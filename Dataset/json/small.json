[
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -589,11 +589,6 @@\n                 return;\n             }\n \n-            // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n-            }\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n                 work1[pj] /= work2[j];\n@@ -612,9 +607,14 @@\n             // depending on the sign of the function, update parl or paru.\n             if (fp > 0) {\n                 parl = FastMath.max(parl, lmPar);\n-            } else if (fp < 0) {\n-                paru = FastMath.min(paru, lmPar);\n-            }\n+            } else {\n+                for (int j = rank; j < cols; ++j) {\n+                    lmDir[permutation[j]] = 0;\n+                }\n+                if (fp < 0) {\n+                    paru = FastMath.min(paru, lmPar);\n+                }\n+            }\n \n             // compute an improved estimate for lmPar\n             lmPar = FastMath.max(parl, lmPar + correction);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -98,7 +98,7 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (n.isExprResult()) {\n       return;\n     }\n \n@@ -110,7 +110,24 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n+    if (parent.getType() == Token.COMMA) {\n+      if (isResultUsed) {\n+        return;\n+      }\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n+          else break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n+        return;\n+      }\n+    }\n+    if (\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -352,11 +352,6 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n-            if (resetFields) {\n-                for (int i = 0; i < count; i++) {\n-                    millis = savedFields[i].set(millis, i == (count - 1));\n-                }\n-            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Lang",
        "content": "@@ -192,12 +192,14 @@\n                 case 'L' :\n-                    if (dec == null\n+                    if ((1) != (val.length())) {\n+                        if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n-                        try {\n-                            return createLong(numeric);\n-                        } catch (NumberFormatException nfe) {\n-                            //Too big for a long\n+                            try {\n+                                return createLong(numeric);\n+                            } catch (NumberFormatException nfe) {\n+                                //Too big for a long\n+                            }\n+                            return createBigInteger(numeric);\n+                            \n                         }\n-                        return createBigInteger(numeric);\n-\n                     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Math",
        "content": "@@ -150,6 +150,9 @@\n      public Complex add(Complex rhs)\n          throws NullArgumentException {\n          MathUtils.checkNotNull(rhs);\n+         if (isNaN || rhs.isNaN) {\n+             return NaN;\n+         }\n          return createComplex(real + rhs.getReal(),\n              imaginary + rhs.getImaginary());\n      }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -882,8 +882,11 @@\n           return true;\n \n         case EOF:\n-          // discard any accumulated information\n-          jsdocBuilder.build(null);\n+          {\n+            if (true)\n+                return true;\n+            jsdocBuilder.build(null);\n+        }\n           parser.addParserWarning(\"msg.unexpected.eof\",\n               stream.getLineno(), stream.getCharno());\n           checkExtendedTypes(extendedTypes);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -297,6 +297,9 @@\n \n     /** {@inheritDoc} */\n     public Complex reciprocal() {\n+    \tif((real == 0.0 && imaginary == 0.0) == true){\n+    \t\treturn this.INF;\n+    \t\t}\n         if (isNaN) {\n             return NaN;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Lang",
        "content": "@@ -3295,7 +3295,7 @@\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(256);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n@@ -3380,7 +3380,7 @@\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n+        StringBuilder buf = new StringBuilder(256);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return INF;\n+            return NaN;\n         }\n \n         if (isInfinite) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -282,7 +282,7 @@\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+        CodeGenerator.Context rhsContext=CodeGenerator.Context.IN_FOR_INIT_CLAUSE;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -464,20 +464,11 @@ public class NumberUtils {\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n-            char firstSigDigit = 0; // strip leading zeroes\n-            for(int i = pfxLen; i < str.length(); i++) {\n-                firstSigDigit = str.charAt(i);\n-                if (firstSigDigit == '0') { // count leading zeroes\n-                    pfxLen++;\n-                } else {\n-                    break;\n-                }\n-            }\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long\n+            if (hexDigits > 16) { // too many for Long\n                 return createBigInteger(str);\n             }\n-            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int\n+            if (hexDigits > 8) { // too many for an int\n                 return createLong(str);\n             }\n             return createInteger(str);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Chart",
        "content": "@@ -149,7 +149,7 @@\n                 contentSize = arrangeFN(container, g2, constraint.getWidth());\n             }\n             else if (h == LengthConstraintType.FIXED) {\n-                contentSize = arrangeFF(container, g2, constraint);\n+                contentSize = new Size2D(constraint.getWidth(), constraint.getHeight());\n             }\n             else if (h == LengthConstraintType.RANGE) {\n                 contentSize = arrangeFR(container, g2, constraint);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+ \tif (fa * fb >= 0.0 &&!(fa * fb==0.0)) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Chart",
        "content": "@@ -941,7 +941,7 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if ((endIndex < 0)  || (endIndex < startIndex)) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n+        super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -105,8 +105,6 @@ public final class NodeUtil {\n         // ignoring side-effects\n         return TernaryValue.TRUE;\n \n-      case Token.VOID:\n-        return TernaryValue.FALSE;\n \n       default:\n         return getPureBooleanValue(n);\n@@ -135,10 +133,7 @@ public final class NodeUtil {\n         return TernaryValue.FALSE;\n \n       case Token.VOID:\n-        if (!mayHaveSideEffects(n.getFirstChild())) {\n           return TernaryValue.FALSE;\n-        }\n-        break;\n \n       case Token.NAME:\n         String name = n.getString();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -349,7 +349,11 @@\n               coefficients[i] = 0;\n           } else {\n               basicRows.add(basicRow);\n-              coefficients[i] =\n+              for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n+                int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n+                subtractRow(0, row, 1.0);\n+            }\n+            coefficients[i] =\n                   (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                   (restrictToNonNegative ? 0 : mostNegative);\n           }\n\n\n@@ -60,7 +60,6 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -116,7 +116,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n-            if (tableau.getNumArtificialVariables() > 0) {\n                 for (Integer row : minRatioPositions) {\n                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                         int column = i + tableau.getArtificialVariableOffset();\n@@ -126,7 +125,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n                         }\n                     }\n                 }\n-            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n@@ -137,7 +135,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // Additional heuristic: if we did not get a solution after half of maxIterations\n             //                       revert to the simple case of just returning the top-most row\n             // This heuristic is based on empirical data gathered while investigating MATH-828.\n-            if (getIterations() < getMaxIterations() / 2) {\n                 Integer minRow = null;\n                 int minIndex = tableau.getWidth();\n                 for (Integer row : minRatioPositions) {\n@@ -152,7 +149,6 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n                     }\n                 }\n                 return minRow;\n-            }\n         }\n         return minRatioPositions.get(0);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if ((dataset) == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -1216,7 +1216,9 @@\n         if (info != null) {\n             plotInfo = info.getPlotInfo();\n         }\n-        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        if (false) {\n+            this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        }\n \n         g2.setClip(savedClip);\n ",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * (n - 1);\n+            int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return org.apache.commons.math.util.MathUtils.equals(x, y, 1);\n     }\n \n     /**",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Chart",
        "content": "@@ -145,7 +145,8 @@\n         this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n-        this.pieChart.removeLegend();\n+        setDataset(dataset);\n+        this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n         TextTitle seriesTitle = new TextTitle(\"Series Title\",\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Chart",
        "content": "@@ -882,3 +882,5 @@\n         if (end < start) {\n-            throw new IllegalArgumentException(\"Requires start <= end.\");\n+            if (org.jfree.data.time.TimeSeries.DEFAULT_RANGE_DESCRIPTION.length() == org.jfree.data.time.TimeSeries.this.data.size()) {\n+                throw new IllegalArgumentException(\"Requires start <= end.\");\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options)!=null)&&(options.dependencyOptions.needsManagement())){\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -665,4 +665,8 @@\n             entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (this.DEFAULT_ZERO_TOLERANCE == this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -224,6 +224,6 @@\n     protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        if ((!(lower < initial)) || ((org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result <= lower) && (1 == lower))) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n-                    lower, initial, upper);\n+            \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+            lower, initial, upper);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -62,3 +62,5 @@\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (false) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                 minPos = i;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return availableLocaleList().contains(locale);\n+        return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Lang",
        "content": "@@ -485,7 +485,7 @@\n             }\n             mant = str.substring(0, decPos);\n         } else {\n-            if (expPos > -1) {\n+            if (false) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Nopol/Lang",
        "content": "@@ -243,3 +243,5 @@\n                     case '/' :\n-                            out.write('\\\\');\n+                            if (escapeSingleQuote) {\n+                                out.write('\\\\');\n+                            }\n                         out.write('/');\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -159,7 +159,7 @@\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(min, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -324,7 +324,7 @@\n                     // procedure cannot produce sensible results.\n \n                 a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n+if (c2==0.0){throw new MathIllegalStateException();}                omega = FastMath.sqrt(c2 / c3);\n             }\n         }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Math",
        "content": "@@ -291,6 +291,16 @@\n         interpolator.storeTime(stepStart + stepSize);\n         if (manager.evaluateStep(interpolator)) {\n             final double dt = manager.getEventTime() - stepStart;\n+        // start of generated patch\n+            if(Math.abs(dt)<=Math.ulp(stepStart)){\n+              System.arraycopy(y,0,yTmp,0,y0.length);\n+              stepSize=0;\n+              loop=false;\n+            }else {\n+              stepSize=dt;\n+            }\n+        // end of generated patch\n+        /* start of original code\n             if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                 // we cannot simply truncate the step, reject the current computation\n                 // and let the loop compute another state with the truncated step.\n@@ -302,6 +312,7 @@\n                 // reject the step to match exactly the next switch time\n                 stepSize = dt;\n             }\n+        end of original code*/\n         } else {\n           loop = false;\n         }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -619,7 +619,7 @@\n             upper = str.length();\n         }\n         // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if ((upper < lower) && (upper != str.length())) {\n             upper = lower;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -117,7 +117,7 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if ((ancestorType == Token.COMMA) || (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK)) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -194,7 +194,7 @@\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+          if(target!=null&&target.getType()==Token.STRING){\n             className = target.getString();\n           }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -94,8 +94,7 @@\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (excerpt.equals(LINE) || 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -1438,7 +1438,7 @@\n       JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n       if (valueType == null && rhsValue != null) {\n         // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+        valueType = ownerNode.getJSType();\n       }\n       // Function prototypes are special.\n       // It's a common JS idiom to do:\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Chart",
        "content": "@@ -560,7 +560,7 @@\n \n \n \n-            if (this.autoSort) {\n+            if (false) {\n                 this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x, y));\n             }else \n             {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -3672,7 +3672,7 @@\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n+        for (int i = 0; i==searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -858,7 +858,7 @@\n       // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n-      options.messageBundle = new EmptyMessageBundle();\n+      \n     }\n \n     return options;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -300,9 +300,7 @@\n             final long a1 = (long) FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((p2 > overflow) || (q2 > overflow)) {\n-                // in maxDenominator mode, if the last fraction was very close to the actual value\n-                // q2 may overflow in the next iteration; in this case return the last one.\n+            if((n<maxIterations)&&(FastMath.abs(value-value)>epsilon)){\n                 throw new FractionConversionException(value, p2, q2);\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -559,16 +559,7 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n-        if (m instanceof DiagonalMatrix) {\n-            final int dim = m.getRowDimension();\n-            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n-            for (int i = 0; i < dim; i++) {\n-               sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n-            }\n-            return sqrtM;\n-        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n-        }\n     }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -342,7 +342,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeDivide(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n@@ -355,7 +355,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeDivide(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n@@ -367,7 +367,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeMultiply(RealVector v) {\n         checkVectorDimensions(v.getDimension());\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n@@ -380,7 +380,7 @@ public class OpenMapRealVector extends AbstractRealVector\n     public OpenMapRealVector ebeMultiply(double[] v) {\n         checkVectorDimensions(v.length);\n         OpenMapRealVector res = new OpenMapRealVector(this);\n-        Iterator iter = entries.iterator();\n+        Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n             res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -282,7 +282,7 @@ class CodeGenerator {\n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = getContextForNoInOperator(context);\n+        Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -256,8 +256,8 @@ public class Fraction extends Number implements Comparable<Fraction> {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        long nOd = ((long) numerator) * object.denominator;\n-        long dOn = ((long) denominator) * object.numerator;\n+        double nOd = doubleValue();\n+        double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -145,7 +145,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return d;\n     }\n     \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -184,10 +184,14 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+                \tif((x == x1) == true){\n+                \t\tx1=x;\n+                \t\t}else{\n                     if (x == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n+                \t\t}\n                     break;\n                 default:\n                     // Should never happen.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -154,7 +154,6 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n                 && this.minimumRangeValueColumn == c))  {\n             updateBounds();\n         }\n-        else {\n         \n             double minval = Double.NaN;\n             if (item.getMinOutlier() != null) {\n@@ -186,7 +185,6 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n                 this.minimumRangeValueRow = r;\n                 this.minimumRangeValueColumn = c;\n             }\n-        }\n         \n         this.rangeBounds = new Range(this.minimumRangeValue,\n               this.maximumRangeValue);\n@@ -740,44 +738,7 @@ public class DefaultBoxAndWhiskerCategoryDataset extends AbstractDataset\n      */\n     private void updateBounds() {\n         this.minimumRangeValue = Double.NaN;\n-        this.minimumRangeValueRow = -1;\n-        this.minimumRangeValueColumn = -1;\n         this.maximumRangeValue = Double.NaN;\n-        this.maximumRangeValueRow = -1;\n-        this.maximumRangeValueColumn = -1;\n-        int rowCount = getRowCount();\n-        int columnCount = getColumnCount();\n-        for (int r = 0; r < rowCount; r++) {\n-            for (int c = 0; c < columnCount; c++) {\n-                BoxAndWhiskerItem item = getItem(r, c);\n-                if (item != null) {\n-                    Number min = item.getMinOutlier();\n-                    if (min != null) {\n-                        double minv = min.doubleValue();\n-                        if (!Double.isNaN(minv)) {\n-                            if (minv < this.minimumRangeValue || Double.isNaN(\n-                                    this.minimumRangeValue)) {\n-                                this.minimumRangeValue = minv;\n-                                this.minimumRangeValueRow = r;\n-                                this.minimumRangeValueColumn = c;\n-                            }\n-                        }\n-                    }\n-                    Number max = item.getMaxOutlier();\n-                    if (max != null) {\n-                        double maxv = max.doubleValue();\n-                        if (!Double.isNaN(maxv)) {\n-                            if (maxv > this.maximumRangeValue || Double.isNaN(\n-                                    this.maximumRangeValue)) {\n-                                this.maximumRangeValue = maxv;\n-                                this.maximumRangeValueRow = r;\n-                                this.maximumRangeValueColumn = c;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n     }\n     \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -155,13 +155,13 @@ public class SummaryStatistics implements StatisticalSummary, Serializable {\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (meanImpl != mean) {\n+        if (!(meanImpl instanceof Mean)) {\n             meanImpl.increment(value);\n         }\n-        if (varianceImpl != variance) {\n+        if (!(varianceImpl instanceof Variance)) {\n             varianceImpl.increment(value);\n         }\n-        if (geoMeanImpl != geoMean) {\n+        if (!(geoMeanImpl instanceof GeometricMean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -19,7 +19,7 @@ package org.apache.commons.math.distribution;\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n@@ -91,7 +91,7 @@ public class PoissonDistributionImpl extends AbstractIntegerDistribution\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, p);\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -326,7 +326,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null || requiresLevel.isOn()) {\n+      if (provided != null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -62,7 +62,7 @@ public class StandardToolTipTagFragmentGenerator\n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText) \n+        return \" title=\\\"\" + toolTipText\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Chart",
        "content": "@@ -4490,6 +4490,7 @@\n                     }\n                 }\n \n+                if (r != null) {\n                     Collection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n@@ -4498,6 +4499,7 @@\n                             includedAnnotations.add(a);\n                         }\n                     }\n+                }\n             }\n         }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -138,6 +138,10 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n+      if (NodeUtil.hasFinally(n)) {\n+        Node finallyBlock = n.getLastChild();\n+        tryMinimizeExits(finallyBlock, exitType, labelName);\n+      }\n     }\n \n     // Just a 'label'.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -363,7 +363,6 @@ class GlobalNamespace\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n-              case Token.CATCH:\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -332,8 +332,10 @@\n         }\n         Range range = (Range) obj;\n         if (!(this.lower == range.lower)) {\n+            if (((1 + org.jfree.data.Range.this.lower) - (-1) < org.jfree.data.Range.this.upper) || (org.jfree.data.Range.this.lower <= 0)) {\n             return false;\n         }\n+        }\n         if (!(this.upper == range.upper)) {\n             return false;\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -79,13 +79,14 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+ \tif (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n             }\n+\n         }\n         return minRatioPos;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -106,7 +106,7 @@\n     public Number getMeanValue(int row, int column) {\n         Number result = null;\n         MeanAndStandardDeviation masd \n-            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n+            = (MeanAndStandardDeviation) this.data.getObject((int)this.minimumRangeValue, column);\n         if (masd != null) {\n             result = masd.getMean();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == 0.0 || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -112,7 +112,7 @@\n \n         if (minRatioPositions.size() == 0) {\n             return null;\n-        } else if (minRatioPositions.size() > 1) {\n+  } else if (minRatioPositions.size() > 1&&!(minRatioPositions.size()>(double)0.0)) {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -82,7 +82,11 @@\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n+                \tif((rhs > minRatio) == false){\n+                \t\tminRatio=rhs;\n+                \t\t}else{\n                     minRatio = ratio;\n+                \t\t}\n                     minRatioPos = i; \n                 }\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Lang",
        "content": "@@ -581,7 +581,7 @@\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (false) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Chart",
        "content": "@@ -443,9 +443,11 @@\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (null!=null) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -441,7 +441,7 @@\n             h[1] = size.height;\n         }\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n+        if ((this.leftBlock != null) && !(this.rightBlock != null)) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n                     LengthConstraintType.RANGE, h[2], null,\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -195,13 +195,8 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+if(fa*upperBound>=0.0){\n+throw new ConvergenceException(\"number of iterations={0}, maximum iterations={1}, \"+\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \",numIterations,maximumIterations,initial,lowerBound,upperBound,a,b,fa,fb);\n         }\n         \n         return new double[]{a, b};\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -184,7 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if(x==x0){\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -197,6 +197,8 @@\n                          int pass) {\n \n         // defensive check\n+        if (true)\n+            return ;\n         if (!(data instanceof StatisticalCategoryDataset)) {\n             throw new IllegalArgumentException(\n                 \"Requires StatisticalCategoryDataset.\");\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Chart",
        "content": "@@ -123,7 +123,7 @@\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((v - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NULL_ARGUMENT_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&((initial)!=0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -1188,6 +1188,9 @@\n \n         }\n         if (plotState != null && hotspot != null) {\n+        \tif((null == plotState.getOwner()) == true){\n+        \t\treturn state;\n+        \t\t}\n             ChartRenderingInfo owner = plotState.getOwner();\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n\n ",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -1189,13 +1189,11 @@ public abstract class Axis implements Cloneable, Serializable {\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n-            if (owner != null) {\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n                 }\n-            }\n         }\n         return state;\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -2290,7 +2290,7 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = getAnnotations().remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Math",
        "content": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return org.apache.commons.math.util.MathUtils.equals(x, y, 1) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1526,6 +1526,8 @@\n             } else if (dMin == dN2) {\n \n                 // case 5.\n+                if (true)\n+                    return ;\n                 tType = -5;\n                 double s = 0.25 * dMin;\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options.dependencyOptions)!=null)&&(options.dependencyOptions.needsManagement())){\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -123,6 +123,9 @@\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n+        if((v == value) == false){\n+        \t\tvalue=v;\n+        \t}\n         int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -669,6 +669,10 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n+                if((ch == 'y') == false){\n+                \treturn ch == 'Y';\n+\n+                \t}\n                 if (ch == 'y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -1111,7 +1111,7 @@\n      * @throws IndexOutOfBoundsException if any index is invalid\n      */\n     private void deleteImpl(int startIndex, int endIndex, int len) {\n-        System.arraycopy(buffer, endIndex, buffer, startIndex, size - endIndex);\n+        System.arraycopy(buffer, endIndex, buffer, startIndex, capacity() - endIndex);\n         size -= len;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -34,7 +34,7 @@ public class Gamma implements Serializable {\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-15;\n+    private static final double DEFAULT_EPSILON = 10e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Lang",
        "content": "@@ -679,6 +679,7 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n+                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -1538,7 +1538,7 @@\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y == (long) y)) {\n                 return pow(-x, y);\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -2163,9 +2163,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2448,9 +2445,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2290,9 +2290,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2529,9 +2526,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Zoomable,\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n-        if (markers == null) {\n-            return false;\n-        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -674,7 +674,7 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n-                if (ch == 'Y') {\n+                if (str!=null) {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -116,7 +116,7 @@\n       }\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType = parent.getType();\n           if (ancestorType == Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -135,7 +135,8 @@\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+  if (sign >= 0&&!(sign<=(double)0.546842)) {\n+\n             // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -1625,19 +1625,13 @@ public final class Period\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            long totalMonths = years * 12L + months;\n-            if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n-                int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n-                result = result.withYears(normalizedYears);\n-                totalMonths = totalMonths - (normalizedYears * 12);\n+            years = FieldUtils.safeAdd(years, months / 12);\n+            months = months % 12;\n+            if (years != 0) {\n+                result = result.withYears(years);\n             }\n-            if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n-                int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n-                result = result.withMonths(normalizedMonths);\n-                totalMonths = totalMonths - normalizedMonths;\n-            }\n-            if (totalMonths != 0) {\n-                throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n+            if (months != 0) {\n+                result = result.withMonths(months);\n             }\n         }\n         return result;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Closure",
        "content": "@@ -728,7 +728,6 @@\n       if (fnParam != null) {\n         if (cArg != null) {\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -669,7 +669,7 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if ((ch == 'y') || !(ch == 'Y')) {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -181,43 +181,30 @@ public final class MathUtils {\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n+        long result = Math.round(binomialCoefficientDouble(n, k));\n+        if (result == Long.MAX_VALUE) {\n+            throw new ArithmeticException(\n+                \"result too large to represent in a long integer\");\n+        }\n         // Use symmetry for large k\n-        if (k > n / 2)\n-            return binomialCoefficient(n, n - k);\n         \n         // We use the formula\n         // (n choose k) = n! / (n-k)! / k!\n         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n         // which could be written\n         // (n choose k) == (n-1 choose k-1) * n / k\n-        long result = 1;\n-        if (n <= 61) {\n             // For n <= 61, the naive implementation cannot overflow.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n-                result = result * i / j;\n-            }\n-        } else if (n <= 66) {\n             // For n > 61 but n <= 66, the result cannot overflow,\n             // but we must take care not to overflow intermediate values.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n                 // We know that (result * i) is divisible by j,\n                 // but (result * i) may overflow, so we split j:\n                 // Filter out the gcd, d, so j/d and i/d are integer.\n                 // result is divisible by (j/d) because (j/d)\n                 // is relative prime to (i/d) and is a divisor of\n                 // result * (i/d).\n-                long d = gcd(i, j);\n-                result = (result / (j / d)) * (i / d);\n-            }\n-        } else {\n             // For n > 66, a result overflow might occur, so we check\n             // the multiplication, taking care to not overflow\n             // unnecessary.\n-            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n-                long d = gcd(i, j);\n-                result = mulAndCheck((result / (j / d)), (i / d));\n-            }\n-        }\n         return result;\n     }\n \n@@ -244,33 +231,9 @@ public final class MathUtils {\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n-        if (n < k) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= 0 for binomial coefficient (n,k)\");\n-        }\n-        if ((n == k) || (k == 0)) {\n-            return 1d;\n-        }\n-        if ((k == 1) || (k == n - 1)) {\n-            return n;\n-        }\n-        if (k > n/2) {\n-            return binomialCoefficientDouble(n, n - k);\n-        }\n-        if (n < 67) {\n-            return binomialCoefficient(n,k);\n-        }\n         \n-        double result = 1d;\n-        for (int i = 1; i <= k; i++) {\n-             result *= (double)(n - k + i) / (double)i;\n-        }\n   \n-        return Math.floor(result + 0.5);\n+        return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n     }\n     \n     /**\n@@ -311,17 +274,11 @@ public final class MathUtils {\n          * For values small enough to do exact integer computation,\n          * return the log of the exact value \n          */\n-        if (n < 67) {  \n-            return Math.log(binomialCoefficient(n,k));\n-        }\n         \n         /*\n          * Return the log of binomialCoefficientDouble for values that will not\n          * overflow binomialCoefficientDouble\n          */\n-        if (n < 1030) { \n-            return Math.log(binomialCoefficientDouble(n, k));\n-        } \n         \n         /*\n          * Sum logs for values that could overflow\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -134,7 +134,7 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (tmp >= upper) {\n                 upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -764,7 +764,7 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n+              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SketchFix/Math",
        "content": "@@ -184,10 +184,6 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n                     break;\n                 default:\n                     // Should never happen.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -107,7 +107,7 @@\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}            addValue((Comparable<?>) v);            \n     }\n     \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -61,7 +61,6 @@ public class MultiDirectional extends DirectSearchOptimizer {\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n-        final RealConvergenceChecker checker = getConvergenceChecker();\n         while (true) {\n \n             incrementIterationsCounter();\n@@ -90,16 +89,8 @@ public class MultiDirectional extends DirectSearchOptimizer {\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n-                return;\n-            }\n \n             // check convergence\n-            final int iter = getIterations();\n-            boolean converged = true;\n-            for (int i = 0; i < simplex.length; ++i) {\n-                converged &= checker.converged(iter, original[i], simplex[i]);\n-            }\n-            if (converged) {\n                 return;\n             }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -3673,7 +3673,7 @@\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n+            int greater = searchList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -150,6 +150,10 @@\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if((rhs.isNaN() || isInfinite()) == true){\n+        \treturn this.NaN;\n+\n+        \t}\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * b >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -216,9 +216,9 @@ public class TypeUtils {\n                 toClass, typeVarAssigns);\n \n         // now to check each type argument\n-        for (TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n-            Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n-            Type fromTypeArg = unrollVariableAssignments(var, fromTypeVarAssigns);\n+        for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n+            Type toTypeArg = entry.getValue();\n+            Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n \n             // parameters must either be absent from the subject type, within\n             // the bounds of the wildcard type, or be an exact match to the\n@@ -672,7 +672,7 @@ public class TypeUtils {\n                 : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n \n         // has target class been reached?\n-        if (toClass.equals(cls)) {\n+        if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n             return typeVarAssigns;\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -1534,7 +1534,7 @@\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (this.work[np - 8] != b2 || this.work[np - 4] > b1) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -354,6 +354,7 @@\n      * @param divisor value of the divisor\n      */\n     protected void divideRow(final int dividendRow, final double divisor) {\n+        if(org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables)\n         for (int j = 0; j < getWidth(); j++) {\n             tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -63,32 +63,22 @@ public class DefaultNameProvider implements NameProvider {\n         if (byNameKeyCache == null) {\n             byIdCache.put(id, byNameKeyCache = createCache());\n             \n-            String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n-            String[] setEn = null;\n-            for (String[] strings : zoneStringsEn) {\n-              if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n-                setEn = strings;\n-                break;\n-              }\n-            }\n             String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings();\n             String[] setLoc = null;\n             for (String[] strings : zoneStringsLoc) {\n               if (strings != null && strings.length == 5 && id.equals(strings[0])) {\n                 setLoc = strings;\n-                break;\n-              }\n-            }\n             \n-            if (setEn != null && setLoc != null) {\n-              byNameKeyCache.put(setEn[2], new String[] {setLoc[2], setLoc[1]});\n+              byNameKeyCache.put(setLoc[2], new String[] {setLoc[2], setLoc[1]});\n               // need to handle case where summer and winter have the same\n               // abbreviation, such as EST in Australia [1716305]\n               // we handle this by appending \"-Summer\", cf ZoneInfoCompiler\n-              if (setEn[2].equals(setEn[4])) {\n-                  byNameKeyCache.put(setEn[4] + \"-Summer\", new String[] {setLoc[4], setLoc[3]});\n+              if (setLoc[2].equals(setLoc[4])) {\n+                  byNameKeyCache.put(setLoc[4] + \"-Summer\", new String[] {setLoc[4], setLoc[3]});\n               } else {\n-                  byNameKeyCache.put(setEn[4], new String[] {setLoc[4], setLoc[3]});\n+                  byNameKeyCache.put(setLoc[4], new String[] {setLoc[4], setLoc[3]});\n+              }\n+                break;\n               }\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1015,15 +1015,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      * @since 1.2\n      */\n     public Complex tan() {\n-        if (isNaN || Double.isInfinite(real)) {\n+        if (isNaN) {\n             return NaN;\n         }\n-        if (imaginary > 20.0) {\n-            return createComplex(0.0, 1.0);\n-        }\n-        if (imaginary < -20.0) {\n-            return createComplex(0.0, -1.0);\n-        }\n \n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n@@ -1066,15 +1060,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      * @since 1.2\n      */\n     public Complex tanh() {\n-        if (isNaN || Double.isInfinite(imaginary)) {\n+        if (isNaN) {\n             return NaN;\n         }\n-        if (real > 20.0) {\n-            return createComplex(1.0, 0.0);\n-        }\n-        if (real < -20.0) {\n-            return createComplex(-1.0, 0.0);\n-        }\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -1525,8 +1525,6 @@\n                 }\n             } else if (dMin == dN2) {\n \n-                // case 5.\n-                tType = -5;\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n@@ -1541,7 +1539,6 @@\n \n                 // approximate contribution to norm squared from i < nn-2.\n                 if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                         if (b2 == 0.0) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1429,7 +1429,7 @@ public class Compiler extends AbstractCompiler {\n \n         // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n         // for the first input file\n-        String code = toSource(root, sourceMap, inputSeqNum == 0);\n+        String code = toSource(root, sourceMap);\n         if (!code.isEmpty()) {\n           cb.append(code);\n \n@@ -1458,19 +1458,19 @@ public class Compiler extends AbstractCompiler {\n   @Override\n   String toSource(Node n) {\n     initCompilerOptionsIfTesting();\n-    return toSource(n, null, true);\n+    return toSource(n, null);\n   }\n \n   /**\n    * Generates JavaScript source code for an AST.\n    */\n-  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n+  private String toSource(Node n, SourceMap sourceMap) {\n     CodePrinter.Builder builder = new CodePrinter.Builder(n);\n     builder.setPrettyPrint(options.prettyPrint);\n     builder.setLineBreak(options.lineBreak);\n     builder.setSourceMap(sourceMap);\n     builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n-    builder.setTagAsStrict(firstOutput &&\n+    builder.setTagAsStrict(\n         options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n     builder.setLineLengthThreshold(options.lineLengthThreshold);\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -326,18 +326,19 @@ class SimplexTableau implements Serializable {\n         Integer basicRow =\n             getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n-        Set<Integer> basicRows = new HashSet<Integer>();\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n-            if (basicRows.contains(basicRow)) {\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n-                coefficients[i] = 0;\n-            } else {\n-                basicRows.add(basicRow);\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n+            if (basicRow != null) {\n+                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n+                    if (tableau.getEntry(basicRow, j) == 1) {\n+                         coefficients[i] = 0;\n+                    }\n+                }\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -142,7 +142,6 @@\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                         if (row == tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n-                                minIndex = i;\n                                 minRow = row;\n                             }\n                         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1095,6 +1095,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n     private static class TimeZoneNameRule implements Rule {\n         private final Locale mLocale;\n         private final int mStyle;\n+        private final TimeZone zone;\n         private final String mStandard;\n         private final String mDaylight;\n \n@@ -1108,6 +1109,7 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n         TimeZoneNameRule(TimeZone timeZone, Locale locale, int style) {\n             mLocale = locale;\n             mStyle = style;\n+            zone = timeZone;\n             \n             mStandard = getTimeZoneDisplay(timeZone, false, style, locale);\n             mDaylight = getTimeZoneDisplay(timeZone, true, style, locale);\n@@ -1129,7 +1131,6 @@ public class FastDatePrinter implements DatePrinter, Serializable {\n          */\n         @Override\n         public void appendTo(StringBuffer buffer, Calendar calendar) {\n-            TimeZone zone = calendar.getTimeZone();\n             if (zone.useDaylightTime()\n                     && calendar.get(Calendar.DST_OFFSET) != 0) {\n                 buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -1135,7 +1135,9 @@\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n+                    if (true)\n+                        return true;\n+                    final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jGenProg/Math",
        "content": "@@ -150,8 +150,11 @@\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        return createComplex(real + rhs.getReal(),\n-            imaginary + rhs.getImaginary());\n+\tif ((isNaN) || (rhs.isNaN)) {\n+            return NaN;\n+        }\n+        return createComplex((real) + (rhs.getReal()),\n+            (imaginary) + (rhs.getImaginary()));\n     }\n \n     /**\n@@ -172,7 +175,7 @@\n         if (isNaN) {\n             return NaN;\n         }\n-        return createComplex(real, -imaginary);\n+        return createComplex(real, (-(imaginary)));\n     }\n \n     /**\n@@ -213,7 +216,7 @@\n     public Complex divide(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n+        if ((isNaN) || (rhs.isNaN)) {\n             return NaN;\n         }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -456,7 +456,9 @@\n             System.arraycopy(iTypes, 0, newTypes, 0, i);\n             System.arraycopy(iValues, 0, newValues, 0, i);\n             newTypes[i] = fieldType;\n+            if (((20) - (value + newTypes.length) < value) || ((2) != (org.joda.time.Partial.this.iTypes.length))) {\n             newValues[i] = value;\n+            }\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -111,9 +111,6 @@ public class LocaleUtils {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             char ch3 = str.charAt(3);\n-            if (ch3 == '_') {\n-                return new Locale(str.substring(0, 2), \"\", str.substring(4));\n-            }\n             char ch4 = str.charAt(4);\n             if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n+                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -108,7 +108,7 @@\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (false) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -167,22 +167,13 @@ class UnreachableCodeElimination implements CompilerPass {\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) {\n+            if (nextCfgNode == fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n \n-    private boolean inFinally(Node parent, Node child) {\n-      if (parent == null || parent.isFunction()) {\n-        return false;\n-      } else if (NodeUtil.isTryFinallyNode(parent, child)) {\n-        return true;\n-      } else {\n-        return inFinally(parent.getParent(), parent);\n-      }\n-    }\n \n     private Node computeFollowing(Node n) {\n       Node next = ControlFlowAnalysis.computeFollowNode(n);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -212,7 +212,8 @@\n      */\n     public double getNumericalVariance() {\n         if (!numericalVarianceIsCalculated) {\n-            numericalVariance = calculateNumericalVariance();\n+            final double logm = FastMath.log(denominatorDegreesOfFreedom);\n+            numericalVariance = calculateNumericalVariance();\n             numericalVarianceIsCalculated = true;\n         }\n         return numericalVariance;\n\n\n@@ -174,8 +174,7 @@\n                                                x);\n             }\n             if (Double.isNaN(hN)) {\n-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n-                                               x);\n+                return -0.0;\n             }\n \n             if (FastMath.abs(deltaN - 1.0) < epsilon) {\n\n\n@@ -83,6 +83,6 @@\n     /** {@inheritDoc} */\n     @Override\n     public String getLocalizedMessage() {\n-        return context.getLocalizedMessage();\n+        return context.getMessage();\n     }\n }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -142,7 +142,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        setDataset(dataset);\n+        this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -694,6 +694,14 @@ class FunctionInjector {\n \n     Node block = fnNode.getLastChild();\n \n+    boolean hasSideEffects = false;\n+    if (block.hasChildren()) {\n+      Preconditions.checkState(block.hasOneChild());\n+      Node stmt = block.getFirstChild();\n+      if (stmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n+      }\n+    }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n \n@@ -719,6 +727,9 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+            return CanInlineResult.NO;\n+          }\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -109,7 +109,7 @@\n         }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+          if (apply(c)) {\n             return true;\n           }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -112,6 +112,9 @@\n      * @throws IllegalStateException if the StopWatch is not running.\n      */\n     public void stop() {\n+    \tif((this.runningState > 0) == true){\n+    \t\treturn;\n+    \t\t}\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -613,9 +613,6 @@ public class WordUtils {\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n-        if (lower > str.length()) {\n-            lower = str.length();    \n-        }\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -97,7 +97,7 @@\n             }\n           }\n \n-          if (canRemove) {\n+          if (false) {\n             declaration.remove();\n             changed = true;\n           }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -904,8 +904,8 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           && right.getString().equals(\"undefined\"))\n           || (Token.VOID == right.getType()\n               && NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n-    int lhType = getNormalizedNodeType(left);\n-    int rhType = getNormalizedNodeType(right);\n+    int lhType = left.getType();\n+    int rhType = right.getType();\n     switch (lhType) {\n       case Token.VOID:\n         if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n@@ -1071,19 +1071,6 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   /**\n    * @return Translate NOT expressions into TRUE or FALSE when possible.\n    */\n-  private int getNormalizedNodeType(Node n) {\n-    int type = n.getType();\n-    if (type == Token.NOT) {\n-      TernaryValue value = NodeUtil.getPureBooleanValue(n);\n-      switch (value) {\n-        case TRUE:\n-          return Token.TRUE;\n-        case FALSE:\n-          return Token.FALSE;\n-      }\n-    }\n-    return type;\n-  }\n \n   /**\n    * The result of the comparison as a Boolean or null if the\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -186,9 +186,9 @@\n \n         final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));\n \n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n-        }\n+\n+\n+\n \n         return out;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -129,7 +129,7 @@\n      */\n     private static String buildMessage(final Locale locale, final Localizable pattern,\n                                        final Object ... arguments) {\n-        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n+        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(locale);\n     }\n \n     /** Gets the message in a specified locale.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Math",
        "content": "@@ -135,7 +135,7 @@\n \n \n \n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, max, max);\n \n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1282,6 +1282,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n+          !options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -1392,7 +1392,8 @@\n                 // can't have an E at the last byte\n                 return false;\n             }\n-            if (chars[i] == '.') {\n+            if ((chars[i] == '.') || (chars[i] == 'l'\n+                || chars[i] == 'L')) {\n                 if (hasDecPoint || hasExp) {\n                     // two decimal points or dec in exponent\n                     return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -1540,25 +1540,7 @@\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n+                \n \n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -304,7 +304,7 @@\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n+            if((Character.isWhitespace(c)) && !(unquote)) {\n                 if(!wasWhite) {\n                     wasWhite= true;\n                     regex.append(\"\\\\s*+\");\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if ((endIndex < 0)  || (endIndex < startIndex)) {\n+        if (endIndex < 0) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * upperBound >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -131,6 +131,8 @@ public abstract class ContinuedFraction {\n \n         int n = 1;\n         double dPrev = 0.0;\n+        double p0 = 1.0;\n+        double q1 = 1.0;\n         double cPrev = hPrev;\n         double hN = hPrev;\n \n@@ -138,18 +140,34 @@ public abstract class ContinuedFraction {\n             final double a = getA(n, x);\n             final double b = getB(n, x);\n \n-            double dN = a + b * dPrev;\n-            if (Precision.equals(dN, 0.0, small)) {\n-                dN = small;\n-            }\n-            double cN = a + b / cPrev;\n-            if (Precision.equals(cN, 0.0, small)) {\n-                cN = small;\n+            double cN = a * hPrev + b * p0;\n+            double q2 = a * q1 + b * dPrev;\n+            if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n+                double scaleFactor = 1d;\n+                double lastScaleFactor = 1d;\n+                final int maxPower = 5;\n+                final double scale = FastMath.max(a,b);\n+                if (scale <= 0) {  // Can't scale\n+                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n+                }\n+                for (int i = 0; i < maxPower; i++) {\n+                    lastScaleFactor = scaleFactor;\n+                    scaleFactor *= scale;\n+                    if (a != 0.0 && a > b) {\n+                        cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n+                        q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n+                    } else if (b != 0) {\n+                        cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n+                        q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n+                    }\n+                    if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n+                        break;\n+                    }\n+                }\n             }\n \n-            dN = 1 / dN;\n-            final double deltaN = cN * dN;\n-            hN = hPrev * deltaN;\n+            final double deltaN = cN / q2 / cPrev;\n+            hN = cPrev * deltaN;\n \n             if (Double.isInfinite(hN)) {\n                 throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n@@ -164,9 +182,11 @@ public abstract class ContinuedFraction {\n                 break;\n             }\n \n-            dPrev = dN;\n-            cPrev = cN;\n-            hPrev = hN;\n+            dPrev = q1;\n+            cPrev = cN / q2;\n+            p0 = hPrev;\n+            hPrev = cN;\n+            q1 = q2;\n             n++;\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -877,7 +877,7 @@\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -296,28 +296,31 @@\n                 System.arraycopy(y, start, y, 0, nbPoints);\n                 signChangeIndex -= start;\n \n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n-            }\n+            } else {\n+                signChangeIndex = 2;\n+                if (nbPoints == x.length) {\n+                    nbPoints--;\n+                    if (signChangeIndex >= (x.length + 1) / 2) {\n+                        System.arraycopy(x, 1, x, 0, nbPoints);\n+                        System.arraycopy(y, 1, y, 0, nbPoints);\n+                        --signChangeIndex;\n+                    }\n+                }\n+            }\n \n-            // insert the last computed point\n+            yB = nextY;\n+            // insert the last computed point\n             //(by construction, we know it lies inside the tightest bracketing interval)\n             System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n             x[signChangeIndex] = nextX;\n             System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n             y[signChangeIndex] = nextY;\n-            ++nbPoints;\n+            if (agingB >= MAXIMAL_AGING) {\n+                targetY = -REDUCTION_FACTOR * yA;\n+            } else {\n+                targetY = 0;\n+            }\n+            ++nbPoints;\n \n             // update the bracketing interval\n             if (nextY * yA <= 0) {\n@@ -390,8 +393,10 @@\n     public double solve(int maxEval, UnivariateFunction f, double min,\n                         double max, double startValue,\n                         AllowedSolution allowedSolution) {\n-        this.allowed = allowedSolution;\n-        return super.solve(maxEval, f, min, max, startValue);\n+        double x1 = getMax();\n+        this.allowed = allowedSolution;\n+        verifyInterval(min, max);\n+        return super.solve(maxEval, f, min, max, startValue);\n     }\n \n }\n\n\n@@ -293,7 +293,8 @@\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n-            throw new TooManyEvaluationsException(e.getMax());\n+            double initial = getStartValue();\n+            throw new TooManyEvaluationsException(e.getMax());\n         }\n     }\n }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -727,7 +727,7 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((hasSideEffects && NodeUtil.canBeSideEffected(cArg)) && (NodeUtil.mayHaveSideEffects(cArg, compiler))) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -472,6 +472,9 @@\n                 locale = Locale.getDefault();\n             }\n             try {\n+                if(locale!=null){\n+                    key=new Pair(key,locale);\n+                }\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);\n                 String pattern = formatter.toPattern();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -60,7 +60,6 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -100,13 +100,7 @@\n     // fix up the tree in more clever ways when these are removed.\n     if (parent.getType() == Token.COMMA) {\n       Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n+      // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n@@ -114,8 +108,8 @@\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n+            ;\n+        else\n             break;\n         }\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -168,7 +168,7 @@ public class PearsonsCorrelation {\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n+                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1216,7 +1216,7 @@\n         if (info != null) {\n             plotInfo = info.getPlotInfo();\n         }\n-        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n+        fireChartChanged();\n \n         g2.setClip(savedClip);\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -705,9 +705,9 @@ public class DateTimeFormatter {\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n-        int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n+        int defaultYear = chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math.distribution;\n+package org.apache.commons.math.distribution;import  org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n import java.io.Serializable;\n \n@@ -91,7 +91,7 @@\n      */\n     public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n         if (p <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n+if (p <= 0){throw new NotStrictlyPositiveException(null);}            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n         }\n         mean = p;\n         normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -106,3 +106,5 @@\n         if (n == 0) {\n-            xbar = x;\n+            if ((x <= 1) || (y <= x)) {\n+                xbar = x;\n+            }\n             ybar = y;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -152,7 +152,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n     for (Candidate c : candidates) {\n-      if (c.canInline(t.getScope())) {\n+      if (c.canInline()) {\n         c.inlineVariable();\n \n         // If definition c has dependencies, then inlining it may have\n@@ -277,7 +277,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n       return defMetadata.node;\n     }\n \n-    private boolean canInline(final Scope scope) {\n+    private boolean canInline() {\n       // Cannot inline a parameter.\n       if (getDefCfgNode().isFunction()) {\n         return false;\n@@ -372,12 +372,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n                   case Token.REGEXP:\n                   case Token.NEW:\n                     return true;\n-                  case Token.NAME:\n-                    Var var = scope.getOwnSlot(input.getString());\n-                    if (var != null\n-                        && var.getParentNode().isCatch()) {\n-                      return true;\n-                    }\n                 }\n                 return false;\n               }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Math",
        "content": "@@ -142,7 +142,7 @@\n      */\n     protected double getInitialDomain(double p) {\n         double ret;\n-        double d = getDenominatorDegreesOfFreedom();\n+        double d = p - 2.0;\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -843,7 +843,7 @@\n \n \n         final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n+if (len==1.0){return a[0] * b[0];}        double prodHighNext = prodHigh[1];\n         double sHighPrev = prodHighCur + prodHighNext;\n         double sPrime = sHighPrev - prodHighNext;\n         double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -186,9 +186,6 @@\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n-        }\n \n         return out;\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Lang",
        "content": "@@ -907,7 +907,7 @@\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = array[i] == null ? null : array[i].getClass();\n         }\n         return classes;\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -227,6 +227,8 @@\n                      PlotRenderingInfo info) {\n \n         // adjust for insets...\n+        if (true)\n+            return ;\n         RectangleInsets insets = getInsets();\n         insets.trim(plotArea);\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -1134,7 +1134,7 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n+                for(int k=0;k<0;k+=step){\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -303,9 +303,6 @@ public class BigFraction\n             if ((p2 > overflow) || (q2 > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n-                    break;\n-                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n@@ -212,9 +212,6 @@ public class Fraction\n             if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n                 // in maxDenominator mode, if the last fraction was very close to the actual value\n                 // q2 may overflow in the next iteration; in this case return the last one.\n-                if (epsilon == 0.0 && FastMath.abs(q1) < maxDenominator) {\n-                    break;\n-                }\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -301,12 +301,10 @@ class InlineVariables implements CompilerPass {\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime() &&\n+          referenceInfo.isAssignedOnceInLifetime()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n-          (isInlineableDeclaredConstant(v, referenceInfo) ||\n-           referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n           Node nameNode = refs.get(i).getNode();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Lang",
        "content": "@@ -3673,6 +3673,9 @@\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n+            if (searchList[i] == null || replacementList[i] == null) {\n+                continue;\n+            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SOFix/Math",
        "content": "@@ -134,7 +134,7 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (tmp > upper) {\n                 upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -59,7 +59,7 @@\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if ((MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) || (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0)) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -695,8 +695,7 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          long lvalLong = lvalInt & 0xffffffffL;\n-          result = lvalLong >>> rvalInt;\n+          result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -133,7 +133,7 @@\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1118,8 +1118,21 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null) {\n-      type.matchConstraint(constraintObj);\n+    if (constraintObj != null && constraintObj.isRecordType()) {\n+      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      if (objType != null) {\n+        for (String prop : constraintObj.getOwnPropertyNames()) {\n+          JSType propType = constraintObj.getPropertyType(prop);\n+          if (!objType.isPropertyTypeDeclared(prop)) {\n+            JSType typeToInfer = propType;\n+            if (!objType.hasProperty(prop)) {\n+              typeToInfer =\n+                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n+            }\n+            objType.defineInferredProperty(prop, typeToInfer, null);\n+          }\n+        }\n+      }\n     }\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Math",
        "content": "@@ -178,7 +178,7 @@\n         if (p < 0.5) {\n             ret = -(Double.MAX_VALUE);\n         }else {\n-            ret = getMean();\n+            ret = ((standardDeviation) - (standardDeviation)) / ((mean) * (java.lang.Math.sqrt(2.0)));\n         }\n \n         return ret;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -187,7 +187,7 @@ class NamedType extends ProxyObjectType {\n     // makes more sense. Now, resolution via registry is first in order to\n     // avoid triggering the warnings built into the resolution via properties.\n     boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectInheritanceCycle()) {\n+    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n \n@@ -199,7 +199,7 @@ class NamedType extends ProxyObjectType {\n     }\n \n     resolveViaProperties(t, enclosing);\n-    if (detectInheritanceCycle()) {\n+    if (detectImplicitPrototypeCycle()) {\n       handleTypeCycle(t);\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -90,7 +90,7 @@\n      * @return the number of evaluations of the objective function.\n      */\n     public int getIterations() {\n-        return iterations.getCount();\n+        return evaluations.getCount();\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Math",
        "content": "@@ -180,7 +180,7 @@\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2d) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -1133,14 +1133,6 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n             return true;\n         }\n         return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -145,7 +145,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return numeratorDegreesOfFreedom;\n     }\n     \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Chart",
        "content": "@@ -271,7 +271,7 @@\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n-        PathIterator iterator1 = p1.getPathIterator(null);\n+        PathIterator iterator1 = p2.getPathIterator(null);\n         PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -527,7 +527,7 @@\n             return false;\n         }\n         for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n+            if (!equals(x[i], y[i], i)) {\n                 return false;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Lang",
        "content": "@@ -486,9 +486,7 @@\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n-            } else {\n-                mant = str;\n+                mant = str;}else {                 mant = str;\n             }\n             dec = null;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -132,10 +132,7 @@\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n-\n-\n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f,min,initial);\n \n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -111,7 +111,7 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n+          if (ancestorType>=Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n             return;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -256,9 +256,6 @@ public class StatisticalBarRenderer extends BarRenderer\n \n         // BAR X\n         Number meanValue = dataset.getMeanValue(row, column);\n-        if (meanValue == null) {\n-            return;\n-        }\n \n         double value = meanValue.doubleValue();\n         double base = 0.0;\n@@ -315,9 +312,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         }\n \n         // standard deviation lines\n-        Number n = dataset.getStdDevValue(row, column);\n-        if (n != null) {\n-            double valueDelta = n.doubleValue();\n+            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                     + valueDelta, dataArea, yAxisLocation);\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n@@ -346,7 +341,6 @@ public class StatisticalBarRenderer extends BarRenderer\n             line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                      lowVal, rectY + rectHeight * 0.75);\n             g2.draw(line);\n-        }\n         \n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                 column);\n@@ -406,9 +400,6 @@ public class StatisticalBarRenderer extends BarRenderer\n \n         // BAR Y\n         Number meanValue = dataset.getMeanValue(row, column);\n-        if (meanValue == null) {\n-            return;\n-        }\n \n         double value = meanValue.doubleValue();\n         double base = 0.0;\n@@ -465,9 +456,7 @@ public class StatisticalBarRenderer extends BarRenderer\n         }\n \n         // standard deviation lines\n-        Number n = dataset.getStdDevValue(row, column);\n-        if (n != null) {\n-            double valueDelta = n.doubleValue();\n+            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n             double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                     + valueDelta, dataArea, yAxisLocation);\n             double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n@@ -495,7 +484,6 @@ public class StatisticalBarRenderer extends BarRenderer\n             line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                      rectX + rectWidth / 2.0d + 5.0d, lowVal);\n             g2.draw(line);\n-        }\n         \n         CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                 column);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/GenProg/Closure",
        "content": "@@ -140,7 +140,6 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(options.dependencyOptions.needsManagement()){\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/kPAR/Closure",
        "content": "@@ -632,7 +632,7 @@\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n+          JsName name = getName(ns.name, true);\n           if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -110,7 +110,7 @@\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType=parent.getParent().getType();\n           if (ancestorType == Token.COMMA)\n             continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -191,8 +191,7 @@\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n-                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && exp == null || (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -141,9 +141,6 @@ public class FastDateParser implements DateParser, Serializable {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n-        if (patternMatcher.regionStart() != patternMatcher.regionEnd()) {\n-            throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart());\n-        }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -451,7 +451,6 @@\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x == 0.0 ? 0.0 : x > 0.0 ? 1.0 : -1.0)) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -154,7 +154,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n \n   @Override\n   public void process(Node externs, Node root) {\n-    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n+    (new NodeTraversal(compiler, this)).traverse(root);\n   }\n \n   @Override\n@@ -68,7 +68,6 @@ final class MustBeReachingVariableDef extends\n   private static class Definition {\n     final Node node;\n     final Set<Var> depends = Sets.newHashSet();\n-    private boolean unknownDependencies = false;\n \n     Definition(Node node) {\n       this.node = node;\n@@ -394,13 +393,9 @@ final class MustBeReachingVariableDef extends\n         new AbstractCfgNodeTraversalCallback() {\n       @Override\n       public void visit(NodeTraversal t, Node n, Node parent) {\n-        if (n.isName()) {\n+        if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n           Var dep = jsScope.getVar(n.getString());\n-          if (dep == null) {\n-            def.unknownDependencies = true;\n-          } else {\n             def.depends.add(dep);\n-          }\n         }\n       }\n     });\n@@ -432,9 +427,6 @@ final class MustBeReachingVariableDef extends\n     GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n     FlowState<MustDef> state = n.getAnnotation();\n     Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n-    if (def.unknownDependencies) {\n-      return true;\n-    }\n \n     for (Var s : def.depends) {\n       if (s.scope != jsScope) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -76,7 +76,7 @@\n       }\n \n       Node helperCode = parseHelperCode(reducer);\n-      if (helperCode == null) {\n+      if (true) {\n         continue;\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -196,12 +196,12 @@\n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+\n+\n+\n+\n+\n+\n         }\n \n         return new double[]{ a, b };\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -1775,7 +1775,7 @@\n         char[] thisBuf = buffer;\n         int len = thisBuf.length - strLen;\n         outer:\n-        for (int i = startIndex; i < len; i++) {\n+        for(int i=startIndex;i<size;i++){\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -139,7 +139,7 @@\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n       if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+        Node finallyBlock = n.getFirstChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -1538,7 +1538,7 @@\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n+            if ((y >= TWO_POWER_52 || y <= -TWO_POWER_52) && !(y < 8e298 && y > -8e298)) {\n                 return pow(-x, y);\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -552,7 +552,7 @@\n       // Only inline functions that return something.\n       if (block.getFirstChild().isReturn()\n           && block.getFirstChild().getFirstChild() != null) {\n-        return true;\n+        return false;\n       }\n     }\n\n\n@@ -194,22 +194,6 @@\n           && NodeUtil.isGet(parent.getFirstChild())) {\n         Node functionExpression = parent.getFirstChild();\n         decomposeSubExpressions(functionExpression.getNext(), child, state);\n-        // Now handle the call expression\n-        if (isExpressionTreeUnsafe(functionExpression, state.sideEffects)\n-            && functionExpression.getFirstChild() != grandchild) {\n-          // TODO(johnlenz): In Internet Explorer, non-JavaScript objects such\n-          // as DOM objects can not be decomposed.\n-          Preconditions.checkState(allowObjectCallDecomposing(),\n-              \"Object method calls can not be decomposed.\");\n-          // Either there were preexisting side-effects, or this node has\n-          // side-effects.\n-          state.sideEffects = true;\n-\n-          // Rewrite the call so \"this\" is preserved.\n-          Node replacement = rewriteCallExpression(parent, state);\n-          // Continue from here.\n-          parent = replacement;\n-        }\n       } else if (parentType == Token.OBJECTLIT) {\n         decomposeObjectLiteralKeys(parent.getFirstChild(), child, state);\n       } else {\n\n\n@@ -1456,7 +1456,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -255,19 +255,16 @@ public abstract class DateTimeZone implements Serializable {\n         if (hoursOffset == 0 && minutesOffset == 0) {\n             return DateTimeZone.UTC;\n         }\n-        if (hoursOffset < -23 || hoursOffset > 23) {\n-            throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n-        }\n         if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n         int offset = 0;\n         try {\n-            int hoursInMinutes = hoursOffset * 60;\n+            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n             if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n             } else {\n-                minutesOffset = hoursInMinutes + minutesOffset;\n+                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n@@ -283,9 +280,6 @@ public abstract class DateTimeZone implements Serializable {\n      * @return the DateTimeZone object for the offset\n      */\n     public static DateTimeZone forOffsetMillis(int millisOffset) {\n-        if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n-            throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n-        }\n         String id = printOffset(millisOffset);\n         return fixedOffsetZone(id, millisOffset);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -135,7 +135,6 @@\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n             if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n\n\n@@ -154,7 +154,8 @@\n \n         this.membershipMatrix = null;\n         this.points = null;\n-        this.clusters = null;\n+        boolean emptyCluster = false;\n+        this.clusters = null;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -473,7 +473,7 @@\n \n     boolean firstReferenceIsAssigningDeclaration() {\n       int size = references.size();\n-      if (size > 0 && references.get(0).isInitializingDeclaration()) {\n+      if (false) {\n         return true;\n       }\n       return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -869,7 +869,6 @@\n             for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                 if (work[i + 2] <= 0) {\n                     i0 = 1 + i / 4;\n-                    break;\n                 }\n                 if (diagMin >= 4 * offDiagMax) {\n                     diagMin    = Math.min(diagMin, work[i + 4]);\n@@ -1090,7 +1089,8 @@\n                     work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                     dMin = 0.0;\n                     updateSigma(tau);\n-                    return deflatedEnd;\n+                    final int upperStart = 5 * main.length;\n+                    return deflatedEnd;\n                 } else if (dMin < 0.0) {\n                     // tau too big. Select new tau and try again.\n                     if (tType < -22) {\n@@ -1134,11 +1134,15 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n+                if (tType < -22) {\n+                    tau = 0.0;\n+                } else if (dMin1 > 0.0) {\n+                    tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n+                    tType -= 11;\n+                } else {\n+                    tau *= 0.25;\n+                    tType -= 12;\n+                }\n                 j -= 4;\n             }\n             return true;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa)>=0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -335,9 +335,6 @@\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n-            }\n         }\n \n         // non-basic artificial variables\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1794,9 +1794,6 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_TOO_MANY_ARGUMENTS_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -130,6 +130,7 @@\n                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n+if (!(v instanceof Comparable<?>)){throw new ClassCastException();}\n             //TreeMap will throw ClassCastException if v is not comparable\n             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Math",
        "content": "@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct(((Comparable<?> )(v)));\n     }\n \n     /**",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -373,7 +373,7 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n \n     Node right = callTarget.getNext();\n     if (right != null) {\n-      if (right.getNext() != null || !NodeUtil.isImmutableValue(right)) {\n+      if (!NodeUtil.isImmutableValue(right)) {\n         return n;\n       }\n     }\n@@ -386,12 +386,7 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n       return n;\n     }\n \n-    if (right != null && right.getType() == Token.STRING\n-        && \",\".equals(right.getString())) {\n       // \",\" is the default, it doesn't need to be explicit\n-      n.removeChild(right);\n-      reportCodeChange();\n-    }\n \n     String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -174,7 +174,6 @@\n             // Dive down the right side of the assign.\n             parent = next;\n             next = leftSide.getNext();\n-            break;\n           } else {\n             return false;\n           }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x > 0.0 ? 1.0 : -1.0)) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -228,7 +228,7 @@\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n \n-        if (start == 0 && end == 0) {\n+        if(chars==null&&end==0){\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1457,10 +1457,6 @@\n             if (tailZone != null) {\n                 if (tailZone.iStartRecurrence.getNameKey()\n                     .equals(tailZone.iEndRecurrence.getNameKey())) {\n-                    if (ZoneInfoCompiler.verbose()) {\n-                        System.out.println(\"Fixing duplicate recurrent name key - \" +\n-                                           tailZone.iStartRecurrence.getNameKey());\n-                    }\n                     if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                         tailZone = new DSTZone(\n                             tailZone.getID(),\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -183,8 +183,8 @@\n             double r = p2 / q2;\n \n             if (Double.isNaN(r)) {\n-                throw new ConvergenceException(\n-                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                throw new MaxIterationsExceededException(maxIterations,\n+                LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n                   x);\n             }\n             relativeError = FastMath.abs(r / c - 1.0);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1600,11 +1600,7 @@ public class Dfp implements FieldElement<Dfp> {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n-        if (x >= 0 && x < RADIX) {\n             return multiplyFast(x);\n-        } else {\n-            return multiply(newInstance(x));\n-        }\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -310,10 +310,7 @@ public final class NodeUtil {\n   }\n \n   static Double getStringNumberValue(String rawJsString) {\n-    if (rawJsString.contains(\"\\u000b\")) {\n       // vertical tab is not always whitespace\n-      return null;\n-    }\n \n     String s = trimJsWhiteSpace(rawJsString);\n     // return ScriptRuntime.toNumber(s);\n@@ -375,7 +372,7 @@ public final class NodeUtil {\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.UNKNOWN;  // IE says \"no\", EcmaScript says \"yes\"\n+        return TernaryValue.TRUE;\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Math",
        "content": "@@ -302,7 +302,7 @@\n     }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return INF;\n         }\n \n         if (isInfinite) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -679,7 +679,6 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n-                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -96,7 +96,7 @@\n         assignPointsToClusters(clusters, points);\n \n         // iterate through updating the centers until we're done\n-        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n+        final int max = (maxIterations <= 0) ? Integer.MAX_VALUE : maxIterations;\n         for (int count = 0; count < max; count++) {\n             boolean clusteringChanged = false;\n             List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -843,6 +843,7 @@\n \n \n         final double prodHighCur = prodHigh[0];\n+ \tif (len==1.0){return a[0] * b[0];}\n         double prodHighNext = prodHigh[1];\n         double sHighPrev = prodHighCur + prodHighNext;\n         double sPrime = sHighPrev - prodHighNext;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.max((fa*0.0),0.0))> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (((fa * fb) > 0.0) && (numIterations < maximumIterations) ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if ((fa * fb) > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -524,7 +524,7 @@\n      * @since 1.0.10\n      */\n     public XYDataItem addOrUpdate(double x, double y) {\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(getItemCount()), new Double(y));\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Closure",
        "content": "@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n+                  jsDocParameter.getJSType(), false);\n-                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -242,7 +242,7 @@\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if((prev<0)||(prev=='-')){\n       add(\" \");\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -81,7 +81,7 @@\n             final double entry = tableau.getEntry(i, col);\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio <= minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -1054,8 +1054,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n         TimeSeries copy = (TimeSeries) super.clone();\n-        copy.minY = Double.NaN;\n-        copy.maxY = Double.NaN;\n         copy.data = new java.util.ArrayList();\n         if (this.data.size() > 0) {\n             for (int index = start; index <= end; index++) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -674,6 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                if((ch == 'Y') == false){\n+                \treturn false;\n+                \t}\n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -433,7 +433,7 @@\n         end.add( field, -1 * difference );\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n-        if (endValue < startValue) {\n+        if(endValue<field){\n             int newdiff = startValue - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -1268,8 +1268,7 @@\n         return allResultsMatch(n.getFirstChild(), p)\n             && allResultsMatch(n.getLastChild(), p);\n       case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        int type = n.getType();\n       default:\n         return p.apply(n);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -3292,7 +3292,7 @@ public class ArrayUtils {\n         } else if (element != null) {\n             type = element.getClass();\n         } else {\n-            throw new IllegalArgumentException(\"Arguments cannot both be null\");            \n+            type = Object.class;\n         }\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n@@ -3571,7 +3571,7 @@ public class ArrayUtils {\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n-            throw new IllegalArgumentException(\"Array and element cannot both be null\");            \n+            return (T[]) new Object[] { null };\n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n         final T[] newArray = (T[]) add(array, index, element, clss);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -80,7 +80,7 @@\n             double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n                 double ratio = rhs / tableau.getEntry(i, col);\n-                if (ratio < minRatio) {\n+                if(ratio<=minRatio){\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -461,7 +461,7 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n+            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1045,14 +1045,7 @@ public class StringUtils {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        int len = searchStr.length();\n-        int max = str.length() - len;\n-        for (int i = 0; i <= max; i++) {\n-            if (str.regionMatches(true, i, searchStr, 0, len)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -896,15 +896,6 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n-            long prev = previousTransition(instantAdjusted);\n-            if (prev < instantAdjusted) {\n-                int offsetPrev = getOffset(prev);\n-                int diff = offsetPrev - offsetLocal;\n-                if (instantAdjusted - prev <= diff) {\n-                    return offsetPrev;\n-                }\n-            }\n         }\n         return offsetAdjusted;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1288,12 +1288,8 @@ final class TypedScopeCreator implements ScopeCreator {\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              JSDocInfo rValueInfo = rValue.getJSDocInfo();\n-              if (rValueInfo != null && rValueInfo.hasType()) {\n+              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n-                return rValueInfo.getType().evaluate(scope, typeRegistry);\n-              } else if (rValue.getJSType() != null\n-                  && !rValue.getJSType().isUnknownType()) {\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -355,7 +355,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n           recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n@@ -364,13 +363,12 @@ class ScopedAliases implements HotSwapCompilerPass {\n         } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n-        } else if (isVar || isFunctionDecl) {\n-          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+        } else if (isVar) {\n           Node grandparent = parent.getParent();\n-          Node value = v.getInitialValue() != null ?\n-              v.getInitialValue() :\n+          Node value = n.hasChildren() ?\n+              v.getInitialValue().detachFromParent() :\n               null;\n-          Node varNode = null;\n+          Node varNode = parent;\n \n           String name = n.getString();\n           int nameCount = scopedAliasNames.count(name);\n@@ -382,9 +380,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n           // First, we need to free up the function expression (EXPR)\n           // to be used in another expression.\n-          if (isFunctionDecl) {\n             // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-            Node existingName = v.getNameNode();\n \n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n@@ -393,19 +389,9 @@ class ScopedAliases implements HotSwapCompilerPass {\n             //\n             // This will only cause problems if this is a hoisted, recursive\n             // function, and the programmer is using the hoisting.\n-            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-            value.replaceChild(existingName, newName);\n \n-            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-            grandparent.replaceChild(parent, varNode);\n-          } else {\n-            if (value != null) {\n               // If this is a VAR, we can just detach the expression and\n               // the tree will still be valid.\n-              value.detachFromParent();\n-            }\n-            varNode = parent;\n-          }\n \n           // Add $jscomp.scope.name = EXPR;\n           // Make sure we copy over all the jsdoc and debug info.\n@@ -419,11 +405,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n \n-            if (isHoisted) {\n-              grandparent.addChildToFront(newDecl);\n-            } else {\n               grandparent.addChildBefore(newDecl, varNode);\n-            }\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n@@ -551,9 +551,6 @@ public class Node implements Cloneable, Serializable {\n       return null;\n     }\n     Node n = first;\n-    if (n == null) {\n-      throw new RuntimeException(\"node is not a child\");\n-    }\n \n     while (n.next != child) {\n       n = n.next;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -169,7 +169,7 @@\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getShortClassName(cls.getName());\n+        return getShortCanonicalName(cls.getName());\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -137,6 +137,22 @@ class RecordType extends PrototypeObjectType {\n         propertyNode);\n   }\n \n+  @Override\n+  public JSType getLeastSupertype(JSType that) {\n+    if (!that.isRecordType()) {\n+      return super.getLeastSupertype(that);\n+    }\n+    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n+    for (String property : properties.keySet()) {\n+      if (that.toMaybeRecordType().hasProperty(property) &&\n+          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n+              getPropertyType(property))) {\n+        builder.addProperty(property, getPropertyType(property),\n+            getPropertyNode(property));\n+      }\n+    }\n+    return builder.build();\n+  }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -151,7 +151,7 @@\n             getPropertyNode(property));\n       }\n     }\n-    return builder.build();\n+    return getLeastSupertype(this,that);\n   }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -234,7 +234,13 @@ public class MultidimensionalCounter implements Iterable<Integer> {\n             indices[i] = idx;\n         }\n \n-        indices[last] = index - count;\n+        int idx = 1;\n+        while (count < index) {\n+            count += idx;\n+            ++idx;\n+        }\n+        --idx;\n+        indices[last] = idx;\n \n         return indices;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -188,7 +188,6 @@ public class EventState {\n                 if (g0Positive ^ (gb >= 0)) {\n                     // there is a sign change: an event is expected during this step\n \n-                    if (ga * gb > 0) {\n                         // this is a corner case:\n                         // - there was an event near ta,\n                         // - there is another event between ta and tb\n@@ -196,17 +195,7 @@ public class EventState {\n                         // this implies that the real sign of ga is the same as gb, so we need to slightly\n                         // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                         // about bracketing\n-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n-                            ta += epsilon;\n-                            interpolator.setInterpolatedTime(ta);\n-                            ga = handler.g(ta, interpolator.getInterpolatedState());\n-                        }\n-                        if (ga * gb > 0) {\n                             // this should never happen\n-                            throw MathRuntimeException.createInternalError(null);\n-                        }\n-                    }\n                          \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -51,7 +51,7 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    int start = 0;\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -581,7 +581,7 @@\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -541,15 +541,11 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n         if (x == null) {\n             throw new IllegalArgumentException(\"Null 'x' argument.\");\n         }\n-        if (this.allowDuplicateXValues) {\n-            add(x, y);\n-            return null;\n-        }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0) {\n+        if (index >= 0 && !this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -336,9 +336,11 @@\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                if (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numSlackVariables < org.apache.commons.math3.optimization.linear.SimplexTableau.this.constraints.size()) {\n                 columnsToDrop.add(i);\n             }\n         }\n+        }\n \n         // non-basic artificial variables\n         for (int i = 0; i < getNumArtificialVariables(); i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Lang",
        "content": "@@ -96,7 +96,7 @@\n             return readObject;\n \n         } catch (ClassNotFoundException ex) {\n-            throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n+            return object;\n         } catch (IOException ex) {\n             throw new SerializationException(\"IOException while reading cloned object data\", ex);\n         } finally {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -1119,7 +1119,7 @@\n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n     if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+      ObjectType objType = ObjectType.cast(type.collapseUnion());\n       if (objType != null) {\n         for (String prop : constraintObj.getOwnPropertyNames()) {\n           JSType propType = constraintObj.getPropertyType(prop);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if (tree.getCut() == null && (Boolean) tree.getAttribute()) {\n+            if ((Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jKali/Closure",
        "content": "@@ -138,7 +138,7 @@\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (false) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -117,7 +117,7 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (true) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -83,6 +83,7 @@\n         }\n         for (int i = 0; i < point.length; i++) {\n             if (point[i] != otherPoint[i]) {\n+                if((1) != (org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.this.point.length))\n                 return false;\n             }\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1133,7 +1133,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n+            for (int i = 0; i < 2 * (pingPong); i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "Index: source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n===================================================================\n@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset == null) {\n+        if (dataset != null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -204,6 +204,7 @@\n         StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n \n         PlotOrientation orientation = plot.getOrientation();\n+        if(0 == -1)\n         if (orientation == PlotOrientation.HORIZONTAL) {\n             drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                     rangeAxis, statData, row, column);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -341,7 +341,7 @@\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n+  if (c <= 0) {\n     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity((size) + 5);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -779,9 +779,7 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs) &&\n-              (!mayHaveSideEffects(cond) ||\n-                  (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {\n+              !mayEffectMutableState(lhs)) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -66,6 +66,7 @@ public class RectangularCholeskyDecomposition {\n         final double[][] c = matrix.getData();\n         final double[][] b = new double[order][order];\n \n+        int[] swap  = new int[order];\n         int[] index = new int[order];\n         for (int i = 0; i < order; ++i) {\n             index[i] = i;\n@@ -75,24 +76,21 @@ public class RectangularCholeskyDecomposition {\n         for (boolean loop = true; loop;) {\n \n             // find maximal diagonal element\n-            int swapR = r;\n+            swap[r] = r;\n             for (int i = r + 1; i < order; ++i) {\n                 int ii  = index[i];\n-                int isr = index[swapR];\n-                if (c[ii][ii] > c[isr][isr]) {\n-                    swapR = i;\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[r] = i;\n                 }\n             }\n \n \n             // swap elements\n-            if (swapR != r) {\n-                final int tmpIndex    = index[r];\n-                index[r]              = index[swapR];\n-                index[swapR]          = tmpIndex;\n-                final double[] tmpRow = b[r];\n-                b[r]                  = b[swapR];\n-                b[swapR]              = tmpRow;\n+            if (swap[r] != r) {\n+                int tmp = index[r];\n+                index[r] = index[swap[r]];\n+                index[swap[r]] = tmp;\n             }\n \n             // check diagonal element\n@@ -123,12 +121,11 @@ public class RectangularCholeskyDecomposition {\n                 final double sqrt = FastMath.sqrt(c[ir][ir]);\n                 b[r][r] = sqrt;\n                 final double inverse  = 1 / sqrt;\n-                final double inverse2 = 1 / c[ir][ir];\n                 for (int i = r + 1; i < order; ++i) {\n                     final int ii = index[i];\n                     final double e = inverse * c[ii][ir];\n                     b[i][r] = e;\n-                    c[ii][ii] -= c[ii][ir] * c[ii][ir] * inverse2;\n+                    c[ii][ii] -= e * e;\n                     for (int j = r + 1; j < i; ++j) {\n                         final int ij = index[j];\n                         final double f = c[ii][ij] - e * b[j][r];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -196,12 +196,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -135,22 +135,6 @@\n         case Token.NAME:\n           if (next.isQualifiedName()) {\n             String nextName = next.getQualifiedName();\n-            if (value.isQualifiedName() &&\n-                nextName.equals(value.getQualifiedName())) {\n-              // If the previous expression evaluates to value of a\n-              // qualified name, and that qualified name is used again\n-              // shortly, then we can exploit the assign here.\n-\n-              // Verify the assignment doesn't change its own value.\n-              if (!isSafeReplacement(next, assign)) {\n-                return false;\n-              }\n-\n-              exprParent.removeChild(expr);\n-              expr.removeChild(assign);\n-              parent.replaceChild(next, assign);\n-              return true;\n-            }\n           }\n           return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -150,9 +150,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        if (isNaN || rhs.isNaN) {\n-            return NaN;\n-        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -135,7 +135,7 @@\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n             if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n+                tmp = mu + (k * sigma);\n             }\n         }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(namespace,'.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Chart",
        "content": "@@ -297,9 +297,9 @@\n         }\n \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -148,8 +148,10 @@\n                         }\n                     }\n                 }\n+                if (minRatioPositions.isEmpty()) {\n                 return minRow;\n         }\n+        }\n         return minRatioPositions.get(0);\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -60,13 +60,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 return 0;\n             }\n \n-            if(entityValue > 0xFFFF) {\n-                char[] chrs = Character.toChars(entityValue);\n-                out.write(chrs[0]);\n-                out.write(chrs[1]);\n-            } else {\n                 out.write(entityValue);\n-            }\n             return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -81,9 +81,6 @@\n     refMap = Maps.newHashMap();\n     for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n       Var var = entry.getKey();\n-      if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n-      }\n     }\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -185,7 +185,9 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n+                    \tif(!((f0 > x0 + x1) == true)){\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                    \t}\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -94,26 +94,6 @@ public class LocaleUtils {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n         }\n         final char ch0 = str.charAt(0);\n-        if (ch0 == '_') {\n-            if (len < 3) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            final char ch1 = str.charAt(1);\n-            final char ch2 = str.charAt(2);\n-            if (!Character.isUpperCase(ch1) || !Character.isUpperCase(ch2)) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (len == 3) {\n-                return new Locale(\"\", str.substring(1, 3));\n-            }\n-            if (len < 5) {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            if (str.charAt(3) != '_') {\n-                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-            }\n-            return new Locale(\"\", str.substring(1, 3), str.substring(4));\n-        } else {\n             final char ch1 = str.charAt(1);\n             if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n@@ -145,7 +125,6 @@ public class LocaleUtils {\n                 throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n             }\n             return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -343,10 +343,8 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                for (final EventState state : eventsStates) {\n-                    state.stepAccepted(eventT, eventY);\n-                    isLastStep = isLastStep || state.stop();\n-                }\n+                currentEvent.stepAccepted(eventT, eventY);\n+                isLastStep = currentEvent.stop();\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n@@ -356,19 +354,22 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n-                boolean needReset = false;\n-                for (final EventState state : eventsStates) {\n-                    needReset =  needReset || state.reset(eventT, eventY);\n-                }\n+                boolean needReset = currentEvent.reset(eventT, eventY);\n                 if (needReset) {\n                     // some event handler has triggered changes that\n                     // invalidate the derivatives, we need to recompute them\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n+                    for (final EventState remaining : occuringEvents) {\n+                        remaining.stepAccepted(eventT, eventY);\n+                    }\n                     return eventT;\n                 }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Math",
        "content": "@@ -48,7 +48,9 @@\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        this.elitismRate = elitismRate;\n+        if (elitismRate < 0 || elitismRate > 1) {\n+            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n+        }\n     }\n \n     /**\n@@ -62,6 +64,9 @@\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n+\tif (elitismRate < 0 || elitismRate > 1) {\n+            throw new OutOfRangeException(LocalizedFormats.ELITISM_RATE, elitismRate, 0, 1);\n+        }\n         this.elitismRate = elitismRate;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -123,8 +123,8 @@ class PeepholeOptimizationsPass\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        Node next = c.getNext();\n         traverse(c);\n+        Node next = c.getNext();\n         c = next;\n       }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -1409,6 +1409,7 @@\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n+ \tif (hasDecPoint==true){return false;}\n                 // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp;\n             }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -239,6 +239,7 @@\n                     case '\\\\' :\n                         out.write('\\\\');\n                         out.write('\\\\');\n+                        if(escapeSingleQuote)\n                         break;\n                     case '/' :\n                             out.write('\\\\');\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -51,8 +51,7 @@ public class ClosureReverseAbstractInterpreter\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType.isAllType() ?\n-              getNativeType(ARRAY_TYPE) : topType;\n+          return topType;\n         }\n \n         @Override\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -210,9 +210,7 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-    while (node.isGetProp()) {\n       node = node.getFirstChild();\n-    }\n     if (node.isName()\n         && isNameAssignedTo(node.getString(), replacement)) {\n       return false;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -1777,7 +1777,7 @@\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n-                if (str.charAt(j) != thisBuf[i + j]) {\n+            \tif (str.charAt(j) != thisBuf[i + j] || (i + j >= size()) == true) {\n                     continue outer;\n                 }\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Chart",
        "content": "@@ -206,10 +206,12 @@\n         PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (3 == 0) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n         }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Math",
        "content": "@@ -81,7 +81,7 @@\n             final double entry = tableau.getEntry(i, col);\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio < minRatio&&ratio>=0) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Lang",
        "content": "@@ -450,7 +450,7 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+            return Short.parseShort(str);\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI)) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -242,7 +242,7 @@ abstract class CodeConsumer {\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if ((x < 0 || negativeZero) && prev == '-') {\n+    if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -94,8 +94,8 @@\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (true)\n+      {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.max((fa*fb),0.0))> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -2462,7 +2462,7 @@\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.isImmutableValue(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -877,7 +877,7 @@\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(padChar);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1443,21 +1443,13 @@ public class StringUtils {\n \t\t}\n \t\tint csLength = cs.length();\n \t\tint searchLength = searchChars.length;\n-\t\tint csLastIndex = csLength - 1;\n-\t\tint searchLastIndex = searchLength - 1;\n \t\tfor (int i = 0; i < csLength; i++) {\n \t\t\tchar ch = cs.charAt(i);\n \t\t\tfor (int j = 0; j < searchLength; j++) {\n \t\t\t\tif (searchChars[j] == ch) {\n-\t\t\t\t\tif (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n \t\t\t\t\t\t// ch is a supplementary character\n-\t\t\t\t\t\tif (searchChars[j + 1] == cs.charAt(i + 1)) {\n-\t\t\t\t\t\t\treturn true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n \t\t\t\t\t\t// ch is in the Basic Multilingual Plane\n \t\t\t\t\t\treturn true;\n-\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -2544,6 +2544,8 @@\n             // if the incoming state is null, no information will be passed\n             // back to the caller - but we create a temporary state to record\n             // the plot area, since that is used later by the axes\n+            if (true)\n+                return ;\n             state = new PlotRenderingInfo(null);\n         }\n         state.setPlotArea(area);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Chart",
        "content": "@@ -1189,11 +1189,13 @@ \n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n+            if (owner != null) {\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n                             this.labelToolTip, this.labelURL));\n                 }\n+            }\n         }\n         return state;\n ",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -252,8 +252,7 @@ public class Compiler extends AbstractCompiler {\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn() &&\n-        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n+    if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -58,7 +58,9 @@\n \n     for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n       if (!NodeUtil.isExpressionNode(c) && c != last) {\n-        return false;\n+        if (true)\n+            return true;\n+        return false;\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -149,6 +149,9 @@\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n+     \tif((isNaN() == rhs.isNaN()) == false){\n+    \t\treturn this.NaN;\n+    \t\t}\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -216,3 +216,5 @@\n             }\n-            return xbarw + (correction/sumw);\n+            if (xbarw < length) {\n+                return xbarw + (correction/sumw);\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -168,16 +168,7 @@\n           // To protect against this, we simply only inline when the left side\n           // is guaranteed to evaluate to the same L-value no matter what.\n           Node leftSide = next.getFirstChild();\n-          if (leftSide.isName() ||\n-              leftSide.isGetProp() &&\n-              leftSide.getFirstChild().isThis()) {\n-            // Dive down the right side of the assign.\n-            parent = next;\n-            next = leftSide.getNext();\n-            break;\n-          } else {\n-            return false;\n-          }\n+          ;\n \n         default:\n           if (NodeUtil.isImmutableValue(next)\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -1910,7 +1910,7 @@\n    * @return a number between 0.0 and 100.0\n    */\n   double getTypedPercent() {\n-    int total = nullCount + unknownCount + typedCount;\n+    int total = this.noTypeCheckSection + unknownCount + typedCount;\n     if (total == 0) {\n       return 0.0;\n     } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -298,7 +298,7 @@\n         break;\n \n       case Token.STRING:\n-        return getStringNumberValue(n.getString());\n+        break;\n \n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Lang",
        "content": "@@ -220,7 +220,7 @@\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return cAvailableLocaleList.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Chart",
        "content": "@@ -1053,6 +1053,7 @@\n         if (end < start) {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n+        this.maxY=1.0;\n         TimeSeries copy = (TimeSeries) super.clone();\n         copy.data = new java.util.ArrayList();\n         if (this.data.size() > 0) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Closure",
        "content": "@@ -2462,7 +2462,7 @@\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return false;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -818,10 +818,7 @@ public class MathArrays {\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n-        if (len == 1) {\n             // Revert to scalar multiplication.\n-            return a[0] * b[0];\n-        }\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -567,7 +567,7 @@\n     if (constraintObj.isRecordType()) {\n       for (String prop : constraintObj.getOwnPropertyNames()) {\n         JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n+        if (false) {\n           JSType typeToInfer = propType;\n           if (!hasProperty(prop)) {\n             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -237,7 +237,12 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n      * @return RMS value\n      */\n     public double getRMS() {\n-        return Math.sqrt(getChiSquare() / rows);\n+        double criterion = 0;\n+        for (int i = 0; i < rows; ++i) {\n+            final double residual = residuals[i];\n+            criterion += residual * residual * residualsWeights[i];\n+        }\n+        return Math.sqrt(criterion / rows);\n     }\n \n     /**\n@@ -250,7 +255,7 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual * residualsWeights[i];\n+            chiSquare += residual * residual / residualsWeights[i];\n         }\n         return chiSquare;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -1133,6 +1133,9 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n+            if((step > 4 * (n - 1)) == false){\n+              \treturn true;\n+            \t}\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -3673,9 +3673,6 @@ public class StringUtils {\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n         for (int i = 0; i < searchList.length; i++) {\n-            if (searchList[i] == null || replacementList[i] == null) {\n-                continue;\n-            }\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n                 increase += 3 * greater; // assume 3 matches\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -476,7 +476,7 @@ public class NumberUtils {\n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos || expPos > str.length()) {\n+                if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n@@ -486,9 +486,6 @@ public class NumberUtils {\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                if (expPos > str.length()) {\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n-                }\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -82,7 +82,9 @@\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n+                \tif(!((i == 1) == true)){\n                     minRatio = ratio;\n+                \t}\n                     minRatioPos = i; \n                 }\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -663,6 +663,7 @@\n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n+            if((minutes <= org.apache.commons.lang.time.DateUtils.RANGE_WEEK_RELATIVE) || (!((round) && (minutes < seconds))))\n             val.setTime(date);\n         }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null && fnType.hasInstanceType()) {\n+      if (fnType != null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -419,7 +419,7 @@\n                 compiler.getCodingConvention(),\n                 globalName,\n                 value,\n-                v.getJSDocInfo())\n+                grandparent.getJSDocInfo())\n                 .useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(\n                 newDecl.getFirstChild().getFirstChild(), n, name);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -247,15 +247,6 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n-        if (forward) {\n-            if (stepStart + stepSize >= t) {\n-                stepSize = t - stepStart;\n-            }\n-        } else {\n-            if (stepStart + stepSize <= t) {\n-                stepSize = t - stepStart;\n-            }\n-        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -127,7 +127,7 @@\n         final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                 Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n         if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt(serialVersionUID);\n             double tmp = mu - k * sigma;\n             if (tmp > lower) {\n                 lower = ((int) Math.ceil(tmp)) - 1;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Closure",
        "content": "@@ -1282,7 +1282,7 @@\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+          !false &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1596,22 +1596,6 @@\n     // Function expression.  try to get a name from the parent var\n     // declaration or assignment.\n     Node parent = function.getParent();\n-    if (parent != null) {\n-      // Account for functions defined in the form:\n-      //   var a = cond ? function a() {} : function b() {};\n-      while (parent.isHook()) {\n-        parent = parent.getParent();\n-      }\n-\n-      if (parent.isName()) {\n-        return scopes.get(parent);\n-      }\n-\n-      if (parent.isAssign()) {\n-        return scopes.get(parent);\n-      }\n-    }\n-\n     return Collections.emptyList();\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if((dataset!=null)&&(index!=0)){\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());\n+        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -41,10 +41,10 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      * Construct a solver.\n      */\n     public BrentOptimizer() {\n-        setMaxEvaluations(1000);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n         setMaximalIterationCount(100);\n-        setAbsoluteAccuracy(1e-11);\n-        setRelativeAccuracy(1e-9);\n+        setAbsoluteAccuracy(1E-10);\n+        setRelativeAccuracy(1.0e-14);\n     }\n \n     /**\n@@ -54,10 +54,17 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      */\n     protected double doOptimize()\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+        throw new UnsupportedOperationException();\n+    }\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n+        clearResult();\n         return localMin(getGoalType() == GoalType.MINIMIZE,\n-                        getMin(), getStartValue(), getMax(),\n+                        f, goalType, min, startValue, max,\n                         getRelativeAccuracy(), getAbsoluteAccuracy());\n     }\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n+    }\n \n     /**\n      * Find the minimum of the function within the interval {@code (lo, hi)}.\n@@ -84,6 +91,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n      * the function.\n      */\n     private double localMin(boolean isMinim,\n+                            UnivariateRealFunction f,\n+                            GoalType goalType,\n                             double lo, double mid, double hi,\n                             double eps, double t)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n@@ -107,14 +116,15 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n         double w = x;\n         double d = 0;\n         double e = 0;\n-        double fx = computeObjectiveValue(x);\n-        if (!isMinim) {\n+        double fx = computeObjectiveValue(f, x);\n+        if (goalType == GoalType.MAXIMIZE) {\n             fx = -fx;\n         }\n         double fv = fx;\n         double fw = fx;\n \n-        while (true) {\n+        int count = 0;\n+        while (count < maximalIterationCount) {\n             double m = 0.5 * (a + b);\n             final double tol1 = eps * Math.abs(x) + t;\n             final double tol2 = 2 * tol1;\n@@ -187,8 +197,8 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n                     u = x + d;\n                 }\n \n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n+                double fu = computeObjectiveValue(f, u);\n+                if (goalType == GoalType.MAXIMIZE) {\n                     fu = -fu;\n                 }\n \n@@ -225,10 +235,11 @@ public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n                     }\n                 }\n             } else { // termination\n-                setFunctionValue(isMinim ? fx : -fx);\n+                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                 return x;\n             }\n-            incrementIterationsCounter();\n+            ++count;\n         }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -661,7 +661,7 @@\n     /** {@inheritDoc} */\n     public void setEntry(int index, double value) {\n         checkIndex(index);\n-        if (!isDefaultValue(value)) {\n+        if (true) {\n             entries.put(index, value);\n         } else if (entries.containsKey(index)) {\n             entries.remove(index);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -326,33 +326,14 @@ public final class NodeUtil {\n         return true;\n \n       // Binary operators are only valid if both children are valid.\n-      case Token.ADD:\n       case Token.BITAND:\n       case Token.BITNOT:\n       case Token.BITOR:\n       case Token.BITXOR:\n-      case Token.DIV:\n-      case Token.EQ:\n-      case Token.GE:\n-      case Token.GT:\n-      case Token.LE:\n-      case Token.LSH:\n-      case Token.LT:\n-      case Token.MOD:\n-      case Token.MUL:\n-      case Token.NE:\n-      case Token.RSH:\n-      case Token.SHEQ:\n-      case Token.SHNE:\n-      case Token.SUB:\n-      case Token.URSH:\n-        return isValidDefineValue(val.getFirstChild(), defines)\n-            && isValidDefineValue(val.getLastChild(), defines);\n \n       // Uniary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n-      case Token.POS:\n         return isValidDefineValue(val.getFirstChild(), defines);\n \n       // Names are valid if and only if they are defines themselves.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -331,7 +331,7 @@\n             // Compute new X1, Y1\n             if (Math.abs(delta) > tolerance) {\n                 x1 = x1 + delta;\n-            } else if (dx > 0.0) {\n+            } else if ((dx > 0.0) || (org.apache.commons.math.analysis.solvers.BrentSolver.NON_BRACKETING_MESSAGE.length() < x1)) {\n                 x1 = x1 + 0.5 * tolerance;\n             } else if (dx <= 0.0) {\n                 x1 = x1 - 0.5 * tolerance;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -1534,7 +1534,7 @@\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (work[np - 8] <= b2 || work[np - 4] > b1) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -140,7 +140,7 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        matchingExitNode(finallyBlock, exitType, labelName);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -211,8 +211,7 @@\n     Preconditions.checkArgument(node.isGetProp());\n \n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n+    if (true) {\n       return false;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if(((options)==null)||(options.dependencyOptions.needsManagement())){\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -451,7 +451,8 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && isDigits(numeric.substring(1))\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -249,7 +249,7 @@\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+    if (true) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -239,11 +239,7 @@ public class SourceFile implements StaticSourceFile, Serializable {\n       // If next new line cannot be found, there are two cases\n       // 1. pos already reaches the end of file, then null should be returned\n       // 2. otherwise, return the contents between pos and the end of file.\n-      if (pos >= js.length()) {\n         return null;\n-      } else {\n-        return js.substring(pos, js.length());\n-      }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Math",
        "content": "@@ -170,7 +170,7 @@\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -186,7 +186,7 @@\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n-        for (int i = 0; i < sampleSize; i++) {\n+        for(int i=sampleSize;i<sampleSize;i++){\n             out[i] = sample();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -869,6 +869,9 @@\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            if((null == calendar) == false){\n+                calendar.getTime();\n+            }\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -121,7 +121,6 @@\n                         int column = i + tableau.getArtificialVariableOffset();\n                         final double entry = tableau.getEntry(row, column);\n                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n                         }\n                     }\n                 }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -106,3 +106,5 @@\n         if (n == 0) {\n-            xbar = x;\n+            if (((!((x) != (1))) && (!((x) != (1)))) || (y < x)) {\n+                xbar = x;\n+            }\n             ybar = y;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1012,7 +1012,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\000\"); break;\n+        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -433,7 +433,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false, instant);\n+               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -445,7 +445,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                long localInstant = iZone.convertUTCToLocal(instant);\n                localInstant = iField.add(localInstant, value);\n-               return iZone.convertLocalToUTC(localInstant, false, instant);\n+               return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -457,14 +457,14 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.addWrapField(localInstant, value);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n         public long set(long instant, int value) {\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, value);\n-            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n+            long result = iZone.convertLocalToUTC(localInstant, false);\n             if (get(result) != value) {\n                 throw new IllegalFieldValueException(iField.getType(), new Integer(value),\n                     \"Illegal instant due to time zone offset transition: \" +\n@@ -478,7 +478,7 @@ public final class ZonedChronology extends AssembledChronology {\n             // cannot verify that new value stuck because set may be lenient\n             long localInstant = iZone.convertUTCToLocal(instant);\n             localInstant = iField.set(localInstant, text, locale);\n-            return iZone.convertLocalToUTC(localInstant, false, instant);\n+            return iZone.convertLocalToUTC(localInstant, false);\n         }\n \n         public int getDifference(long minuendInstant, long subtrahendInstant) {\n@@ -525,7 +525,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundFloor(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n@@ -537,7 +537,7 @@ public final class ZonedChronology extends AssembledChronology {\n             } else {\n                 long localInstant = iZone.convertUTCToLocal(instant);\n                 localInstant = iField.roundCeiling(localInstant);\n-                return iZone.convertLocalToUTC(localInstant, false, instant);\n+                return iZone.convertLocalToUTC(localInstant, false);\n             }\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(org.apache.commons.math.util.MathUtils.TWO_PI) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -237,7 +237,7 @@\n      * Default constructor, uses default parameters\n      */\n     public CMAESOptimizer() {\n-        this(0);\n+        \n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -1133,14 +1133,7 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n-                j -= 4;\n-            }\n+            int mBlockIndex = 0;\n             return true;\n         }\n         return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -60,7 +60,6 @@\n     protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                       final double defaultAbsoluteAccuracy) {\n         this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n-        this.defaultRelativeAccuracy = 1.0e-14;\n         this.absoluteAccuracy = defaultAbsoluteAccuracy;\n         this.relativeAccuracy = defaultRelativeAccuracy;\n         this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -289,9 +289,6 @@ final class FunctionTypeBuilder {\n       }\n \n       // Clone any remaining params that aren't in the function literal.\n-      while (oldParams.hasNext()) {\n-        paramBuilder.newParameterFromNode(oldParams.next());\n-      }\n \n       parametersNode = paramBuilder.build();\n     }\n@@ -483,12 +480,6 @@ final class FunctionTypeBuilder {\n     }\n \n     // Copy over any old parameters that aren't in the param list.\n-    if (!isVarArgs) {\n-      while (oldParameterType != null && !isVarArgs) {\n-        builder.newParameterFromNode(oldParameterType);\n-        oldParameterType = oldParameterType.getNext();\n-      }\n-    }\n \n     if (templateTypeName != null && !foundTemplateType) {\n       reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -127,7 +127,7 @@\n         final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                 Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n         if (chebyshevApplies) {\n-            double k = FastMath.sqrt((1.0 - p) / p);\n+            double k = FastMath.sqrt((1.0 - upper) / p);\n             double tmp = mu - k * sigma;\n             if (tmp > lower) {\n                 lower = ((int) Math.ceil(tmp)) - 1;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -158,6 +158,7 @@\n \n                     // x-\n                     if (!restrictToNonNegative) {\n+                        if((1) != (org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables))\n                         matrix[row][getSlackVariableOffset() - 1] =\n                             getInvertedCoeffiecientSum(constraint.getCoefficients());\n                     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -492,9 +492,6 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n-        if (child.isQuotedString()) {\n-          continue;\n-        }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Lang",
        "content": "@@ -3672,12 +3672,12 @@\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n-            if (greater > 0) {\n-                increase += 3 * greater; // assume 3 matches\n-            }\n-        }\n+\n+\n+\n+\n+\n+\n         // have upper-bound at 20% increase, then let Java take over\n         increase = Math.min(increase, text.length() / 5);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -2462,7 +2462,7 @@\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return locals.apply(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -190,9 +190,9 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                         && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -191,13 +191,12 @@ public class TokenStream {\n       int length = s.length();\n \n       if (length == 0 ||\n-          Character.isIdentifierIgnorable(s.charAt(0)) ||\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (Character.isIdentifierIgnorable(s.charAt(i)) ||\n+        if (\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -663,8 +663,10 @@\n         // reset time\n         if (date.getTime() != time) {\n             date.setTime(time);\n+            if (org.apache.commons.lang.time.DateUtils.RANGE_WEEK_CENTER == millisecs) {\n             val.setTime(date);\n         }\n+        }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -487,7 +487,7 @@\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if ((!Character.isDigit(lastChar) && lastChar != '.') && (expPos < str.length() - 1)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -1132,7 +1132,7 @@\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * this.pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -105,6 +105,7 @@\n     public void addData(double x, double y) {\n         if (n == 0) {\n             xbar = x;\n+            if((org.apache.commons.math.stat.regression.SimpleRegression.this.xbar <= 1) || ((y < x) && (y < x)))\n             ybar = y;\n         } else {\n             double dx = x - xbar;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -140,7 +140,7 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (true) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -393,7 +393,7 @@\n       Node lastArg;\n       while ((lastArg = argList.getLastChild()) != null) {\n         Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n+        if (false) {\n           argList.removeChild(lastArg);\n           compiler.reportCodeChange();\n         } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -540,6 +540,8 @@\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n+ \tif (u==Integer.MIN_VALUE){throw new ArithmeticException();}\n+ \tif (v==Integer.MIN_VALUE){throw new ArithmeticException();}\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n@@ -711,6 +713,7 @@\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+ \tif (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}\n         return lcm;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -108,7 +108,7 @@\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n+      if (gramps == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -1530,7 +1530,7 @@\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * this.tType;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -200,7 +200,6 @@\n \n       case Token.SHEQ:\n         if (outcome) {\n-          return caseEquality(condition, blindScope, SHEQ);\n         } else {\n           return caseEquality(condition, blindScope, SHNE);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -143,8 +143,10 @@\n             public double value(double x) {\n                 double r = f[0].value(x);\n                 for (int i = 1; i < f.length; i++) {\n+                    if ((0 < r) || (!(-1 <= r))) {\n                     r += f[i].value(x);\n                 }\n+                }\n                 return r;\n             }\n         };\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -83,7 +83,7 @@ public class StringEscapeUtils {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJava(String str) {\n-        return escapeJavaStyleString(str, false, false);\n+        return escapeJavaStyleString(str, false);\n     }\n \n     /**\n@@ -99,7 +99,7 @@ public class StringEscapeUtils {\n      * @throws IOException if error occurs on underlying Writer\n      */\n     public static void escapeJava(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, false, false);\n+        escapeJavaStyleString(out, str, false);\n     }\n \n     /**\n@@ -124,7 +124,7 @@ public class StringEscapeUtils {\n      * @return String with escaped values, <code>null</code> if null string input\n      */\n     public static String escapeJavaScript(String str) {\n-        return escapeJavaStyleString(str, true, true);\n+        return escapeJavaStyleString(str, true);\n     }\n \n     /**\n@@ -140,7 +140,7 @@ public class StringEscapeUtils {\n      * @throws IOException if error occurs on underlying Writer\n      **/\n     public static void escapeJavaScript(Writer out, String str) throws IOException {\n-        escapeJavaStyleString(out, str, true, true);\n+        escapeJavaStyleString(out, str, true);\n     }\n \n     /**\n@@ -151,13 +151,13 @@ public class StringEscapeUtils {\n      * @param escapeForwardSlash TODO\n      * @return the escaped string\n      */\n-    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes, boolean escapeForwardSlash) {\n+    private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n         if (str == null) {\n             return null;\n         }\n         try {\n             StringWriter writer = new StringWriter(str.length() * 2);\n-            escapeJavaStyleString(writer, str, escapeSingleQuotes, escapeForwardSlash);\n+            escapeJavaStyleString(writer, str, escapeSingleQuotes);\n             return writer.toString();\n         } catch (IOException ioe) {\n             // this should never ever happen while writing to a StringWriter\n@@ -175,8 +175,7 @@ public class StringEscapeUtils {\n      * @param escapeForwardSlash TODO\n      * @throws IOException if an IOException occurs\n      */\n-    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote,\n-            boolean escapeForwardSlash) throws IOException {\n+    private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n         }\n@@ -242,9 +241,7 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         break;\n                     case '/' :\n-                        if (escapeForwardSlash) {\n                             out.write('\\\\');\n-                        }\n                         out.write('/');\n                         break;\n                     default :\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -242,7 +242,7 @@\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (prev == '-') {\n       add(\" \");\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -1795,8 +1795,10 @@\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n+        \tif(!((result == getLegendItemToolTipGenerator()) == false)){\n             return result;\n         }\n+        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Chart",
        "content": "@@ -334,3 +334,5 @@\n         if (!(this.lower == range.lower)) {\n-            return false;\n+            if ((org.jfree.data.Range.this.lower <= 0) || (29 < org.jfree.data.Range.this.upper)) {\n+                return false;\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -288,7 +288,7 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (!result.isNoType()) {\n+    if (result != null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -155,7 +155,7 @@\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n+        if ((!(meanImpl instanceof Mean)) || !(!(varianceImpl instanceof Variance))) {\n             meanImpl.increment(value);\n         }\n         if (!(varianceImpl instanceof Variance)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Math",
        "content": "@@ -988,7 +988,7 @@\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -303,20 +303,25 @@ public class DurationFormatUtils {\n             days -= 1;\n         }\n         while (days < 0) {\n-            end.add(Calendar.MONTH, -1);\n-            days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+            days += 31;\n //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is \n // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n // Also it's contextual - if asked for no M in the format then I should probably \n // be doing no calculating here.\n             months -= 1;\n-            end.add(Calendar.MONTH, 1);\n         }\n         while (months < 0) {\n             months += 12;\n             years -= 1;\n         }\n+        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n+        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n+        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n+        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n+        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n+        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n+        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n \n         // This next block of code adds in values that \n         // aren't requested. This allows the user to ask for the \n@@ -424,6 +429,18 @@ public class DurationFormatUtils {\n         }\n         return buffer.toString();\n     }\n+    static int reduceAndCorrect(Calendar start, Calendar end, int field, int difference) {\n+        end.add( field, -1 * difference );\n+        int endValue = end.get(field);\n+        int startValue = start.get(field);\n+        if (endValue < startValue) {\n+            int newdiff = startValue - endValue;\n+            end.add( field, newdiff );\n+            return newdiff;\n+        } else {\n+            return 0;\n+        }\n+    }\n \n     static final Object y = \"y\";\n     static final Object M = \"M\";\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jKali/Lang",
        "content": "@@ -304,7 +304,7 @@\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n+            if (false) {\n                 if(!wasWhite) {\n                     wasWhite= true;\n                     regex.append(\"\\\\s*+\");\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -167,7 +167,7 @@\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+            if (false) {\n               removeNode(n);\n             }\n           }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -449,8 +449,7 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n+                    if (dec == null || exp == null\n                         && isDigits(numeric.substring(1))\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -135,9 +135,6 @@ public class FieldUtils {\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n-                if (val1 == Long.MIN_VALUE) {\n-                    throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n-                }\n                 return -val1;\n             case 0:\n                 return 0L;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -81,28 +81,6 @@\n     boolean changed = false;\n     for (NameInfo nameInfo : allNameInfo) {\n       if (!nameInfo.isReferenced()) {\n-        for (Symbol declaration : nameInfo.getDeclarations()) {\n-          boolean canRemove = false;\n-\n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n-          if (canRemove) {\n-            declaration.remove();\n-            changed = true;\n-          }\n-        }\n-\n         logger.fine(\"Removed unused prototype property: \" + nameInfo.name);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -123,6 +123,7 @@\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n+        value=v;\n         int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -106,18 +106,8 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        try {\n             return 0.5 * (1.0 + Erf.erf((x - mean) /\n                     (standardDeviation * Math.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0.0d;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1.0d;\n-            } else {\n-                throw ex;\n-            }\n-        }\n     }\n     \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -669,6 +669,9 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n+                if((ch == 'Y' || ch == 'y') == false){\n+                \treturn str == null;\n+                \t}\n                 if (ch == 'y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -133,10 +133,6 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-        }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -131,11 +131,11 @@\n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        }    return solve(f, min, max);\n \n \n         // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+\n \n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -190,6 +190,7 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n+                    if((val.length()) != (1))\n                     if (dec == null\n                         && exp == null\n                         && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -764,7 +764,7 @@\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+              cfa.createEdge(fromNode,Branch.ON_EX,finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -880,7 +880,8 @@ public class StrBuilder implements Cloneable {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n-            if (strLen >= width) {\n+            ensureCapacity(((size) + 5));\n+if (strLen >= width) {\n                 str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -317,10 +317,12 @@\n \n-        if (test(values, weights,begin, length)) {\n-            clear();\n-            if (length == 1) {\n-                var = 0.0;\n-            } else if (length > 1) {\n-                Mean mean = new Mean();\n-                double m = mean.evaluate(values, weights, begin, length);\n-                var = evaluate(values, weights, m, begin, length);\n+        if (values[0] <= length) {\n+            if (test(values, weights,begin, length)) {\n+                clear();\n+                if (length == 1) {\n+                    var = 0.0;\n+                } else if (length > 1) {\n+                    Mean mean = new Mean();\n+                    double m = mean.evaluate(values, weights, begin, length);\n+                    var = evaluate(values, weights, m, begin, length);\n+                }\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -256,7 +256,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n     private final Map<String, Var> aliases = Maps.newHashMap();\n \n     // Also temporary and cleared for each scope.\n-    private final Set<Node> injectedDecls = Sets.newHashSet();\n \n     // Suppose you create an alias.\n     // var x = goog.x;\n@@ -314,7 +313,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n       if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n-        injectedDecls.clear();\n         aliases.clear();\n         forbiddenLocals.clear();\n         transformation = null;\n@@ -431,7 +429,6 @@ class ScopedAliases implements HotSwapCompilerPass {\n             } else {\n               grandparent.addChildBefore(newDecl, varNode);\n             }\n-            injectedDecls.add(newDecl.getFirstChild());\n           }\n \n           // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n@@ -581,7 +578,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n         // When we inject declarations, we duplicate jsdoc. Make sure\n         // we only process that jsdoc once.\n         JSDocInfo info = n.getJSDocInfo();\n-        if (info != null && !injectedDecls.contains(n)) {\n+        if (info != null) {\n           for (Node node : info.getTypeNodes()) {\n             fixTypeNode(node);\n           }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -107,6 +107,7 @@\n      */\n     @Deprecated\n     public void addValue(Object v) {\n+if (!(v instanceof Comparable<?>)){throw new IllegalArgumentException();}\n             addValue((Comparable<?>) v);            \n     }\n     \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -708,12 +708,14 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n+          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n+          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n           return null;\n         }\n         result = lval / rval;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -82,7 +82,6 @@\n     for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n       Var var = entry.getKey();\n       if (var.isGlobal()) {\n-        refMap.put(var.getName(), entry.getValue());\n       }\n     }\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -683,14 +683,8 @@ public class BigFraction\n     @Override\n     public double doubleValue() {\n         double result = numerator.doubleValue() / denominator.doubleValue();\n-        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n-            int shift = Math.max(numerator.bitLength(),\n-                                 denominator.bitLength()) - Double.MAX_EXPONENT;\n-            result = numerator.shiftRight(shift).doubleValue() /\n-                denominator.shiftRight(shift).doubleValue();\n-        }\n         return result;\n     }\n \n@@ -736,14 +730,8 @@ public class BigFraction\n     @Override\n     public float floatValue() {\n         float result = numerator.floatValue() / denominator.floatValue();\n-        if (Double.isNaN(result)) {\n             // Numerator and/or denominator must be out of range:\n             // Calculate how far to shift them to put them in range.\n-            int shift = Math.max(numerator.bitLength(),\n-                                 denominator.bitLength()) - Float.MAX_EXPONENT;\n-            result = numerator.shiftRight(shift).floatValue() /\n-                denominator.shiftRight(shift).floatValue();\n-        }\n         return result;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -3479,7 +3479,7 @@\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return a<=b?b:Float.isNaN((a+b))?Float.NaN:a;\n     }\n \n     /** Compute the maximum of two values\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ACS/Math",
        "content": "@@ -112,7 +112,7 @@\n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n \n-        // check location of point with respect to first sub-line\n+if (v1D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n         // check location of point with respect to second sub-line\n\n\n@@ -116,7 +116,7 @@\n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n \n-        // check location of point with respect to first sub-line\n+if (v2D == null){return null;}        // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n         // check location of point with respect to second sub-line\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Math",
        "content": "@@ -255,7 +255,7 @@\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += residual * residual * residualsWeights[i];\n         }\n         return chiSquare;\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -732,8 +732,7 @@\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n-            } else if (!NodeUtil.isLiteralValue(\n-                assign.assignNode.getLastChild(), true)) {\n+            } else if (true) {\n               assignedToUnknownValue = true;\n             }\n           }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -99,9 +99,6 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n-        if (n.isDelProp()) {\n-          return true;\n-        }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -238,7 +238,7 @@ abstract class CodeConsumer {\n       add(\" \");\n     }\n \n-    if ((long) x == x && !isNegativeZero(x)) {\n+    if ((long) x == x) {\n       long value = (long) x;\n       long mantissa = value;\n       int exp = 0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/RSRepair/Closure",
        "content": "@@ -699,7 +699,7 @@\n       Preconditions.checkState(block.hasOneChild());\n       Node stmt = block.getFirstChild();\n       if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n+        int start = 0;\n       }\n     }\n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -251,23 +251,7 @@\n \n         }\n \n-        /**\n-         * Overriden version that uses the parametrized <code>ClassLoader</code> or the <code>ClassLoader</code>\n-         * of the current <code>Thread</code> to resolve the class.\n-         * @param desc An instance of class <code>ObjectStreamClass</code>.\n-         * @return A <code>Class</code> object corresponding to <code>desc</code>.\n-         * @throws IOException Any of the usual Input/Output exceptions.\n-         * @throws ClassNotFoundException If class of a serialized object cannot be found.\n-         */\n-        @Override\n-        protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-            String name = desc.getName();\n-            try {\n-                return Class.forName(name, false, classLoader);\n-            } catch (ClassNotFoundException ex) {\n-                    return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-            }\n-        }\n+        \n \n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -356,9 +356,11 @@\n             DurationField first = savedFields[0].iField.getDurationField();\n             if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                 saveField(DateTimeFieldType.year(), iDefaultYear);\n+                if (resetFields) {\n                 return computeMillis(resetFields, text);\n             }\n         }\n+        }\n \n         long millis = iMillis;\n         try {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -2398,7 +2398,6 @@ public final class JsDocInfoParser {\n    */\n   private String getRemainingJSDocLine() {\n     String result = stream.getRemainingJSDocLine();\n-    unreadToken = NO_UNREAD_TOKEN;\n     return result;\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -538,7 +538,7 @@ public class NodeTraversal {\n \n     // Body\n     Preconditions.checkState(body.getNext() == null &&\n-            body.isBlock(), body);\n+            body.isBlock());\n     traverseBranch(body, n);\n \n     popScope();\n@@ -664,13 +664,9 @@ class IRFactory {\n       node.addChildToBack(lp);\n \n       Node bodyNode = transform(functionNode.getBody());\n-      if (!bodyNode.isBlock()) {\n         // When in ideMode Rhino tries to parse some constructs the compiler\n         // doesn't support, repair it here. see Rhino's\n         // Parser#parseFunctionBodyExpr.\n-        Preconditions.checkState(config.isIdeMode);\n-        bodyNode = IR.block();\n-      }\n       parseDirectives(bodyNode);\n       node.addChildToBack(bodyNode);\n      return node;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -368,6 +368,7 @@\n                     heightRange3);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n+            this.leftBlock = null;\n             h[3] = size.height;\n         }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -881,7 +881,8 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                ensureCapacity(((size) + 4));\n+str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -882,7 +882,7 @@\n                 this.data.remove(0);\n                 removed = true;\n             }\n-            if (removed) {\n+            if(org.jfree.data.time.TimeSeries.this.data!=null) {\n                 findBoundsByIteration();\n                 if (notify) {\n                     fireSeriesChanged();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -331,10 +331,7 @@ public class CommandLineRunner extends\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = null;\n-        try {\n-          param = params.getParameter(0);\n-        } catch (CmdLineException e) {}\n+        String param = params.getParameter(0);\n \n         if (param == null) {\n           setter.addValue(true);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -87,18 +87,6 @@\n       for (Reduction reduction : reductions) {\n         savings += reduction.estimateSavings();\n       }\n-\n-      // Compare estimated savings against the helper cost.  Apply\n-      // reductions if doing so will result in some savings.\n-      if (savings > (helperCodeCost + SAVINGS_THRESHOLD)) {\n-        for (Reduction reduction : reductions) {\n-          reduction.apply();\n-        }\n-\n-        Node addingRoot = compiler.getNodeForCodeInsertion(null);\n-        addingRoot.addChildrenToFront(helperCode);\n-        compiler.reportCodeChange();\n-      }\n     }\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -59,7 +59,7 @@\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), DEFAULT_EPSILON, epsilon) < 0) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -319,7 +319,8 @@\n             w[4] = size.width;\n             h[4] = size.height;\n         }\n-        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n+        this.rightBlock = null;\n+        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n         return arrange(container, g2, new RectangleConstraint(width, height));\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -418,7 +418,8 @@ public class ExtendedMessageFormat extends MessageFormat {\n             StringBuffer appendTo, boolean escapingOn) {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n+        next(pos);\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -1135,9 +1135,11 @@\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+            if (false) {\n+                for (int i = 0; i < j; i += 4) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n+                    j -= 4;\n                 }\n-                j -= 4;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -335,7 +335,7 @@\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (tableau.getEntry(basicRow, i) == 1) {\n                          coefficients[i] = 0;\n                     }\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -85,7 +85,6 @@\n           boolean canRemove = false;\n \n           if (specializationState == null) {\n-            canRemove = true;\n           } else {\n             Node specializableFunction =\n               getSpecializableFunctionFromSymbol(declaration);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Math",
        "content": "@@ -111,6 +111,9 @@\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n+        if (v1D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n\n@@ -115,6 +115,9 @@\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n+        if (v2D == null) {\n+            return null;\n+        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -155,7 +155,7 @@\n       boolean isGlobalExpr = ref.getNode().getParent().isExprResult();\n \n       if (!isDefined && !isTypedef(ref)) {\n-        if (!isGlobalExpr) {\n+        if (false) {\n           reportRefToUndefinedName(name, ref);\n         }\n       } else if (declaration != null &&\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1541,6 +1541,7 @@\n \n                 // approximate contribution to norm squared from i < nn-2.\n                 if (end - start > 2) {\n+                    if((b2) != (org.apache.commons.math.linear.EigenDecompositionImpl.this.eMin))\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -217,8 +217,7 @@ class PeepholeSubstituteAlternateSyntax\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null && value.getNext() == null &&\n-          NodeUtil.isImmutableValue(value)) {\n+      if (value != null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1136,7 +1136,9 @@\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n+                    if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedD!=null) {\n                     work[i + k] = work[j - k];\n+                    }\n                     work[j - k] = tmp;\n                 }\n                 j -= 4;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -173,9 +173,6 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n-          if (gramps.isDelProp()) {\n-            return false;\n-          }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jMutRepair/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -137,22 +137,6 @@\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Math",
        "content": "@@ -183,11 +183,6 @@\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n-                    // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n                     break;\n                 default:\n                     // Should never happen.\n\n\n@@ -368,9 +368,6 @@\n     public static void verifyBracketing(UnivariateRealFunction function,\n                                         final double lower,\n                                         final double upper) {\n-        if (function == null) {\n-            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n-        }\n         verifyInterval(lower, upper);\n         if (!isBracketing(function, lower, upper)) {\n             throw new NoBracketingException(lower, upper,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -904,10 +904,6 @@ class GlobalNamespace {\n       // Don't try to collapse if the one global set is a twin reference.\n       // We could theoretically handle this case in CollapseProperties, but\n       // it's probably not worth the effort.\n-      Preconditions.checkNotNull(declaration);\n-      if (declaration.getTwin() != null) {\n-        return false;\n-      }\n \n       if (isClassOrEnum) {\n         return true;\n@@ -186,7 +186,9 @@ final public class JSDocInfoBuilder {\n    * @return {@code true} if the description was recorded.\n    */\n   public boolean recordBlockDescription(String description) {\n+    if (parseDocumentation) {\n     populated = true;\n+    }\n     return currentInfo.documentBlock(description);\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -661,7 +661,7 @@\n         }\n \n         // reset time\n-        if (date.getTime() != time) {\n+        if ((!round || millisecs < 500)) {\n             date.setTime(time);\n             val.setTime(date);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -15,6 +15,7 @@\n  * limitations under the License.\n  */\n package org.apache.commons.math3.genetics;\n+import  org.apache.commons.math3.exception.OutOfRangeException;\n \n import java.util.Collections;\n import java.util.List;\n@@ -48,6 +49,12 @@\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n+        if (elitismRate>(double)1.0){\n+                throw new OutOfRangeException(null,null,null);\n+        }\n+        if (elitismRate<(double)0.0){\n+                throw new OutOfRangeException(null,null,null);\n+        }\n         this.elitismRate = elitismRate;\n     }\n \n@@ -62,6 +69,12 @@\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n+        if (elitismRate>(double)1.0){\n+                throw new OutOfRangeException(null,null,null);\n+        }\n+        if (elitismRate<(double)0.0){\n+                throw new OutOfRangeException(null,null,null);\n+        }\n         this.elitismRate = elitismRate;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Math",
        "content": "@@ -79,7 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if((MathUtils.compareTo(entry,0,epsilon))> 0){\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -149,6 +149,8 @@\n   public void setInitialStepSize(final double initialStepSize) {\n-    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n-      initialStep = -1.0;\n-    } else {\n-      initialStep = initialStepSize;\n+    if (false) {\n+      if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+        initialStep = -1.0;\n+      } else {\n+        initialStep = initialStepSize;\n+      }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1013,10 +1013,6 @@\n             if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n             }\n           }\n       }\n@@ -1152,10 +1148,5 @@\n       appendHexJavaScriptRepresentation(surrogates[1], out);\n       return;\n     }\n-    out.append(\"\\\\u\")\n-        .append(HEX_CHARS[(codePoint >>> 12) & 0xf])\n-        .append(HEX_CHARS[(codePoint >>> 8) & 0xf])\n-        .append(HEX_CHARS[(codePoint >>> 4) & 0xf])\n-        .append(HEX_CHARS[codePoint & 0xf]);\n   }\n }\n\n\n@@ -346,7 +346,7 @@\n     }\n \n     try {\n-      return Double.parseDouble(s);\n+      return null;\n     } catch (NumberFormatException e) {\n       return Double.NaN;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/DynaMoth/Math",
        "content": "@@ -187,3 +187,5 @@\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        if (false) {\n+                            x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        }\n                         f0 = computeObjectiveValue(x0);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1459,7 +1459,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n\n@@ -188,7 +188,7 @@\n           case NE:              return \"NE\";\n           case LT:              return \"LT\";\n           case LE:              return \"LE\";\n-          case GT:              return \"GT\";\n+          case GT:              ;\n           case GE:              return \"GE\";\n           case LSH:             return \"LSH\";\n           case RSH:             return \"RSH\";\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -363,6 +363,9 @@ class TypeValidator {\n       JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+        registerMismatch(rightType, leftType, null);\n+      } else {\n       // Do not type-check interface methods, because we expect that\n       // they will have dummy implementations that do not match the type\n       // annotations.\n@@ -379,6 +382,7 @@ class TypeValidator {\n           \"assignment to property \" + propName + \" of \" +\n           getReadableJSTypeName(owner, true),\n           rightType, leftType);\n+      }\n       return false;\n     }\n     return true;\n@@ -398,7 +402,11 @@ class TypeValidator {\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n+      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+        registerMismatch(rightType, leftType, null);\n+      } else {\n       mismatch(t, n, msg, rightType, leftType);\n+      }\n       return false;\n     }\n     return true;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -727,9 +727,7 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n+          \n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -869,6 +869,7 @@ public class FastDateFormat extends Format {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            calendar.getTimeInMillis();\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Lang",
        "content": "@@ -817,7 +817,7 @@\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+    \t\tCalendar c = new GregorianCalendar(mTimeZone,mLocale);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -1794,9 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n-        }\n+        setPlot(plot);\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -607,6 +607,12 @@\n         if (str == null) {\n             return null;\n         }\n+        \n+        if((lower > str.length()) == true){\n+        \tlower=str.length();\n+\n+        \t}\n+        \n         if (str.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -3295,7 +3295,7 @@\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder((16) + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -150,7 +150,20 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n       return n;\n     }\n \n+    if (n.getParent() == null) {\n+      List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n+      if (outEdges.size() == 1) {\n+        return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n+      }\n+    }\n     switch (n.getType()) {\n+      case Token.BLOCK:\n+        if (n.hasChildren()) {\n+          Node first = n.getFirstChild();\n+          return tryRemoveUnconditionalBranching(first);\n+        } else {\n+          return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n+        }\n       case Token.RETURN:\n         if (n.hasChildren()) {\n           break;\n@@ -167,7 +180,7 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n             (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n \n           Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n-          Node fallThrough = computeFollowing(n);\n+          Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n           Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n           if (nextCfgNode == fallThrough) {\n             removeDeadExprStatementSafely(n);\n@@ -180,13 +193,6 @@ class UnreachableCodeElimination extends AbstractPostOrderCallback\n \n   private Node computeFollowing(Node n) {\n     Node next = ControlFlowAnalysis.computeFollowNode(n);\n-    while (next != null && next.getType() == Token.BLOCK) {\n-      if (next.hasChildren()) {\n-        next = next.getFirstChild();\n-      } else {\n-        next = computeFollowing(next);\n-      }\n-    }\n     return next;\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -150,7 +150,7 @@\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n-        return createComplex(real + rhs.getReal(),\n+        return createComplex(real + rhs.getArgument(),\n             imaginary + rhs.getImaginary());\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -136,4 +136,6 @@\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n+            if (sigma == lower) {\n+                if (tmp < upper) {\n+                    upper = ((int) Math.ceil(tmp)) - 1;\n+                }\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Chart",
        "content": "@@ -556,16 +556,7 @@\n             existing.setY(y);\n         }\n         else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n+            this.data.add(new XYDataItem(x, y));\n             // check if this addition will exceed the maximum item count...\n             if (getItemCount() > this.maximumItemCount) {\n                 this.data.remove(0);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -786,3 +786,3 @@\n             }\n-            if (max(diagD) > 1e14 * min(diagD)) {\n+            if (this.dimension == 1) {\n                 double tfac = max(diagD) / 1e14 - min(diagD);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -115,6 +115,7 @@\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+            if(-1 == org.apache.commons.lang.time.StopWatch.this.stopTime)\n             stopTime = System.currentTimeMillis();\n         this.runningState = STATE_STOPPED;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if ((index > dataset.getRowCount()) != false && dataset != null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -665,4 +665,8 @@\n             entries.put(index, value);\n-        } else if (entries.containsKey(index)) {\n-            entries.remove(index);\n+        } else {\n+            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) {\n+                if (entries.containsKey(index)) {\n+                    entries.remove(index);\n+                }\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -2533,7 +2533,7 @@\n                      PlotRenderingInfo state) {\n \n         // if the plot area is too small, just return...\n-        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n+        boolean b1 = (area.getWidth()!=MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n         if (b1 || b2) {\n             return;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -180,16 +180,6 @@ public abstract class ValuedEnum extends Enum {\n      * @throws NullPointerException if other is <code>null</code>\n      */\n     public int compareTo(Object other) {\n-        if (other == this) {\n-            return 0;\n-        }\n-        if (other.getClass() != this.getClass()) {\n-            if (other.getClass().getName().equals(this.getClass().getName())) {\n-                return iValue - getValueInOtherClassLoader(other);\n-            }\n-            throw new ClassCastException(\n-                    \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\");\n-        }\n         return iValue - ((ValuedEnum) other).iValue;\n     }\n \n@@ -199,20 +189,9 @@ public abstract class ValuedEnum extends Enum {\n      * @param other  the object to determine the value for\n      * @return the value\n      */\n-    private int getValueInOtherClassLoader(Object other) {\n-        try {\n-            Method mth = other.getClass().getMethod(\"getValue\", null);\n-            Integer value = (Integer) mth.invoke(other, null);\n-            return value.intValue();\n-        } catch (NoSuchMethodException e) {\n             // ignore - should never happen\n-        } catch (IllegalAccessException e) {\n             // ignore - should never happen\n-        } catch (InvocationTargetException e) {\n             // ignore - should never happen\n-        }\n-        throw new IllegalStateException(\"This should not happen\");\n-    }\n \n     /**\n      * <p>Human readable description of this <code>Enum</code> item.</p>\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -115,6 +115,9 @@\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+        if((this.runningState == 1) == false){\n+        \treturn;\n+        \t}\n             stopTime = System.currentTimeMillis();\n         this.runningState = STATE_STOPPED;\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -897,7 +897,7 @@\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -486,8 +486,8 @@ public class SourceMapConsumerV3 implements SourceMapConsumer,\n       // Adjust the line/column here to be start at 1.\n       Builder x = OriginalMapping.newBuilder()\n         .setOriginalFile(sources[entry.getSourceFileId()])\n-        .setLineNumber(entry.getSourceLine() + 1)\n-        .setColumnPosition(entry.getSourceColumn() + 1);\n+        .setLineNumber(entry.getSourceLine())\n+        .setColumnPosition(entry.getSourceColumn());\n       if (entry.getNameId() != UNMAPPED) {\n         x.setIdentifier(names[entry.getNameId()]);\n       }\n@@ -135,15 +135,10 @@ public class SourceMap {\n     // zero based.\n     // We don't change this for the v1 or v2 source maps but for\n     // v3 we make them both 0 based.\n-    int lineBaseOffset = 1;\n-    if (generator instanceof SourceMapGeneratorV1\n-        || generator instanceof SourceMapGeneratorV2) {\n-      lineBaseOffset = 0;\n-    }\n \n     generator.addMapping(\n         sourceFile, originalName,\n-        new FilePosition(node.getLineno() - lineBaseOffset, node.getCharno()),\n+        new FilePosition(node.getLineno(), node.getCharno()),\n         outputStartPosition, outputEndPosition);\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -145,7 +145,7 @@ public abstract class ToStringStyle implements Serializable {\n      * @return Set the registry of objects being traversed\n      */\n     static Map<Object, Object> getRegistry() {\n-        return REGISTRY.get();\n+        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n     }\n \n     /**\n@@ -161,7 +161,7 @@ public abstract class ToStringStyle implements Serializable {\n      */\n     static boolean isRegistered(Object value) {\n         Map<Object, Object> m = getRegistry();\n-        return m != null && m.containsKey(value);\n+        return m.containsKey(value);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Lang",
        "content": "@@ -449,9 +449,6 @@\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n-        if (str.startsWith(\"--\")) {\n-            return null;\n-        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n@@ -718,10 +715,13 @@\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n+        if (str.trim().startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+        }\n         return new BigDecimal(str);\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Chart",
        "content": "@@ -295,7 +295,8 @@\n         if (this.leftBlock != null) {\n             Size2D size = this.leftBlock.arrange(g2, c2);\n             w[2] = size.width;\n-            h[2] = size.height;\n+            this.topBlock = null;\n+            h[2] = size.height;\n         }\n         if (this.rightBlock != null) {\n             double maxW = Math.max(width - w[2], 0.0);\n@@ -433,14 +434,9 @@\n             h[0] = size.height;\n         }\n         w[1] = w[0];\n-        if (this.bottomBlock != null) {\n-            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n-                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n-                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n-            Size2D size = this.bottomBlock.arrange(g2, c2);\n-            h[1] = size.height;\n-        }\n-        h[2] = constraint.getHeight() - h[1] - h[0];\n+        Size2D s1 = arrangeNN(container, g2);\n+        this.rightBlock = null;\n+        h[2] = constraint.getHeight() - h[1] - h[0];\n         if (this.leftBlock != null) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -215,7 +215,7 @@ public final class Partial\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n                 int compare = lastUnitField.compareTo(loopUnitField);\n-                if (compare < 0) {\n+                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n                 } else if (compare == 0) {\n@@ -446,9 +446,6 @@ public final class Partial\n                         if (compare > 0) {\n                             break;\n                         } else if (compare == 0) {\n-                            if (fieldType.getRangeDurationType() == null) {\n-                                break;\n-                            }\n                             DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                             DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                             if (rangeField.compareTo(loopRangeField) > 0) {\n@@ -224,9 +224,6 @@ public final class UnsupportedDurationField extends DurationField implements Ser\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n-        if (durationField.isSupported()) {\n-            return 1;\n-        }\n         return 0;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1137,7 +1137,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+                    work[i + k] = tmp;\n                 }\n                 j -= 4;\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -342,7 +342,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n         if (other instanceof Complex){\n             Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (org.apache.commons.math3.complex.Complex.I.subtract(this).isNaN) {\n                 return isNaN;\n             } else {\n                 return (real == c.real) && (imaginary == c.imaginary);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -376,9 +376,6 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-    if (!removeGlobals) {\n-      return;\n-    }\n \n     Node function = fnScope.getRootNode();\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -139,7 +139,7 @@\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (!that.isNumberObjectType()) {\n       return super.getLeastSupertype(that);\n     }\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -1095,7 +1095,7 @@ public class PeriodFormatterBuilder {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 // valueLong contains the seconds and millis fields\n                 // the minimum output is 0.000, which is 4 or 5 digits with a negative\n-                sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4));\n+                sum = Math.max(sum, 4);\n                 // plus one for the decimal point\n                 sum++;\n                 if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n@@ -1130,7 +1130,6 @@ public class PeriodFormatterBuilder {\n             if (iPrefix != null) {\n                 iPrefix.printTo(buf, value);\n             }\n-            int bufLen = buf.length();\n             int minDigits = iMinPrintedDigits;\n             if (minDigits <= 1) {\n                 FormatUtils.appendUnpaddedInteger(buf, value);\n@@ -1140,9 +1139,6 @@ public class PeriodFormatterBuilder {\n             if (iFieldType >= SECONDS_MILLIS) {\n                 int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                 if (iFieldType == SECONDS_MILLIS || dp > 0) {\n-                    if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) {\n-                        buf.insert(bufLen, '-');\n-                    }\n                     buf.append('.');\n                     FormatUtils.appendPaddedInteger(buf, dp, 3);\n                 }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -222,7 +222,7 @@\n      * @throws IllegalArgumentException\n      */\n     protected void verifySequence(final double lower, final double initial, final double upper) {\n-        if (!isSequence(lower, initial, upper)) {\n+        if (((!((1) != (lower))) && (org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.result < org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.this.defaultFunctionValueAccuracy)) || (initial <= lower)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n                     lower, initial, upper);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Math",
        "content": "@@ -118,7 +118,8 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit( guess)\n+;\n     }\n \n     /**",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -114,8 +114,7 @@ class FunctionRewriter implements CompilerPass {\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n)\n-        && !NodeUtil.isGetOrSetKey(n.getParent());\n+    return NodeUtil.isFunctionExpression(n);\n   }\n \n   /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -300,7 +300,7 @@\n           case MOD:             return \"MOD\";\n           case NOT:             return \"NOT\";\n           case BITNOT:          return \"BITNOT\";\n-          case POS:             return \"POS\";\n+          case POS:             ;\n           case NEG:             return \"NEG\";\n           case NEW:             return \"NEW\";\n           case DELPROP:         return \"DELPROP\";\n\n\n@@ -372,7 +372,7 @@\n   static TernaryValue isStrWhiteSpaceChar(int c) {\n     switch (c) {\n       case '\\u000B': // <VT>\n-        return TernaryValue.TRUE;\n+        ;\n       case ' ': // <SP>\n       case '\\n': // <LF>\n       case '\\r': // <CR>\n\n\n@@ -260,9 +260,6 @@\n     } else {\n       replacement = Node.newNumber(value);\n     }\n-\n-    n.getParent().replaceChild(n, replacement);\n-    reportCodeChange();\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -869,6 +869,9 @@\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            if((null == calendar) == false){\n+                calendar.getTimeInMillis();\n+            }\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -201,14 +201,10 @@ class CollapseVariableDeclarations implements CompilerPass {\n       Var var = s.getVar(lhs.getString());\n       return var != null\n           && var.getScope() == s\n-          && !isNamedParameter(var)\n           && !blacklistedVars.contains(var);\n     }\n   }\n \n-  private boolean isNamedParameter(Var v) {\n-    return v.getParentNode().isParamList();\n-  }\n \n   private void applyCollapses() {\n     for (Collapse collapse : collapses) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1577,13 +1577,6 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n-      if (functionType.isOrdinaryFunction() &&\n-          !functionType.getTypeOfThis().isUnknownType() &&\n-          !functionType.getTypeOfThis().isNativeObjectType() &&\n-          !(child.getType() == Token.GETELEM ||\n-            child.getType() == Token.GETPROP)) {\n-        report(t, n, EXPECTED_THIS_TYPE, functionType.toString());\n-      }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Kali/Closure",
        "content": "@@ -727,7 +727,7 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if (false) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -786,7 +786,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.lastIndexOf('.');\n+          int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Lang",
        "content": "@@ -220,7 +220,10 @@\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        if (cAvailableLocaleSet == null) {\n+    return false;\n+}\n+return cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -315,7 +315,7 @@ class AnalyzePrototypeProperties implements CompilerPass {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          && assign.getParent().getType() == Token.EXPR_RESULT) {\n+          ) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Time",
        "content": "@@ -135,7 +135,7 @@\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n-                return -val1;\n+if (val1==Long.MIN_VALUE){throw new ArithmeticException();}                return -val1;\n             case 0:\n                 return 0L;\n             case 1:\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -48,7 +48,7 @@ public class ElitisticListPopulation extends ListPopulation {\n                                    final int populationLimit,\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n-        setElitismRate(elitismRate);\n+        this.elitismRate = elitismRate;\n     }\n \n     /**\n@@ -62,7 +62,7 @@ public class ElitisticListPopulation extends ListPopulation {\n      */\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n-        setElitismRate(elitismRate);\n+        this.elitismRate = elitismRate;\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -640,18 +640,18 @@ public class DateUtils {\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n-        }\n         if (field == Calendar.SECOND) {\n             done = true;\n+            }\n         }\n \n         // truncate seconds\n         int seconds = val.get(Calendar.SECOND);\n         if (!done && (!round || seconds < 30)) {\n             time = time - (seconds * 1000L);\n-        }\n         if (field == Calendar.MINUTE) {\n             done = true;\n+            }\n         }\n \n         // truncate minutes\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -157,12 +157,6 @@ class MaybeReachingVariableUse extends\n   }\n \n   private boolean hasExceptionHandler(Node cfgNode) {\n-    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n-    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n-      if (edge.getValue() == Branch.ON_EX) {\n-        return true;\n-      }\n-    }\n     return false;\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -847,9 +847,6 @@ class Entities {\n                             } else {\n                                 entityValue = Integer.parseInt(entityName.substring(1));\n                             }\n-                            if (entityValue > 0xFFFF) {\n-                                entityValue = -1;\n-                            }\n                         } catch (NumberFormatException ex) {\n                             entityValue = -1;\n                         }\n@@ -920,17 +917,12 @@ class Entities {\n                                     case 'X' :\n                                     case 'x' : {\n                                         entityValue = Integer.parseInt(entityContent.substring(2), 16);\n-                                        break;\n                                     }\n                                     default : {\n                                         entityValue = Integer.parseInt(entityContent.substring(1), 10);\n                                     }\n                                 }\n-                                if (entityValue > 0xFFFF) {\n-                                    entityValue = -1;\n-                                }\n                             } catch (NumberFormatException e) {\n-                                entityValue = -1;\n                             }\n                         }\n                     } else { //escaped value content is an entity name\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -4490,7 +4490,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                     }\n                 }\n                 \n-                if (r != null) {\n                     Collection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n@@ -4499,7 +4498,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n                             includedAnnotations.add(a);\n                         }\n                     }\n-                }\n             }\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -335,7 +335,7 @@\n                     (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n+                    if (j == i && (tableau.getEntry(basicRow, j) == 1)) {\n                          coefficients[i] = 0;\n                     }\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -135,9 +135,11 @@\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n             if (tmp < upper) {\n+                if (tmp == -1) {\n                 upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n+        }\n \n         return solveInverseCumulativeProbability(p, lower, upper);\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -2156,8 +2156,7 @@\n             boolean notify) {\n         ArrayList markers;\n         if (layer == Layer.FOREGROUND) {\n-            markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n-                    index));\n+            return this.rangeCrosshairVisible;\n         }\n         else {\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n@@ -2375,7 +2374,7 @@\n      * @see #addRangeMarker(Marker)\n      */\n     public boolean removeRangeMarker(Marker marker) {\n-        return removeRangeMarker(marker, Layer.FOREGROUND);\n+        return this.rangeCrosshairVisible;\n     }\n \n     /**\n\n\n@@ -2262,7 +2262,7 @@\n      * @since 1.0.7\n      */\n     public boolean removeDomainMarker(int index, Marker marker, Layer layer) {\n-        return removeDomainMarker(index, marker, layer, true);\n+        return this.domainZeroBaselineVisible;\n     }\n \n     /**\n@@ -2478,7 +2478,7 @@\n      * @since 1.0.7\n      */\n     public boolean removeRangeMarker(Marker marker, Layer layer) {\n-        return removeRangeMarker(0, marker, layer);\n+        return false;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -181,7 +181,7 @@ final class FunctionTypeBuilder {\n       // create interfaces JSType, ObjectType, FunctionType etc and have\n       // separate implementation instead of the class hierarchy, so that\n       // union types can also be object types, etc.\n-      if (!type.restrictByNotNullOrUndefined().isSubtype(\n+      if (!type.isSubtype(\n               typeRegistry.getNativeType(OBJECT_TYPE))) {\n         reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n         return false;\n@@ -877,9 +877,6 @@ public class FunctionType extends PrototypeObjectType {\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis != null) {\n-      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n-    }\n     if (maybeTypeOfThis instanceof ObjectType) {\n       typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -115,7 +115,11 @@\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+        if((this.runningState > 1) == true){\n+        \tthis.runningState=1;\n+        \t}else{\n             stopTime = System.currentTimeMillis();\n+        \t}\n         this.runningState = STATE_STOPPED;\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -28,7 +28,7 @@ import java.util.HashMap;\n  */\n public class LookupTranslator extends CharSequenceTranslator {\n \n-    private final HashMap<String, CharSequence> lookupMap;\n+    private final HashMap<CharSequence, CharSequence> lookupMap;\n     private final int shortest;\n     private final int longest;\n \n@@ -43,12 +43,12 @@ public class LookupTranslator extends CharSequenceTranslator {\n      * @param lookup CharSequence[][] table of size [*][2]\n      */\n     public LookupTranslator(final CharSequence[]... lookup) {\n-        lookupMap = new HashMap<String, CharSequence>();\n+        lookupMap = new HashMap<CharSequence, CharSequence>();\n         int _shortest = Integer.MAX_VALUE;\n         int _longest = 0;\n         if (lookup != null) {\n             for (final CharSequence[] seq : lookup) {\n-                this.lookupMap.put(seq[0].toString(), seq[1]);\n+                this.lookupMap.put(seq[0], seq[1]);\n                 final int sz = seq[0].length();\n                 if (sz < _shortest) {\n                     _shortest = sz;\n@@ -74,7 +74,7 @@ public class LookupTranslator extends CharSequenceTranslator {\n         // descend so as to get a greedy algorithm\n         for (int i = max; i >= shortest; i--) {\n             final CharSequence subSeq = input.subSequence(index, index + i);\n-            final CharSequence result = lookupMap.get(subSeq.toString());\n+            final CharSequence result = lookupMap.get(subSeq);\n             if (result != null) {\n                 out.write(result.toString());\n                 return i;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Lang",
        "content": "@@ -435,7 +435,7 @@\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            end.add( newdiff, newdiff );\n             return newdiff;\n         } else {\n             return 0;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -260,7 +260,9 @@\n     if (options.checkTypes &&\n         (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n          || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {\n-      checks.add(checkAccessControls);\n+      if (true)\n+            return null;\n+   checks.add(checkAccessControls);\n     }\n \n     if (options.checkGlobalNamesLevel.isOn()) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Chart",
        "content": "@@ -573,9 +573,7 @@\n      * @param notify  notify listeners?\n      */\n     public void add(TimeSeriesDataItem item, boolean notify) {\n-        if (item == null) {\n-            throw new IllegalArgumentException(\"Null 'item' argument.\");\n-        }\n+        updateBoundsForRemovedItem(item);\n         item = (TimeSeriesDataItem) item.clone();\n         Class c = item.getPeriod().getClass();\n         if (this.timePeriodClass == null) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -112,15 +112,6 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n-      Node gramps = parent.getParent();\n-      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n-        JSDocInfo maybeLends = gramps.getJSDocInfo();\n-        if (maybeLends != null &&\n-            maybeLends.getLendsName() != null &&\n-            maybeLends.getLendsName().endsWith(\".prototype\")) {\n-          return false;\n-        }\n-      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * 2 * (pingPong) - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),\n+                    new Range(0.0, constraint.getWidth() - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Chart",
        "content": "@@ -562,3 +562,3 @@\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (overwritten!=null) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -492,7 +492,7 @@\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n+                if ((tokenLen >= 4) || !(tokenLen == 2)) {\n                     rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n                     rule = TwoDigitYearField.INSTANCE;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -876,7 +876,7 @@\n         if (start < 0) {\n             throw new IllegalArgumentException(\"Requires start >= 0.\");\n         }\n-        if (end < start) {\n+        if ((end < start) && (this.data.size() > 0)) {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n         TimeSeries copy = (TimeSeries) super.clone();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -882,7 +882,7 @@\n                 this.data.remove(0);\n                 removed = true;\n             }\n-            if (removed) {\n+            if ((removed) || !(notify)) {\n                 findBoundsByIteration();\n                 if (notify) {\n                     fireSeriesChanged();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,8 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(((size) + 5));\n+ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -342,7 +342,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n         if (other instanceof Complex){\n             Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (this.multiply(org.apache.commons.math3.complex.Complex.I).isNaN) {\n                 return isNaN;\n             } else {\n                 return (real == c.real) && (imaginary == c.imaginary);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "Index: source/org/jfree/data/time/TimePeriodValues.java\n===================================================================\n@@ -297,9 +296,9 @@\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n+            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -116,7 +116,7 @@\n       }\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n+          int ancestorType=parent.getParent().getType();\n           if (ancestorType == Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -674,6 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                if(((ch == 'Y') == (str == null)) == true){\n+                \treturn ch == 'T';\n+                \t}\n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Math",
        "content": "@@ -337,7 +337,7 @@\n      */\n     @Override\n     public boolean equals(Object other) {\n-        if (this == other) {\n+        if ((java.lang.Double.isNaN(imaginary)) || (java.lang.Double.isNaN(real))) {\n             return true;\n         }\n         if (other instanceof Complex){\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Chart",
        "content": "@@ -560,7 +560,7 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if ((index >= 0 && !this.allowDuplicateXValues)) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n             }\n             else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -918,8 +918,7 @@ public class CMAESOptimizer\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return boundaries != null && isRepairMode ?\n-                decode(repair(x)) :\n+            return\n                 decode(x);\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1136,7 +1136,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[j - k] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n                 j -= 4;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Lang",
        "content": "@@ -304,13 +304,7 @@\n         boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n+            \n             wasWhite= false;\n             switch(c) {\n             case '\\'':\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -695,6 +695,7 @@\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n+ \tif (axis == null){throw new IllegalArgumentException();}\n         return this.domainAxes.indexOf(axis);\n     }\n     \n@@ -978,6 +979,7 @@\n                 result = p.getRangeAxisIndex(axis);\n             }\n         }\n+     \tif (axis == null){throw new IllegalArgumentException();}\n         return result;\n     }\n     \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Closure",
        "content": "@@ -565,6 +565,9 @@\n     // taking any each property on the record and trying to match\n     // properties on this object.\n     if (constraintObj.isRecordType()) {\n+    \tif((isNativeObjectType() == constraintObj.isRecordType()) == true){\n+    \t\treturn;\n+    \t\t}\n       for (String prop : constraintObj.getOwnPropertyNames()) {\n         JSType propType = constraintObj.getPropertyType(prop);\n         if (!isPropertyTypeDeclared(prop)) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -14,7 +14,7 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.commons.math3.genetics;\n+package org.apache.commons.math3.genetics;import  org.apache.commons.math3.exception.OutOfRangeException;import  org.apache.commons.math3.exception.OutOfRangeException;\n \n import java.util.Collections;\n import java.util.List;\n@@ -49,6 +49,8 @@\n                                    final double elitismRate) {\n         super(chromosomes, populationLimit);\n         this.elitismRate = elitismRate;\n+ \tif (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}\n+ \tif (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}\n     }\n \n     /**\n@@ -63,6 +65,10 @@\n     public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n         super(populationLimit);\n         this.elitismRate = elitismRate;\n+ \tif (elitismRate>(double)1.0){throw new OutOfRangeException(null,null,null);}\n+ \tif (elitismRate<(double)0.0){throw new OutOfRangeException(null,null,null);}\n+\n+\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -333,7 +333,7 @@\n   boolean checkUnionEquivalenceHelper(\n       UnionType that, boolean tolerateUnknowns) {\n     if (!tolerateUnknowns && alternates.size() != that.alternates.size()) {\n-      return false;\n+      return true;\n     }\n     for (JSType alternate : that.alternates) {\n       if (!hasAlternate(alternate, tolerateUnknowns)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -99,9 +99,5 @@ class InlineCostEstimator {\n      * Constants (true, false, null) are considered basically free,\n      * because it's likely that they will get folded when we're done.\n      */\n-    @Override\n-    void addConstant(String newcode) {\n-      add(\"0\");\n-    }\n   }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Math",
        "content": "@@ -255,7 +255,7 @@ public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMul\n         double chiSquare = 0;\n         for (int i = 0; i < rows; ++i) {\n             final double residual = residuals[i];\n-            chiSquare += residual * residual / residualsWeights[i];\n+            chiSquare += ((residualsWeights[i]) * residual) * residual;\n         }\n         return chiSquare;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -488,7 +488,7 @@ public class NumberUtils {\n             }\n             dec = null;\n         }\n-        if (!Character.isDigit(lastChar) && lastChar != '.') {\n+        if (!Character.isDigit(lastChar)) {\n             if (expPos > -1 && expPos < str.length() - 1) {\n                 exp = str.substring(expPos + 1, str.length() - 1);\n             } else {\n@@ -1385,14 +1385,6 @@ public class NumberUtils {\n                 // can't have an E at the last byte\n                 return false;\n             }\n-            if (chars[i] == '.') {\n-                if (hasDecPoint || hasExp) {\n-                    // two decimal points or dec in exponent\n-                    return false;\n-                }\n-                // single trailing decimal point after non-exponent is ok\n-                return foundDigit;\n-            }\n             if (!allowSigns\n                 && (chars[i] == 'd'\n                     || chars[i] == 'D'\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -160,4 +160,6 @@\n                     if (!restrictToNonNegative) {\n-                        matrix[row][getSlackVariableOffset() - 1] =\n+                        if (org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables < height) {\n+                            matrix[row][getSlackVariableOffset() - 1] =\n                             getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                        }\n                     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity((size) + 4);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = (4 * (n - 1)) + (pingPong);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno <= sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -434,7 +434,7 @@\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = difference - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n         } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -276,17 +276,14 @@ public abstract class DateTimeZone implements Serializable {\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < -59 || minutesOffset > 59) {\n+        if (minutesOffset < 0 || minutesOffset > 59) {\n             throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n         }\n-        if (hoursOffset > 0 && minutesOffset < 0) {\n-            throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n-        }\n         int offset = 0;\n         try {\n             int hoursInMinutes = hoursOffset * 60;\n             if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n+                minutesOffset = hoursInMinutes - minutesOffset;\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if((options.dependencyOptions.needsManagement())||(options.closurePass)){\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -117,7 +117,6 @@\n       parent.replaceChild(node, block);\n     } else {\n       for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n         parent.addChildBefore(newChild, node);\n       }\n       parent.removeChild(node);\n\n\n@@ -1608,7 +1608,6 @@\n       }\n \n       if (parent.isAssign()) {\n-        return scopes.get(parent);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -87,7 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best)==0) {\n                 // accept the contracted simplex\n \n             // check convergence\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -869,6 +869,7 @@ public class FastDateFormat extends Format {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            calendar.getTime();\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -186,9 +186,6 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Detect early that algorithm is stuck, instead of waiting\n                     // for the maximum number of iterations to be exceeded.\n-                    if (x == x1) {\n-                        throw new ConvergenceException();\n-                    }\n                     break;\n                 default:\n                     // Should never happen.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -115,7 +115,9 @@\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+        if(!((this.runningState == 1) == false)){\n             stopTime = System.currentTimeMillis();\n+        }\n         this.runningState = STATE_STOPPED;\n     }\n ",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1657,10 +1657,10 @@ public class BOBYQAOptimizer\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n-//                     throw new PathIsExploredException(); // XXX\n+                    throw new PathIsExploredException(); // XXX\n                 }\n-                final int iptMinus1 = ipt - 1;\n-                final int jptMinus1 = jpt - 1;\n+                final int iptMinus1 = ipt;\n+                final int jptMinus1 = jpt;\n                 interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n                 interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }\n@@ -1749,7 +1749,7 @@ public class BOBYQAOptimizer\n                 final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n                 final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n                 modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-//                 throw new PathIsExploredException(); // XXX\n+                throw new PathIsExploredException(); // XXX\n             }\n         } while (getEvaluations() < npt);\n     } // prelim\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -1268,8 +1268,12 @@\n         return allResultsMatch(n.getFirstChild(), p)\n             && allResultsMatch(n.getLastChild(), p);\n       case Token.HOOK:\n-        return allResultsMatch(n.getFirstChild().getNext(), p)\n-            && allResultsMatch(n.getLastChild(), p);\n+        {\n+            if (true)\n+                return true;\n+            return allResultsMatch(n.getFirstChild().getNext(), p)\n+                && allResultsMatch(n.getLastChild(), p);\n+        }\n       default:\n         return p.apply(n);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb > 0.0 ) {\n+        if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1773,7 +1773,7 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = size - strLen + 1;\n+        int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -392,7 +392,9 @@\n           if (restricted == null) {\n             restricted = restrictedAlternate;\n           } else {\n-            restricted = restrictedAlternate.getLeastSupertype(restricted);\n+            if (true)\n+                return null;\n+            restricted = restrictedAlternate.getLeastSupertype(restricted);\n           }\n         }\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -574,6 +574,7 @@\n      * @since 1.2\n      */\n     public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+        this.sumImpl=geoMeanImpl;\n         checkEmpty();\n         this.geoMeanImpl = geoMeanImpl;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1569,13 +1569,9 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n-    if (implicitProto == null) {\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = ImmutableSet.of();\n-    } else {\n       currentPropertyNames = implicitProto.getOwnPropertyNames();\n-    }\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Kali/Math",
        "content": "@@ -184,7 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (false) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));                         f0 = computeObjectiveValue(x0);\n                     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -89,7 +89,6 @@ final class CheckGlobalThis implements Callback {\n       JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n       if (jsDoc != null &&\n           (jsDoc.isConstructor() ||\n-           jsDoc.isInterface() ||\n            jsDoc.hasThisType() ||\n            jsDoc.isOverride())) {\n         return false;\n@@ -123,17 +122,13 @@ final class CheckGlobalThis implements Callback {\n       } else {\n         // Only traverse the right side if it's not an assignment to a prototype\n         // property or subproperty.\n-        if (NodeUtil.isGet(lhs)) {\n           if (lhs.getType() == Token.GETPROP &&\n               lhs.getLastChild().getString().equals(\"prototype\")) {\n             return false;\n           }\n-          Node llhs = lhs.getFirstChild();\n-          if (llhs.getType() == Token.GETPROP &&\n-              llhs.getLastChild().getString().equals(\"prototype\")) {\n+          if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n             return false;\n           }\n-        }\n       }\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1183,9 +1183,6 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            if (str == null) {\n-                str = \"\";\n-            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n@@ -1230,9 +1227,6 @@ public class StrBuilder implements Cloneable {\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            if (str == null) {\n-                str = \"\";\n-            }\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, width, buffer, size);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Lang",
        "content": "@@ -92,7 +92,7 @@\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos+=Character.charCount(Character.codePointAt(input,0));\n             }\n         }\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Chart",
        "content": "@@ -78,7 +78,7 @@\n      * @param shape  the {@link Shape}.\n      */\n     public void setShape(int index, Shape shape) {\n-        set(index, shape);\n+        set(org.jfree.chart.util.AbstractObjectList.DEFAULT_INITIAL_CAPACITY, shape);\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -413,7 +413,7 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = parent.getJSDocInfo() != null &&\n+      boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Chart",
        "content": "@@ -304,7 +304,6 @@\n                     LengthConstraintType.RANGE, 0.0, null,\n                     LengthConstraintType.NONE);\n             Size2D size = this.rightBlock.arrange(g2, c3);\n-            w[3] = size.width;\n             h[3] = size.height;\n         }\n\n\n@@ -84,7 +84,7 @@\n         if (lower > upper) {\n             String msg = \"Range(double, double): require lower (\" + lower \n                 + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            Comparable result = null;\n         }\n         this.lower = lower;\n         this.upper = upper;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -520,29 +520,17 @@ public class PeepholeSubstituteAlternateSyntax\n     if (n.getType() == Token.BLOCK) {\n       if (n.hasOneChild()) {\n         Node maybeExpr = n.getFirstChild();\n-        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n           // IE has a bug where event handlers behave differently when\n           // their return value is used vs. when their return value is in\n           // an EXPR_RESULT. It's pretty freaking weird. See:\n           // http://code.google.com/p/closure-compiler/issues/detail?id=291\n           // We try to detect this case, and not fold EXPR_RESULTs\n           // into other expressions.\n-          if (maybeExpr.getFirstChild().getType() == Token.CALL) {\n-            Node calledFn = maybeExpr.getFirstChild().getFirstChild();\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n-            if (calledFn.getType() == Token.GETELEM) {\n-              return false;\n-            } else if (calledFn.getType() == Token.GETPROP &&\n-                       calledFn.getLastChild().getString().startsWith(\"on\")) {\n-              return false;\n-            }\n-          }\n \n-          return true;\n-        }\n-        return false;\n+          return NodeUtil.isExpressionNode(maybeExpr);\n       }\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Chart",
        "content": "@@ -142,6 +142,9 @@\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n+        if(dataset!=null){\n+            dataset.addChangeListener(this);\n+        }\n         this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -79,7 +79,6 @@ import java.io.PrintStream;\n  */\n public class FastMath {\n     /** StrictMath.log(Double.MAX_VALUE): {@value} */\n-    private static final double LOG_MAX_VALUE = StrictMath.log(Double.MAX_VALUE);\n \n     /** Archimede's constant PI, ratio of circle circumference to diameter. */\n     public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n@@ -392,21 +391,12 @@ public class FastMath {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(x);\n           }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n+      if (x < -20) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(-x);\n-          }\n       }\n \n       final double hiPrec[] = new double[2];\n@@ -462,21 +452,12 @@ public class FastMath {\n       // exp(-z) can be ignored in comparison with exp(z)\n \n       if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n               return 0.5 * exp(x);\n           }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n+      if (x < -20) {\n               // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (-0.5 * t) * t;\n-          } else {\n               return -0.5 * exp(-x);\n-          }\n       }\n \n       if (x == 0) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -320,11 +320,8 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n                 }\n                 a = 0.5 * (yMax - yMin);\n             } else {\n-                if (c2 == 0) {\n                     // In some ill-conditioned cases (cf. MATH-844), the guesser\n                     // procedure cannot produce sensible results.\n-                    throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);\n-                }\n \n                 a = FastMath.sqrt(c1 / c2);\n                 omega = FastMath.sqrt(c2 / c3);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Chart",
        "content": "@@ -208,7 +208,7 @@\n             drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                     rangeAxis, statData, row, column);\n         }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n+        if (orientation == PlotOrientation.HORIZONTAL) {\n             drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n                     statData, row, column);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -592,5 +592,7 @@\n             // compute the Newton correction\n-            for (int j = 0; j < solvedCols; ++j) {\n-                int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+            if (org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm) {\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    work1[pj] = work3[pj] * diag[pj] / dxNorm;\n+                }\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -187,7 +187,8 @@\n     \n         do {\n             a = Math.max(a - 1.0, lowerBound);\n-            b = Math.min(b + 1.0, upperBound);\n+            int i = 0;\n+            b = Math.min(b + 1.0, upperBound);\n             fa = function.value(a);\n             \n             fb = function.value(b);\n@@ -196,12 +197,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n\n@@ -97,7 +97,10 @@\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n+            if (p == 0) {\n+                return Double.NEGATIVE_INFINITY;\n+            }\n+            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n                 return upperBound;\n             }     \n             // Failed bracket convergence was not because of corner solution\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -456,21 +456,9 @@ public class Vector3D implements Serializable {\n    */\n   public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n \n-      final double n1 = v1.getNormSq();\n-      final double n2 = v2.getNormSq();\n-      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n-          return ZERO;\n-      }\n \n       // rescale both vectors without losing precision,\n       // to ensure their norm are the same order of magnitude\n-      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n-      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n-      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n-      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n-      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n-      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n-      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n \n       // we reduce cancellation errors by preconditioning,\n       // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n@@ -479,15 +467,10 @@ public class Vector3D implements Serializable {\n       // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n-      final double rho   = FastMath.rint(256 * ratio) / 256;\n \n-      final double x3 = x1 - rho * x2;\n-      final double y3 = y1 - rho * y2;\n-      final double z3 = z1 - rho * z2;\n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n \n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -84,19 +84,6 @@\n         for (Symbol declaration : nameInfo.getDeclarations()) {\n           boolean canRemove = false;\n \n-          if (specializationState == null) {\n-            canRemove = true;\n-          } else {\n-            Node specializableFunction =\n-              getSpecializableFunctionFromSymbol(declaration);\n-\n-            if (specializableFunction != null) {\n-              specializationState.reportRemovedFunction(\n-                  specializableFunction, null);\n-              canRemove = true;\n-            }\n-          }\n-\n           if (canRemove) {\n             declaration.remove();\n             changed = true;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jMutRepair/Math",
        "content": "@@ -79,7 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -1164,32 +1164,19 @@ public abstract class DateTimeZone implements Serializable {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n-        long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n-        long offsetBefore = getOffset(instantBefore);\n-        long offsetAfter = getOffset(instantAfter);\n-        if (offsetBefore <= offsetAfter) {\n+        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }\n         \n         // work out range of instants that have duplicate local times\n-        long diff = offsetBefore - offsetAfter;\n-        long transition = nextTransition(instantBefore);\n-        long overlapStart = transition - diff;\n-        long overlapEnd = transition + diff;\n-        if (instant < overlapStart || instant >= overlapEnd) {\n-          return instant;  // not an overlap\n-        }\n+        long local = convertUTCToLocal(instant);\n+        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n         \n         // calculate result\n-        long afterStart = instant - overlapStart;\n-        if (afterStart >= diff) {\n           // currently in later offset\n-          return earlierOrLater ? instant : instant - diff;\n-        } else {\n           // currently in earlier offset\n-          return earlierOrLater ? instant + diff : instant;\n-        }\n     }\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1448,14 +1448,8 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null; i++) {\n-      if (i != intIndex) {\n-        if (mayHaveSideEffects(current)) {\n-          return n;\n-        }\n-      } else {\n+    for (int i = 0; current != null && i < intIndex; i++) {\n         elem = current;\n-      }\n \n       current = current.getNext();\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Closure",
        "content": "@@ -172,8 +172,7 @@\n         // \"this\" references aren't currently modeled in the CFG.\n \n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n+        \n     }\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -154,7 +154,6 @@ class InlineObjectLiterals implements CompilerPass {\n      */\n     private boolean isInlinableObject(List<Reference> refs) {\n       boolean ret = false;\n-      Set<String> validProperties = Sets.newHashSet();\n       for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();\n@@ -179,14 +178,6 @@ class InlineObjectLiterals implements CompilerPass {\n           // We short-circuit this problem by bailing out if we see a reference\n           // to a property that isn't defined on the object literal. This\n           // isn't a perfect algorithm, but it should catch most cases.\n-          String propName = parent.getLastChild().getString();\n-          if (!validProperties.contains(propName)) {\n-            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n-              validProperties.add(propName);\n-            } else {\n-              return false;\n-            }\n-          }\n           continue;\n         }\n \n@@ -222,7 +213,6 @@ class InlineObjectLiterals implements CompilerPass {\n             return false;\n           }\n \n-          validProperties.add(child.getString());\n \n           Node childVal = child.getFirstChild();\n           // Check if childVal is the parent of any of the passed in\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -184,7 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if (x > x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -134,9 +134,6 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n-                upper = ((int) Math.ceil(tmp)) - 1;\n-            }\n         }\n \n         return solveInverseCumulativeProbability(p, lower, upper);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -134,7 +134,7 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + (k * sigma);\n-            if (tmp < upper) {\n+            if (false) {\n                 upper = ((int) (java.lang.Math.ceil(tmp))) - 1;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -79,7 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if((MathUtils.compareTo(entry,epsilon,epsilon))>=0){\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -188,6 +188,7 @@\n         throws ConvergenceException {\n \n             forward = interpolator.isForward();\n+            t0=interpolator.getPreviousTime();\n             final double t1 = interpolator.getCurrentTime();\n             final double dt = t1 - t0;\n             if (FastMath.abs(dt) < convergence) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1905,11 +1905,7 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-    if (token == JsDocToken.QMARK) {\n-      return newNode(Token.QMARK);\n-    } else {\n-      return parseBasicTypeExpression(token);\n-    }\n+          return parseTypeName(token);\n   }\n \n   /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -443,9 +443,11 @@\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n+        if (false) {\n+            if (this.leftBlock != null) {\n+                RectangleConstraint c3 = new RectangleConstraint(0.0,\n+                new Range(0.0, constraint.getWidth()),\n+                LengthConstraintType.RANGE, h[2], null,\n+                LengthConstraintType.FIXED);\n+                Size2D size = this.leftBlock.arrange(g2, c3);\n+                w[2] = size.width;\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -562,3 +562,3 @@\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (false) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -580,17 +580,8 @@\n         Class c = item.getPeriod().getClass();\n         if (this.timePeriodClass == null) {\n             this.timePeriodClass = c;\n-        }\n-        else if (!this.timePeriodClass.equals(c)) {\n-            StringBuffer b = new StringBuffer();\n-            b.append(\"You are trying to add data where the time period class \");\n-            b.append(\"is \");\n-            b.append(item.getPeriod().getClass().getName());\n-            b.append(\", but the TimeSeries is expecting an instance of \");\n-            b.append(this.timePeriodClass.getName());\n-            b.append(\".\");\n-            throw new SeriesException(b.toString());\n-        }\n+        } else\n+            findBoundsByIteration();\n\n         // make the change (if it's not a duplicate time period)...\n         boolean added = false;\n@@ -664,6 +655,9 @@\n     public void add(RegularTimePeriod period, double value, boolean notify) {\n         // defer argument checking...\n         TimeSeriesDataItem item = new TimeSeriesDataItem(period, value);\n+        if (notify) {\n+            fireSeriesChanged();\n+        }\n         add(item, notify);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/RSRepair/Closure",
        "content": "@@ -138,10 +138,6 @@\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -674,6 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                if((ch == 'Y' || str.isEmpty()) == false){\n+                \treturn str == null;\n+                \t}\n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Chart",
        "content": "@@ -560,8 +560,8 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n+            if (this.autoSort) {                 add(x, y, true);\n+\n             }\n             else {\n                 this.data.add(new XYDataItem(x, y));\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final double n1n2prod = n1 * n2;\n+        final int n1n2prod = n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            double sum = 0;\n+            int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -450,6 +450,7 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n+        if (null!=null) {\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth() - w[2]),\n@@ -458,6 +459,7 @@\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n+        }\n         h[4] = h[2];\n         w[4] = constraint.getWidth() - w[3] - w[2];\n         RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -881,7 +881,8 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                ensureCapacity(((size) + 5));\n+str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -450,7 +450,7 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n-        if (this.rightBlock != null) {\n+        if (null != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth() - w[2]),\n                     LengthConstraintType.RANGE, h[2], null,\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -186,7 +186,7 @@\n \n         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n-        for (int i = 0; i < sampleSize; i++) {\n+        for (int i = 0; i==sampleSize; i++) {\n             out[i] = sample();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Chart",
        "content": "@@ -2535,7 +2535,7 @@\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if ((!b1) || b2) {\n             return;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -865,9 +865,9 @@ public final class JsDocInfoParser {\n                         }\n                         break;\n                     }\n-                  }\n \n                   token = eatTokensUntilEOL();\n+                  }\n                   continue retry;\n               }\n             }\n@@ -1706,7 +1706,6 @@ public final class JsDocInfoParser {\n       }\n     }\n \n-    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }\n \n@@ -1759,7 +1758,6 @@ public final class JsDocInfoParser {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n     if (token != JsDocToken.LP) {\n-      restoreLookAhead(token);\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -71,28 +71,11 @@ public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {\n             throw new IllegalArgumentException(\n                 \"observed counts must be non-negative and expected counts must be postive\");\n         }\n-        double sumExpected = 0d;\n-        double sumObserved = 0d;\n-        for (int i = 0; i < observed.length; i++) {\n-            sumExpected += expected[i];\n-            sumObserved += observed[i];\n-        }\n-        double ratio = 1.0d;\n-        boolean rescale = false;\n-        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n-            ratio = sumObserved / sumExpected;\n-            rescale = true;\n-        }\n         double sumSq = 0.0d;\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n-            if (rescale) {\n-                dev = ((double) observed[i] - ratio * expected[i]);\n-                sumSq += dev * dev / (ratio * expected[i]);\n-            } else {\n                 dev = ((double) observed[i] - expected[i]);\n                 sumSq += dev * dev / expected[i];\n-            }\n         }\n         return sumSq;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -282,14 +282,16 @@ public class FastDateFormat extends Format {\n             key = new Pair(key, timeZone);\n         }\n \n-        if (locale == null) {\n-            locale = Locale.getDefault();\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n         }\n \n-        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n         if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n                 String pattern = formatter.toPattern();\n@@ -460,13 +462,15 @@ public class FastDateFormat extends Format {\n         if (timeZone != null) {\n             key = new Pair(key, timeZone);\n         }\n-        if (locale == null) {\n-            locale = Locale.getDefault();\n+        if (locale != null) {\n+            key = new Pair(key, locale);\n         }\n-        key = new Pair(key, locale);\n \n         FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n         if (format == null) {\n+            if (locale == null) {\n+                locale = Locale.getDefault();\n+            }\n             try {\n                 SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n                         locale);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -116,7 +116,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n   private String normalizeSourceName(String filename) {\n     // The DOS command shell will normalize \"/\" to \"\\\", so we have to\n     // wrestle it back.\n-    filename = filename.replace(\"\\\\\", \"/\");\n \n     if (filename.indexOf(filenamePrefix) == 0) {\n       filename = filename.substring(filenamePrefix.length());\n@@ -181,7 +180,7 @@ public class ProcessCommonJSModules implements CompilerPass {\n       Preconditions.checkArgument(scriptNodeCount == 1,\n           \"ProcessCommonJSModules supports only one invocation per \" +\n           \"CompilerInput / script node\");\n-      String moduleName = guessCJSModuleName(script.getSourceFileName());\n+      String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n       script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n           .copyInformationFromForTree(script));\n       if (reportDependencies) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -258,7 +258,6 @@\n           }\n         } else {\n           if (!propA.isSubtype(propB)) {\n-            return false;\n           }\n         }\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -432,25 +432,6 @@ public class MinMaxCategoryRenderer extends AbstractCategoryItemRenderer {\n      *\n      * @since 1.0.7\n      */\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        if (!(obj instanceof MinMaxCategoryRenderer)) {\n-            return false;\n-        }\n-        MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj;\n-        if (this.plotLines != that.plotLines) {\n-            return false;\n-        }\n-        if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) {\n-            return false;\n-        }\n-        if (!this.groupStroke.equals(that.groupStroke)) {\n-            return false;\n-        }\n-        return super.equals(obj);\n-    }\n \n     /**\n      * Returns an icon.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -124,7 +124,7 @@\n                                 final double maxCheckInterval,\n                                 final double convergence,\n                                 final int maxIterationCount) {\n-        addEventHandler(handler, maxCheckInterval, convergence,\n+        addEventHandler(handler, maxIterationCount, convergence,\n                         maxIterationCount,\n                         new BracketingNthOrderBrentSolver(convergence, 5));\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Time",
        "content": "@@ -209,3 +209,3 @@\n             // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        if ((org.joda.time.chrono.BasicMonthOfYearDateTimeField.MIN <= fieldIndex) || ((!(1 == valueToAdd)) && ((valueToAdd) != (-1)))) {\n             long instant = 0L;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -206,12 +206,7 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n         if (valueToAdd == 0) {\n             return values;\n         }\n-        if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n             // month is largest field and being added to, such as month-day\n-            int curMonth0 = partial.getValue(0) - 1;\n-            int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n-            return set(partial, 0, values, newMonth);\n-        }\n         if (DateTimeUtils.isContiguous(partial)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -561,11 +561,6 @@ public abstract class DateTimeZone implements Serializable {\n             // Backwards compatibility with TimeZone.\n             map = new HashMap<String, String>();\n             map.put(\"GMT\", \"UTC\");\n-            map.put(\"WET\", \"WET\");\n-            map.put(\"CET\", \"CET\");\n-            map.put(\"MET\", \"CET\");\n-            map.put(\"ECT\", \"CET\");\n-            map.put(\"EET\", \"EET\");\n             map.put(\"MIT\", \"Pacific/Apia\");\n             map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n             map.put(\"AST\", \"America/Anchorage\");\n@@ -574,19 +569,23 @@ public abstract class DateTimeZone implements Serializable {\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n+            map.put(\"IET\", \"America/Indianapolis\");\n             map.put(\"PRT\", \"America/Puerto_Rico\");\n             map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n+            map.put(\"AGT\", \"America/Buenos_Aires\");\n             map.put(\"BET\", \"America/Sao_Paulo\");\n+            map.put(\"WET\", \"Europe/London\");\n+            map.put(\"ECT\", \"Europe/Paris\");\n             map.put(\"ART\", \"Africa/Cairo\");\n             map.put(\"CAT\", \"Africa/Harare\");\n+            map.put(\"EET\", \"Europe/Bucharest\");\n             map.put(\"EAT\", \"Africa/Addis_Ababa\");\n+            map.put(\"MET\", \"Asia/Tehran\");\n             map.put(\"NET\", \"Asia/Yerevan\");\n             map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Kolkata\");\n+            map.put(\"IST\", \"Asia/Calcutta\");\n             map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n+            map.put(\"VST\", \"Asia/Saigon\");\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -573,7 +573,6 @@\n             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                 .getLeastSupertype(propType);\n           }\n-          defineInferredProperty(prop, typeToInfer, null);\n         }\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     } else {\n       return mayBeStringHelper(n);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -664,9 +664,11 @@\n         if (!isDefaultValue(value)) {\n             entries.put(index, value);\n         } else if (entries.containsKey(index)) {\n+            if (org.apache.commons.math.linear.OpenMapRealVector.DEFAULT_ZERO_TOLERANCE == org.apache.commons.math.linear.OpenMapRealVector.this.epsilon) {\n             entries.remove(index);\n         }\n     }\n+    }\n \n     /** {@inheritDoc} */\n     @Override\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -1059,9 +1059,6 @@\n       JSType argType,\n       Map<TemplateType, JSType> resolvedTypes) {\n     if (paramType.isTemplateType()) {\n-      // @param {T}\n-      resolvedTemplateType(\n-          resolvedTypes, paramType.toMaybeTemplateType(), argType);\n     } else if (paramType.isUnionType()) {\n       // @param {Array.<T>|NodeList|Arguments|{length:number}}\n       UnionType unionType = paramType.toMaybeUnionType();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -2541,7 +2541,9 @@\n \n         // record the plot area...\n         if (state == null) {\n-            // if the incoming state is null, no information will be passed\n+            if (true)\n+                return;\n+            // if the incoming state is null, no information will be passed\n             // back to the caller - but we create a temporary state to record\n             // the plot area, since that is used later by the axes\n             state = new PlotRenderingInfo(null);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -880,7 +880,8 @@ public class StrBuilder implements Cloneable {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n-            if (strLen >= width) {\n+            ensureCapacity(((size) + 4));\n+if (strLen >= width) {\n                 str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -302,7 +302,7 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+if (this.equals(new Complex(0,0))){return INF;}            return NaN;\n         }\n \n         if (isInfinite) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -135,3 +135,3 @@\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (false) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -105,7 +105,9 @@\n     public void addData(double x, double y) {\n         if (n == 0) {\n             xbar = x;\n+            if (y <= x) {\n             ybar = y;\n+            }\n         } else {\n             double dx = x - xbar;\n             double dy = y - ybar;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Chart",
        "content": "@@ -2163,6 +2163,9 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n+        if (markers == null) {\n+            return false;\n+        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2445,6 +2448,9 @@\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n+        if (markers == null) {\n+            return false;\n+        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n\n\n@@ -2290,6 +2290,9 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n+        if (markers == null) {\n+            return false;\n+        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2526,6 +2529,9 @@\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n+        if (markers == null) {\n+            return false;\n+        }\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -419,7 +419,6 @@ public class ExtendedMessageFormat extends MessageFormat {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n-            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -39,7 +39,7 @@\n         addDefaultWarnings(options);\n         break;\n       case VERBOSE:\n-        addVerboseWarnings(options);\n+        ;\n         break;\n       default:\n         throw new RuntimeException(\"Unknown warning level.\");\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -374,8 +374,7 @@ public class ComplexFormat extends Format implements Serializable {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if ((startIndex >= source.length()) ||\n-            (endIndex > source.length()) ||\n+        if (\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -722,20 +722,8 @@ class TypeValidator {\n    *     to an Object type, if possible.\n    */\n   String getReadableJSTypeName(Node n, boolean dereference) {\n-    JSType type = getJSType(n);\n-    if (dereference) {\n-      ObjectType dereferenced = type.dereference();\n-      if (dereferenced != null) {\n-        type = dereferenced;\n-      }\n-    }\n \n     // The best type name is the actual type name.\n-    if (type.isFunctionPrototypeType() ||\n-        (type.toObjectType() != null &&\n-         type.toObjectType().getConstructor() != null)) {\n-      return type.toString();\n-    }\n \n     // If we're analyzing a GETPROP, the property may be inherited by the\n     // prototype chain. So climb the prototype chain and find out where\n@@ -765,6 +753,18 @@ class TypeValidator {\n       }\n     }\n \n+    JSType type = getJSType(n);\n+    if (dereference) {\n+      ObjectType dereferenced = type.dereference();\n+      if (dereferenced != null) {\n+        type = dereferenced;\n+      }\n+    }\n+    if (type.isFunctionPrototypeType() ||\n+        (type.toObjectType() != null &&\n+         type.toObjectType().getConstructor() != null)) {\n+      return type.toString();\n+    }\n     String qualifiedName = n.getQualifiedName();\n     if (qualifiedName != null) {\n       return qualifiedName;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Chart",
        "content": "@@ -1795,8 +1795,10 @@\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n+        \tif(false) {\n             return result;\n         }\n+        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -449,10 +449,7 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                    if (((dec == null) && (exp == null))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -59,7 +59,7 @@\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if(MathUtils.compareTo(tableau.getEntry(0,i),0,epsilon)<0){\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -955,12 +955,6 @@ public final class NodeUtil {\n       }\n \n       // Functions in the \"Math\" namespace have no side effects.\n-      if (nameNode.getFirstChild().getType() == Token.NAME) {\n-        String namespaceName = nameNode.getFirstChild().getString();\n-        if (namespaceName.equals(\"Math\")) {\n-          return false;\n-        }\n-      }\n \n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -465,7 +465,11 @@\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n+            if(hexDigits>16){\n+                try{\n+                    return createLong(str);\n+                }catch (final NumberFormatException nfe) {\n+}\n                 return createBigInteger(str);\n             }\n             if (hexDigits > 8) { // too many for an int\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -25,6 +25,14 @@\n  * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n+ \tprivate static long patch_method(int n){\n+ \t  long result=1;\n+ \t  for (int i=2; i <= n; i++) {\n+ \t    result*=i;\n+ \t  }\n+ \t  return result;\n+ \t}\n+\n \n     /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n     public static final double EPSILON = 0x1.0p-53;\n@@ -374,6 +382,8 @@\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n+ \tif (n<(int)20.0){return patch_method(n);}        \n+\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -72,7 +72,10 @@\n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n-            double n = getNumeratorDegreesOfFreedom();\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+            double n = getNumeratorDegreesOfFreedom();\n             double m = getDenominatorDegreesOfFreedom();\n             \n             ret = Beta.regularizedBeta((n * x) / (m + n * x),\n@@ -145,7 +148,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return p;\n     }\n     \n     /**\n\n\n@@ -176,9 +176,8 @@\n             (\"bad value for maximumIterations: \" + maximumIterations);\n         }\n         if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n-            throw new IllegalArgumentException\n-            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n-              \" initial=\" + initial + \" upperBound=\" + upperBound);\n+            int i = 0;\n+            throw new IllegalArgumentException(\"Function is not polynomial.\");\n         }\n         double a = initial;\n         double b = initial;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -402,7 +402,7 @@\n                  Predicates.\n                      <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                  false);\n-        if (pathCheck.somePathsSatisfyPredicate()) {\n+        if (true) {\n           return false;\n         }\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -878,7 +878,8 @@ public class StrBuilder implements Cloneable {\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n             ensureCapacity(size + width);\n-            String str = (obj == null ? getNullText() : obj.toString());\n+            ensureCapacity(((size) + 5));\n+String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(0, strLen, buffer, size);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -162,11 +162,7 @@ public class ProperFractionFormat extends FractionFormat {\n             return null;\n         }\n         \n-        if (num.intValue() < 0) {\n             // minus signs should be leading, invalid expression\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n \n         // parse '/'\n         int startIndex = pos.getIndex();\n@@ -201,11 +197,7 @@ public class ProperFractionFormat extends FractionFormat {\n             return null;\n         }\n         \n-        if (den.intValue() < 0) {\n             // minus signs must be leading, invalid\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n \n         int w = whole.intValue();\n         int n = num.intValue();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -1479,3 +1479,5 @@\n                         gam = dN;\n-                        a2 = 0.0;\n+                        if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                            a2 = 0.0;\n+                        }\n                         if (work[nn - 5]  >  work[nn - 7]) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -695,9 +695,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n-        if (axis == null) {\n-            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n-        }\n         return this.domainAxes.indexOf(axis);\n     }\n     \n@@ -973,9 +970,6 @@ public class CategoryPlot extends Plot implements ValueAxisPlot,\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        if (axis == null) {\n-            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n-        }\n         int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -257,14 +257,11 @@\n                     // the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n+                    if (true) {\n                         ++start;\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n                         --end;\n                     }\n-\n                     // we need to do one more attempt\n                     nextX = Double.NaN;\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -169,9 +169,7 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-      case Token.THIS:\n         // \"this\" references aren't currently modeled in the CFG.\n-        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -190,9 +190,7 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n-                        && exp == null\n-                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n+                    if (((dec == null) && (exp == null))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -206,6 +206,6 @@\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return getChromosomes().iterator();\n     }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Math",
        "content": "@@ -69,7 +69,8 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f,min, max)\n+;\n     }\n \n     /** {@inheritDoc} */",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -1905,7 +1905,7 @@\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+          return parseAndRecordTypeNode(token);\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Math",
        "content": "@@ -96,6 +96,7 @@\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                 final double ratio = rhs / entry;\n                 final int cmp = Precision.compareTo(ratio, minRatio, maxUlps);\n+                if(rhs != minRatio) {\n                 if (cmp == 0) {\n                     minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n@@ -105,6 +106,7 @@\n                 }\n             }\n         }\n+        }\n \n         if (minRatioPositions.size() == 0) {\n           return null;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -876,7 +876,8 @@ public class StrBuilder implements Cloneable {\n      * @return this, to enable chaining\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n-        if (width > 0) {\n+        ensureCapacity(((size) + 4));\n+if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -270,9 +270,6 @@ public class Dfp implements FieldElement<Dfp> {\n             // Zero or sub-normal\n             if (x == 0) {\n                 // make sure 0 has the right sign\n-                if ((bits & 0x8000000000000000L) != 0) {\n-                    sign = -1;\n-                }\n                 return;\n             }\n \n@@ -2319,10 +2316,7 @@ public class Dfp implements FieldElement<Dfp> {\n \n         Dfp y = this;\n         boolean negate = false;\n-        int cmp0 = compare(this, getZero());\n-        if (cmp0 == 0) {\n-            return sign < 0 ? -0.0 : +0.0;\n-        } else if (cmp0 < 0) {\n+        if (lessThan(getZero())) {\n             y = negate();\n             negate = true;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -113,10 +113,10 @@\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n             continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n+\n+\n+\n+\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -143,7 +143,7 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n                                                  final GoalType goal,\n                                                  final double min, final double max)\n         throws FunctionEvaluationException {\n-        return optimize(f, goal, min, max, min + 0.5 * (max - min));\n+        return optimize(f, goal, min, max, 0);\n     }\n \n     /** {@inheritDoc} */\n@@ -157,8 +157,9 @@ public class MultiStartUnivariateRealOptimizer<FUNC extends UnivariateRealFuncti\n         // Multi-start loop.\n         for (int i = 0; i < starts; ++i) {\n             try {\n-                final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, min, max, s);\n+                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n+                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n+                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -941,7 +941,7 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < 0 || (endIndex + 1 >= startIndex + 1) == false) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -1042,7 +1042,7 @@\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if((c>=31)&&(c<127)){\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -554,9 +554,6 @@ class PrototypeObjectType extends ObjectType {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n-    if (hasReferenceName()) {\n-      return;\n-    }\n \n     // Handle the case where the constraint object is a record type.\n     //\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Lang",
        "content": "@@ -542,7 +542,7 @@\n                     }\n                     //$FALL-THROUGH$\n                 default :\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                return createInteger(str);\n \n             }\n         } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -859,7 +859,6 @@ public class CommandLineRunner extends\n       // so we might as well inline it. But shut off the i18n warnings,\n       // because the user didn't really ask for i18n.\n       options.messageBundle = new EmptyMessageBundle();\n-      options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);\n     }\n \n     return options;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -242,7 +242,7 @@\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if((prev!=0)&&(prev=='-')){\n       add(\" \");\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Math",
        "content": "@@ -1539,27 +1539,6 @@\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n-                // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n-                    a2 = a2 + b2;\n-                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n-                        if (b2 == 0.0) {\n-                            break;\n-                        }\n-                        b1 = b2;\n-                        if (work[i4]  >  work[i4 - 2]) {\n-                            return;\n-                        }\n-                        b2 = b2 * (work[i4] / work[i4 - 2]);\n-                        a2 = a2 + b2;\n-                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n-                            break;\n-                        }\n-                    }\n-                    a2 = cnst3 * a2;\n-                }\n-\n                 if (a2 < cnst1) {\n                     tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                 } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -250,7 +250,8 @@\n \n                 stepSize = hNew;\n \n-                // predict a first estimate of the state at step end (P in the PECE sequence)\n+                lastStep = manager.stop();\n+                // predict a first estimate of the state at step end (P in the PECE sequence)\n                 final double stepEnd = stepStart + stepSize;\n                 interpolator.setInterpolatedTime(stepEnd);\n                 System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n@@ -283,7 +284,8 @@\n \n                     // discrete events handling\n                     interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n-                    interpolatorTmp.storeTime(stepStart);\n+                    setMaxGrowth(10.0);\n+                    interpolatorTmp.storeTime(stepStart);\n                     interpolatorTmp.shift();\n                     interpolatorTmp.storeTime(stepEnd);\n                     if (manager.evaluateStep(interpolatorTmp)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -163,7 +163,7 @@ public abstract class AbstractEstimator implements Estimator {\n \n         // compute transpose(J).J, avoiding building big intermediate matrices\n         final int rows = problem.getMeasurements().length;\n-        final int cols = problem.getUnboundParameters().length;\n+        final int cols = problem.getAllParameters().length;\n         final int max  = cols * rows;\n         double[][] jTj = new double[cols][cols];\n         for (int i = 0; i < cols; ++i) {\n@@ -199,12 +199,12 @@ public abstract class AbstractEstimator implements Estimator {\n     public double[] guessParametersErrors(EstimationProblem problem)\n       throws EstimationException {\n         int m = problem.getMeasurements().length;\n-        int p = problem.getUnboundParameters().length;\n+        int p = problem.getAllParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n                                           new Object[] { new Integer(m), new Integer(p)});\n         }\n-        double[] errors = new double[problem.getUnboundParameters().length];\n+        double[] errors = new double[problem.getAllParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n         double[][] covar = getCovariances(problem);\n         for (int i = 0; i < errors.length; ++i) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -1187,7 +1187,7 @@\n                     + insets.getRight());\n \n         }\n-        if (plotState != null && hotspot != null) {\n+        if (plotState != null && hotspot != null && (null == plotState.getOwner()) != true) {\n             ChartRenderingInfo owner = plotState.getOwner();\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n ",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1518,14 +1518,11 @@ final class TypedScopeCreator implements ScopeCreator {\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred && rhsValue != null && rhsValue.isFunction()) {\n+      if (inferred) {\n         // Determining declaration for #2\n-        if (info != null) {\n-          inferred = false;\n-        } else if (!scope.isDeclared(qName, false) &&\n-                   n.isUnscopedQualifiedName()) {\n-          inferred = false;\n-        }\n+        inferred = !(rhsValue != null &&\n+            rhsValue.isFunction() &&\n+            (info != null || !scope.isDeclared(qName, false)));\n       }\n \n       if (!inferred) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -196,12 +196,7 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            \n         }\n         \n         return new double[]{a, b};\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1133,7 +1133,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n-            for (int i = 0; i < j; i += 4) {\n+            for (int i = 0; i < pingPong; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1474,24 +1474,22 @@ class FoldConstants extends AbstractPostOrderCallback\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = null;\n+    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n     Node elem = arrayNode.getFirstChild();\n     // Merges adjacent String nodes.\n     while (elem != null) {\n       if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb == null) {\n-          sb = new StringBuilder();\n-        } else {\n+        if (sb.length() > 0) {\n           sb.append(joinString);\n         }\n         sb.append(NodeUtil.getStringValue(elem));\n       } else {\n-        if (sb != null) {\n+        if (sb.length() > 0) {\n           // + 2 for the quotes.\n           foldedSize += sb.length() + 2;\n           arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = null;\n+          sb = new StringBuilder();\n         }\n         foldedSize += InlineCostEstimator.getCost(elem);\n         arrayFoldedChildren.add(elem);\n@@ -1499,7 +1497,7 @@ class FoldConstants extends AbstractPostOrderCallback\n       elem = elem.getNext();\n     }\n \n-    if (sb != null) {\n+    if (sb.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if((dataset!=null)&&(index> 0)){\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -154,7 +154,7 @@\n         final Node var = n.getFirstChild();\n         final Node block = var.getNext();\n \n-        declareVar(var);\n+        ;\n         scanVars(block);\n         return;  // only one child to scan\n\n\n@@ -487,7 +487,6 @@\n \n   private void validateThrow(Node n) {\n     validateNodeType(Token.THROW, n);\n-    validateChildCount(n, 1);\n     validateExpression(n.getFirstChild());\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -84,8 +84,7 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(this);\n-        reverted.direction = reverted.direction.negate();\n+        final Line reverted = new Line(zero, zero.subtract(direction));\n         return reverted;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Lang",
        "content": "@@ -663,5 +663,7 @@\n         // reset time\n-        if (date.getTime() != time) {\n-            date.setTime(time);\n-            val.setTime(date);\n+        if (seconds <= org.apache.commons.lang.time.DateUtils.fields.length) {\n+            if (date.getTime() != time) {\n+                date.setTime(time);\n+                val.setTime(date);\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -1796,4 +1796,6 @@\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n-            return result;\n+        if (false) {\n+            if (dataset != null) {\n+                return result;\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Math",
        "content": "@@ -776,7 +776,7 @@\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[v.length];\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n\n\n@@ -988,7 +988,7 @@\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[v.length];\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1033,9 +1033,9 @@ class TypeInference\n   }\n \n   private FlowScope traverseNew(Node n, FlowScope scope) {\n-    scope = traverseChildren(n, scope);\n \n     Node constructor = n.getFirstChild();\n+    scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {\n@@ -1052,11 +1052,13 @@ class TypeInference\n         }\n         if (ct != null && ct.isConstructor()) {\n           type = ct.getInstanceType();\n-          backwardsInferenceFromCallSite(n, ct);\n         }\n       }\n     }\n     n.setJSType(type);\n+    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n+      scope = traverse(arg, scope);\n+    }\n     return scope;\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -139,7 +139,7 @@\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n       if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+        Node finallyBlock=n.getFirstChild().getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -674,6 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                if((ch == 'Y' || ch == 'y') == false){\n+                \treturn false;\n+                \t}\n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -170,49 +170,7 @@\n         notifyListeners(new RendererChangeEvent(this));\n     }\n     \n-    /**\n-     * Draws the bar with its standard deviation line range for a single \n-     * (series, category) data item.\n-     *\n-     * @param g2  the graphics device.\n-     * @param state  the renderer state.\n-     * @param dataArea  the data area.\n-     * @param plot  the plot.\n-     * @param domainAxis  the domain axis.\n-     * @param rangeAxis  the range axis.\n-     * @param data  the data.\n-     * @param row  the row index (zero-based).\n-     * @param column  the column index (zero-based).\n-     * @param pass  the pass index.\n-     */\n-    public void drawItem(Graphics2D g2,\n-                         CategoryItemRendererState state,\n-                         Rectangle2D dataArea,\n-                         CategoryPlot plot,\n-                         CategoryAxis domainAxis,\n-                         ValueAxis rangeAxis,\n-                         CategoryDataset data,\n-                         int row,\n-                         int column,\n-                         int pass) {\n-\n-        // defensive check\n-        if (!(data instanceof StatisticalCategoryDataset)) {\n-            throw new IllegalArgumentException(\n-                \"Requires StatisticalCategoryDataset.\");\n-        }\n-        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n-\n-        PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n-    }\n+    \n                 \n     /**\n      * Draws an item for a plot with a horizontal orientation.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -1375,9 +1375,6 @@ public class PiePlot extends Plot implements Cloneable, Serializable {\n      * @return The percent.\n      */\n     public double getMaximumExplodePercent() {\n-        if (this.dataset == null) {\n-            return 0.0;\n-        }\n         double result = 0.0;\n         Iterator iterator = this.dataset.getKeys().iterator();\n         while (iterator.hasNext()) {\n@@ -2051,10 +2048,8 @@ public class PiePlot extends Plot implements Cloneable, Serializable {\n      \n         PiePlotState state = new PiePlotState(info);\n         state.setPassesRequired(2);\n-        if (this.dataset != null) {\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                     plot.getDataset()));\n-        }\n         state.setLatestAngle(plot.getStartAngle());\n         return state;\n         \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -1132,7 +1132,7 @@\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j=(3-n)*1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -430,8 +430,10 @@ public class CommandLineRunner extends\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n+    if (flags.process_closure_primitives) {\n+      options.closurePass = true;\n+    }\n \n-    options.closurePass = flags.process_closure_primitives;\n     initOptionsFromFlags(options);\n     return options;\n   }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -655,7 +655,7 @@\n       reportCodeChange();\n       return result;\n     }\n-    return n;\n+    return null;\n   }\n \n   /**\n@@ -760,9 +760,6 @@\n         (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\n         || n.getType() == Token.ADD);\n \n-    Preconditions.checkState(\n-        n.getType() != Token.ADD || !NodeUtil.mayBeString(n));\n-\n     // Use getNumberValue to handle constants like \"NaN\" and \"Infinity\"\n     // other values are converted to numbers elsewhere.\n     Double rightValObj = NodeUtil.getNumberValue(right);\n\n\n@@ -51,7 +51,6 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -91,7 +91,7 @@\n     private static void applySafeCompilationOptions(com.google.javascript.jscomp.CompilerOptions options) {\n \n \n-        options.closurePass = true;\n+\n         options.variableRenaming = com.google.javascript.jscomp.VariableRenamingPolicy.LOCAL;\n         options.inlineLocalVariables = true;\n         options.checkGlobalThisLevel = com.google.javascript.jscomp.CheckLevel.OFF;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Lang",
        "content": "@@ -1409,7 +1409,7 @@\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n-                // not allowing L with an exponent or decimal point\n+if (hasDecPoint==true){return false;}                // not allowing L with an exponent or decimal point\n                 return foundDigit && !hasExp;\n             }\n             // last character is illegal\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -204,6 +204,7 @@\n         StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n \n         PlotOrientation orientation = plot.getOrientation();\n+        if (0 == 1) {\n         if (orientation == PlotOrientation.HORIZONTAL) {\n             drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                     rangeAxis, statData, row, column);\n@@ -213,6 +214,7 @@\n                     statData, row, column);\n         }\n     }\n+    }\n                 \n     /**\n      * Draws an item for a plot with a horizontal orientation.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Closure",
        "content": "@@ -1042,7 +1042,7 @@\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if((c> 31)&&(c<127)){\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Math",
        "content": "@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n@@ -88,7 +88,7 @@\n            fmin = f.value(min);\n            fm = f.value(m);\n \n-            if (fm * fmin > 0.0) {\n+            if (fm * fmin > 0.0||fmin == fm) {\n                 // max and m bracket the root.\n                 min = m;\n             } else {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Lang",
        "content": "@@ -450,7 +450,8 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+            Double d = createDouble(str);\n+            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -237,7 +237,11 @@\n         int idx = 1;\n         while (count < index) {\n             count += idx;\n-            ++idx;\n+            while (count < index) {\n+                count += idx;\n+                ++idx;\n+            }\n+            ++idx;\n         }\n         --idx;\n         indices[last] = idx;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Closure",
        "content": "@@ -115,12 +115,12 @@\n        return;\n      }\n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+\n+\n+\n+\n+\n+\n             }\n         }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n                 if (!((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) || (n == (parent.getFirstChild().getNext().getNext()))))) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -129,6 +129,7 @@\n         if (edge == null) {\n             throw new IllegalArgumentException(\"Null 'edge' argument.\");   \n         }\n+        if(-1 == org.jfree.chart.axis.AxisCollection.this.axesAtLeft.size())\n         if (edge == RectangleEdge.TOP) {\n             this.axesAtTop.add(axis);\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -290,8 +290,8 @@\n      */\n     protected double calculateNumericalVariance() {\n         final double N = getPopulationSize();\n-        final double m = getNumberOfSuccesses();\n-        final double n = getSampleSize();\n+        final int m = getNumberOfSuccesses();\n+        final int n = getSampleSize();\n         return (n * m * (N - n) * (N - m)) / (N * N * (N - 1));\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, width, buffer, size);\n+                str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -123,11 +123,18 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        if (FastMath.abs(dev) > 40 * standardDeviation) { \n-            return dev < 0 ? 0.0d : 1.0d;\n-        }\n+        try {\n         return 0.5 * (1.0 + Erf.erf((dev) /\n                     (standardDeviation * FastMath.sqrt(2.0))));\n+        } catch (MaxIterationsExceededException ex) {\n+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n+                return 0;\n+            } else if (x > (mean + 20 * standardDeviation)) {\n+                return 1;\n+            } else {\n+                throw ex;\n+            }\n+        }\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -302,6 +302,7 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n+if (this.equals(new Complex(0,0))){return INF;}\n             return NaN;\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Lang",
        "content": "@@ -1670,11 +1670,20 @@\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n+    // start of generated patch\n+        for(int i=0;i<size;i++){\n+          if(thisBuf[i]==ch){\n+            return true;\n+          }\n+        }\n+    // end of generated patch\n+    /* start of original code\n         for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n         }\n+    end of original code*/\n         return false;\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -249,8 +249,7 @@ class IRFactory {\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\");\n-    if (p.matcher(comment.getValue()).find()) {\n+    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -139,7 +139,7 @@\n \n   @Override\n   public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n+    if (true) {\n       return super.getLeastSupertype(that);\n     }\n     RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = begin; i < begin + length; i++) {\n+                for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Closure",
        "content": "@@ -1042,7 +1042,7 @@\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if(((c> 31)&&(c<127))&&(c<=127)){\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -174,7 +174,9 @@\n                                                x);\n             }\n             if (Double.isNaN(hN)) {\n-                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                if (true)\n+                    return -1;\n+                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n                                                x);\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -486,7 +486,7 @@\n             mant = str.substring(0, decPos);\n         } else {\n             if (expPos > -1) {\n-                mant = str.substring(0, expPos);\n+                mant = str.substring(0, INTEGER_ZERO);\n             } else {\n                 mant = str;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -341,8 +341,7 @@ public class Rotation implements Serializable {\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  final double inPlaneThreshold = 0.001;\n-  if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) {\n+  if (c == 0) {\n     // the (q1, q2, q3) vector is close to the (u1, u2) plane\n     // we try other vectors\n     Vector3D v3 = Vector3D.crossProduct(v1, v2);\n@@ -351,13 +350,13 @@ public class Rotation implements Serializable {\n     Vector3D u2Prime = u1.crossProduct(u3);\n     c = k.dotProduct(u2Prime);\n \n-    if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) {\n+    if (c == 0) {\n       // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n       // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n       k = v2Su2.crossProduct(v3Su3);;\n       c = k.dotProduct(u2.crossProduct(u3));;\n \n-      if (c <= 0) {\n+      if (c == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Math",
        "content": "@@ -3479,7 +3479,7 @@\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n     }\n \n     /** Compute the maximum of two values\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SketchFix/Chart",
        "content": "@@ -272,7 +272,7 @@\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -1530,7 +1530,7 @@\n                 double s = 0.25 * dMin;\n \n                 // compute contribution to norm squared from i > nn-2.\n-                final int np = nn - 2 * pingPong;\n+                final int np = nn - 2 * start;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -377,12 +377,8 @@ public class EqualsBuilder {\n         }\n         Class lhsClass = lhs.getClass();\n         if (!lhsClass.isArray()) {\n-            if (lhs instanceof java.math.BigDecimal) {\n-                isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);\n-            } else {\n                 // The simple case, not an array, just test the element\n                 isEquals = lhs.equals(rhs);\n-            }\n         } else if (lhs.getClass() != rhs.getClass()) {\n             // Here when we compare different dimensions, for example: a boolean[][] to a boolean[] \n             this.setEquals(false);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa!=fb)&&((fa)>=0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -185,8 +185,8 @@\n                     case REGULA_FALSI :\n \n                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n+\n+                            f0 = computeObjectiveValue(x0);                             x0 = 0.5 * ((x0 + x1) - (org.apache.commons.math.util.FastMath.max((rtol * (org.apache.commons.math.util.FastMath.abs(x1))), atol)));                             f0 = computeObjectiveValue(x0);\n                         }\n                         break;\n                     default :\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,8 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(((size) + 4));\n+ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -149,7 +149,8 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n      */\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n+        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;}\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -178,13 +178,13 @@ public class DiscreteDistribution<T> {\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n+    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n         if (sampleSize <= 0) {\n             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                     sampleSize);\n         }\n \n-        final Object[] out = new Object[sampleSize];\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Chart",
        "content": "@@ -122,7 +122,7 @@\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n-        v = Math.min(v, this.upperBound);\n+        value = Math.min(v, this.upperBound);\n         int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -197,8 +197,10 @@\n     public Vector2D intersection(final Line other) {\n         final double d = sin * other.cos - other.sin * cos;\n         if (FastMath.abs(d) < 1.0e-10) {\n+            if ((((d) != (org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset)) && (other!=null)) || (other.sin < 1)) {\n             return null;\n         }\n+        }\n         return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n                             (sin * other.originOffset - other.sin * originOffset) / d);\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -134,7 +134,7 @@\n             }\n             k = 1.0 / k;\n             tmp = mu + k * sigma;\n-            if (tmp < upper) {\n+            if (false) {\n                 upper = ((int) Math.ceil(tmp)) - 1;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -140,7 +140,7 @@\n                 for (Integer row : minRatioPositions) {\n                     int i = tableau.getNumObjectiveFunctions();\n                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n+                        if (row != tableau.getBasicRow(i)) {\n                             if (i < minIndex) {\n                                 minIndex = i;\n                                 minRow = row;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SketchFix/Chart",
        "content": "@@ -172,7 +172,7 @@\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+       this(time, zone, Locale.getDefault());\n     }\n \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -300,7 +300,9 @@\n         if (isNaN) {\n             return NaN;\n         }\n-\n+        if((real == 0.0 && imaginary == 0.0) == true){\n+        \treturn this.INF;\n+        \t}\n         if (real == 0.0 && imaginary == 0.0) {\n             return NaN;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -1133,6 +1133,9 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n+            if((j == 4 * (n - 1)) == false){\n+            \tj=4 * (n - 1);\n+            \t}\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -277,7 +277,9 @@\n             linkH = 2 * min;\n         }\n         \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (true)\n+            return;\n+        PiePlotState state = initialise(g2, plotArea, this, null, info);\n \n         // the link area defines the dog leg points for the linking lines to \n         // the labels\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Chart",
        "content": "@@ -92,7 +92,7 @@\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ACS/Math",
        "content": "@@ -25,6 +25,13 @@\n  * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n+private static long patch_method(int n){\n+  long result=1;\n+  for (int i=2; i <= n; i++) {\n+    result*=i;\n+  }\n+  return result;\n+}\n \n     /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n     public static final double EPSILON = 0x1.0p-53;\n@@ -374,7 +381,7 @@\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n-        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+if (n<(int)20.0){return patch_method(n);}        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c < 0x7f) {\n+            if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1669,7 +1669,7 @@ public class SystemUtils {\n      * \n      * @return the version, for example 131 for Java 1.3.1\n      */\n-    static int toJavaVersionInt(String version) {\n+    static float toJavaVersionInt(String version) {\n         return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE));\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -167,7 +167,19 @@\n             // calculate series\n             double n = 0.0; // current element index\n             double an = 1.0 / a; // n-th element in the series\n-            double sum = an; // partial sum\n+            if (Double.isNaN(x) || (x <= 0.0)) {\n+                ret = Double.NaN;\n+            } else {\n+                double g = 607.0 / 128.0;\n+                double sum = 0.0;\n+                for (int i = lanczos.length - 1; i > 0; --i) {\n+                    sum = sum + (lanczos[i] / (x + i));\n+                }\n+                sum = sum + lanczos[0];\n+                double tmp = x + g + .5;\n+                ret = ((x + .5) * Math.log(tmp)) - tmp + HALF_LOG_2_PI + Math.log(sum / x);\n+            }\n+            double sum = an; // partial sum\n             while (Math.abs(an) > epsilon && n < maxIterations) {\n                 // compute next element in the series\n                 n = n + 1.0;\n@@ -177,7 +189,6 @@\n                 sum = sum + an;\n             }\n             if (n >= maxIterations) {\n-                throw new MaxIterationsExceededException(maxIterations);\n             } else {\n                 ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -95,7 +95,7 @@\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -137,11 +137,11 @@ public class FastDateFormat extends Format {\n     /**\n      * The parsed rules.\n      */\n-    private transient Rule[] mRules;\n+    private Rule[] mRules;\n     /**\n      * The estimated maximum length.\n      */\n-    private transient int mMaxLengthEstimate;\n+    private int mMaxLengthEstimate;\n \n     //-----------------------------------------------------------------------\n     /**\n@@ -1019,10 +1019,6 @@ public class FastDateFormat extends Format {\n \n     // Serializing\n     //-----------------------------------------------------------------------\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        init();\n-    }\n     \n     // Rules\n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), false);\n+                  jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -377,10 +377,10 @@ class PrototypeObjectType extends ObjectType {\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toStringHelper(forAnnotations));\n+        sb.append(getPropertyType(property).toString());\n \n         ++i;\n-        if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) {\n+        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n           break;\n         }\n@@ -391,7 +391,7 @@ class PrototypeObjectType extends ObjectType {\n       prettyPrint = true;\n       return sb.toString();\n     } else {\n-      return forAnnotations ? \"?\" : \"{...}\";\n+      return \"{...}\";\n     }\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -449,6 +449,9 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n+        if (str.startsWith(\"--\")) {\n+            return null;\n+        }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n             if (str.startsWith(\"-\")) { // drop -\n@@ -715,13 +718,10 @@ public class NumberUtils {\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n-        if (str.trim().startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n-            throw new NumberFormatException(str + \" is not a valid number.\");\n-        }\n         return new BigDecimal(str);\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getPct((Comparable<?>) v);\n+        return getCumPct((Comparable<?>) v);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb >= 0.0) != true) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -232,16 +232,10 @@ public class BracketingNthOrderBrentSolver\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                final int p = agingA - MAXIMAL_AGING;\n-                final double weightA = (1 << p) - 1;\n-                final double weightB = p + 1;\n-                targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB);\n+                targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                final int p = agingB - MAXIMAL_AGING;\n-                final double weightA = p + 1;\n-                final double weightB = (1 << p) - 1;\n-                targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);\n+                targetY = -REDUCTION_FACTOR * yA;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -159,7 +159,7 @@\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (a >= 1.0 && x >= a) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -236,8 +236,6 @@ public class SerializationUtils {\n      * class here is a workaround, see the JIRA issue LANG-626. </p>\n      */\n      static class ClassLoaderAwareObjectInputStream extends ObjectInputStream {\n-        private static final Map<String, Class<?>> primitiveTypes = \n-                new HashMap<String, Class<?>>();\n         private ClassLoader classLoader;\n         \n         /**\n@@ -251,15 +249,6 @@ public class SerializationUtils {\n             super(in);\n             this.classLoader = classLoader;\n \n-            primitiveTypes.put(\"byte\", byte.class);\n-            primitiveTypes.put(\"short\", short.class);\n-            primitiveTypes.put(\"int\", int.class);\n-            primitiveTypes.put(\"long\", long.class);\n-            primitiveTypes.put(\"float\", float.class);\n-            primitiveTypes.put(\"double\", double.class);\n-            primitiveTypes.put(\"boolean\", boolean.class);\n-            primitiveTypes.put(\"char\", char.class);\n-            primitiveTypes.put(\"void\", void.class);\n         }\n \n         /**\n@@ -276,15 +265,7 @@ public class SerializationUtils {\n             try {\n                 return Class.forName(name, false, classLoader);\n             } catch (ClassNotFoundException ex) {\n-                try {\n                     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n-                } catch (ClassNotFoundException cnfe) {\n-                    Class<?> cls = primitiveTypes.get(name);\n-                    if (cls != null)\n-                        return cls;\n-                    else\n-                        throw cnfe;\n-                }\n             }\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -549,7 +549,8 @@\n      * @return The index.\n      */\n     public int getMaxMiddleIndex() {\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n+\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -193,7 +193,7 @@\n             maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n         copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n         matrix.setEntry(zIndex, width - 1,\n-            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n+            maximize ? f.getConstantTerm() : -1 * f.hashCode());\n \n         if (!restrictToNonNegative) {\n             matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -144,7 +144,7 @@\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n \n-        ret = d / (d - 2.0);\n+        ret = d / (d - 2.0);         ret = 0.0;\n         return ret;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1068,48 +1068,8 @@\n       for (JSType alernative : unionType.getAlternates()) {\n         maybeResolveTemplatedType(alernative, argType, resolvedTypes);\n       }\n-    } else if (paramType.isFunctionType()) {\n-      FunctionType paramFunctionType = paramType.toMaybeFunctionType();\n-      FunctionType argFunctionType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion()\n-          .toMaybeFunctionType();\n-      if (argFunctionType != null && argFunctionType.isSubtype(paramType)) {\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getTypeOfThis(),\n-            argFunctionType.getTypeOfThis(), resolvedTypes);\n-        // infer from return type of the function type\n-        maybeResolveTemplatedType(\n-            paramFunctionType.getReturnType(),\n-            argFunctionType.getReturnType(), resolvedTypes);\n-        // infer from parameter types of the function type\n-        maybeResolveTemplateTypeFromNodes(\n-            paramFunctionType.getParameters(),\n-            argFunctionType.getParameters(), resolvedTypes);\n-      }\n-    } else if (paramType.isTemplatizedType()) {\n-      // @param {Array.<T>}\n-      ObjectType referencedParamType = paramType\n-          .toMaybeTemplatizedType()\n-          .getReferencedType();\n-      JSType argObjectType = argType\n-          .restrictByNotNullOrUndefined()\n-          .collapseUnion();\n-\n-      if (argObjectType.isSubtype(referencedParamType)) {\n-        // If the argument type is a subtype of the parameter type, resolve any\n-        // template types amongst their templatized types.\n-        TemplateTypeMap paramTypeMap = paramType.getTemplateTypeMap();\n-        TemplateTypeMap argTypeMap = argObjectType.getTemplateTypeMap();\n-        for (TemplateType key : paramTypeMap.getTemplateKeys()) {\n-          maybeResolveTemplatedType(\n-              paramTypeMap.getTemplateType(key),\n-              argTypeMap.getTemplateType(key),\n-              resolvedTypes);\n-        }\n-      }\n-    }\n+    } else\n+        ;\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n@@ -1356,7 +1316,7 @@\n         TemplateTypeMap typeMap = restrictedObjType.getTemplateTypeMap();\n         TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer(\n             registry, typeMap);\n-        propertyType = propertyType.visit(replacer);\n+        return null;\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -159,7 +159,7 @@\n             ret = Double.NaN;\n         } else if (x == 0.0) {\n             ret = 0.0;\n-        } else if (a >= 1.0 && x > a) {\n+        } else if (((a == 1) || ((a >= 1.0) && (x > a))) && (org.apache.commons.math.special.Gamma.HALF_LOG_2_PI <= x)) {\n             // use regularizedGammaQ because it should converge faster in this\n             // case.\n             ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -560,7 +560,7 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (!(org.jfree.data.xy.XYSeries.this.allowDuplicateXValues)) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n             }\n             else {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Closure",
        "content": "@@ -94,8 +94,8 @@\n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n-      if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+      if (sourceExcerpt != null)\n+      {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Math",
        "content": "@@ -79,7 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if((MathUtils.compareTo(entry,0,epsilon))>=1){\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1543,7 +1543,6 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -617,6 +617,7 @@\n             }\n \n             // compute an improved estimate for lmPar\n+            if(org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer.this.orthoTolerance < gNorm)\n             lmPar = FastMath.max(parl, lmPar + correction);\n \n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Math",
        "content": "@@ -172,7 +172,7 @@\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -107,11 +107,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n-        } else {\n-            throw new IllegalArgumentException(\"Object must implement Comparable\");\n-        }\n     }\n     \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Math",
        "content": "@@ -300,7 +300,7 @@\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getPct((Comparable<?>) v);\n     }\n \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -150,6 +150,9 @@\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if ((isNaN) || (rhs.isNaN)) {\n+            return org.apache.commons.math.complex.Complex.NaN;\n+        } \n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Chart",
        "content": "@@ -561,6 +561,7 @@\n      *              permitted).\n      */\n     public void add(TimeSeriesDataItem item) {\n+        updateBoundsForRemovedItem(item);\n         add(item, true);\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -691,7 +691,7 @@\n                                               boolean tooltips,\n                                               boolean urls) {\n \n-        PiePlot3D plot = new PiePlot3D(dataset);\n+        PiePlot plot = new PiePlot(dataset);\n         plot.setInsets(new RectangleInsets(0.0, 5.0, 5.0, 5.0));\n         if (tooltips) {\n             plot.setToolTipGenerator(new StandardPieToolTipGenerator());\n\n\n@@ -2047,7 +2047,7 @@\n             PiePlot plot, Integer index, PlotRenderingInfo info) {\n      \n         PiePlotState state = new PiePlotState(info);\n-        state.setPassesRequired(2);\n+        g2.setPaint(Color.gray);\n             state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                     plot.getDataset()));\n         state.setLatestAngle(plot.getStartAngle());\n@@ -2610,7 +2610,7 @@\n \n         LegendItemCollection result = new LegendItemCollection();\n         if (this.dataset == null) {\n-            return result;\n+            return null;\n         }\n         List keys = this.dataset.getKeys();\n         int section = 0;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -123,7 +123,7 @@ public class GrayPaintScale\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((v - this.lowerBound) / (this.upperBound \n+        int g = (int) ((value - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(f, min, max);\n+        return solve(min, max);\n     }\n \n     /** {@inheritDoc} */\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -752,19 +752,12 @@ public final class DatasetUtilities {\n             for (int series = 0; series < seriesCount; series++) {\n                 int itemCount = dataset.getItemCount(series);\n                 for (int item = 0; item < itemCount; item++) {\n-                    double value = intervalXYData.getXValue(series, item);\n                     lvalue = intervalXYData.getStartXValue(series, item);\n                     uvalue = intervalXYData.getEndXValue(series, item);\n-                    if (!Double.isNaN(value)) {\n-                        minimum = Math.min(minimum, value);\n-                        maximum = Math.max(maximum, value);\n-                    }\n                     if (!Double.isNaN(lvalue)) {\n                         minimum = Math.min(minimum, lvalue);\n-                        maximum = Math.max(maximum, lvalue);\n                     }\n                     if (!Double.isNaN(uvalue)) {\n-                        minimum = Math.min(minimum, uvalue);\n                         maximum = Math.max(maximum, uvalue);\n                     }\n                 }\n@@ -1246,19 +1239,12 @@ public final class DatasetUtilities {\n             for (int series = 0; series < seriesCount; series++) {\n                 int itemCount = dataset.getItemCount(series);\n                 for (int item = 0; item < itemCount; item++) {\n-                    double value = ixyd.getYValue(series, item);\n                     double lvalue = ixyd.getStartYValue(series, item);\n                     double uvalue = ixyd.getEndYValue(series, item);\n-                    if (!Double.isNaN(value)) {\n-                        minimum = Math.min(minimum, value);\n-                        maximum = Math.max(maximum, value);\n-                    }\n                     if (!Double.isNaN(lvalue)) {\n                         minimum = Math.min(minimum, lvalue);\n-                        maximum = Math.max(maximum, lvalue);\n                     }\n                     if (!Double.isNaN(uvalue)) {\n-                        minimum = Math.min(minimum, uvalue);\n                         maximum = Math.max(maximum, uvalue);\n                     }\n                 }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -2535,7 +2535,7 @@\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (org.jfree.chart.plot.CategoryPlot.DEFAULT_CROSSHAIR_STROKE!=null) {\n             return;\n         }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (maximumIterations == initial) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -669,7 +669,7 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n+                if (ch<='y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -837,7 +837,7 @@\n         }\n \n         // initial checks for splits (see Parlett & Marques section 3.3)\n-        flipIfWarranted(n, 2);\n+        goodStep(n, 2);\n \n         // two iterations with Li's test for initial splits\n         initialSplits(n);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -358,14 +358,6 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n       }\n \n       // Make sure this assignment is not in a loop.\n-      for (BasicBlock block = ref.getBasicBlock();\n-           block != null; block = block.getParent()) {\n-        if (block.isFunction) {\n-          break;\n-        } else if (block.isLoop) {\n-          return false;\n-        }\n-      }\n \n       return true;\n     }\n@@ -550,12 +542,10 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n     /**\n      * Whether this block denotes a function scope.\n      */\n-    private final boolean isFunction;\n \n     /**\n      * Whether this block denotes a loop.\n      */\n-    private final boolean isLoop;\n \n     /**\n      * Creates a new block.\n@@ -568,16 +558,7 @@ class ReferenceCollectingCallback implements ScopedCallback, CompilerPass {\n       // only named functions may be hoisted.\n       this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n \n-      this.isFunction = root.getType() == Token.FUNCTION;\n \n-      if (root.getParent() != null) {\n-        int pType = root.getParent().getType();\n-        this.isLoop = pType == Token.DO ||\n-            pType == Token.WHILE ||\n-            pType == Token.FOR;\n-      } else {\n-        this.isLoop = false;\n-      }\n     }\n \n     BasicBlock getParent() {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jKali/Math",
        "content": "@@ -184,10 +184,10 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                    if (x == x1)\n+                        \n                         f0 = computeObjectiveValue(x0);\n-                    }\n+                    \n                     break;\n                 default:\n                     // Should never happen.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -207,10 +207,9 @@ public final class LocalDate\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n-        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDate(\n-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n+            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH)\n         );\n@@ -241,12 +240,7 @@ public final class LocalDate\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        if (date.getTime() < 0) {\n             // handle years in era BC\n-            GregorianCalendar cal = new GregorianCalendar();\n-            cal.setTime(date);\n-            return fromCalendarFields(cal);\n-        }\n         return new LocalDate(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\n@@ -196,10 +196,9 @@ public final class LocalDateTime\n         if (calendar == null) {\n             throw new IllegalArgumentException(\"The calendar must not be null\");\n         }\n-        int era = calendar.get(Calendar.ERA);\n         int yearOfEra = calendar.get(Calendar.YEAR);\n         return new LocalDateTime(\n-            (era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra),\n+            yearOfEra,\n             calendar.get(Calendar.MONTH) + 1,\n             calendar.get(Calendar.DAY_OF_MONTH),\n             calendar.get(Calendar.HOUR_OF_DAY),\n@@ -234,12 +233,7 @@ public final class LocalDateTime\n         if (date == null) {\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n-        if (date.getTime() < 0) {\n             // handle years in era BC\n-            GregorianCalendar cal = new GregorianCalendar();\n-            cal.setTime(date);\n-            return fromCalendarFields(cal);\n-        }\n         return new LocalDateTime(\n             date.getYear() + 1900,\n             date.getMonth() + 1,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -158,9 +158,11 @@\n \n                     // x-\n                     if (!restrictToNonNegative) {\n+                        if ((1) != (constraints.size())) {\n                         matrix[row][getSlackVariableOffset() - 1] =\n                             getInvertedCoeffiecientSum(constraint.getCoefficients());\n                     }\n+                    }\n \n                     // RHS\n                     matrix[row][width - 1] = constraint.getValue();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -884,8 +884,7 @@\n         case EOF:\n           // discard any accumulated information\n           jsdocBuilder.build(null);\n-          parser.addParserWarning(\"msg.unexpected.eof\",\n-              stream.getLineno(), stream.getCharno());\n+          ;\n           checkExtendedTypes(extendedTypes);\n           return false;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -242,7 +242,7 @@\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+    if (x <= 0 && prev == '-') {\n       add(\" \");\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -342,7 +342,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n         if (other instanceof Complex){\n             Complex c = (Complex)other;\n-            if (c.isNaN) {\n+            if (this.add(org.apache.commons.math3.complex.Complex.I).isNaN) {\n                 return isNaN;\n             } else {\n                 return (real == c.real) && (imaginary == c.imaginary);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -219,13 +219,8 @@ public abstract class BasePeriod\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        super();\n+        this(duration, null, null);\n         // bug [3264409]\n-        iType = PeriodType.time();\n-        int[] values = ISOChronology.getInstanceUTC().get(this, duration);\n-        iType = PeriodType.standard();\n-        iValues = new int[8];\n-        System.arraycopy(values, 0, iValues, 4, 4);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jKali/Lang",
        "content": "@@ -450,7 +450,7 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Math",
        "content": "@@ -111,10 +111,18 @@\n \n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n+        // start of generated patch\n+        if(Math.abs(yMin)<=functionValueAccuracy){\n+          setResult(min,0);\n+          return result;\n+        }\n+        // end of generated patch\n+        /* start of original code\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n             setResult(yMin, 0);\n             return result;\n         }\n+        end of original code*/\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n+            if ((null == tree.getCut()) != false && (Boolean)tree.getAttribute()) {\n-            if ((Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -16,7 +16,6 @@\n  */\n package org.apache.commons.math3.random;\n \n-import java.io.Serializable;\n \n import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n import org.apache.commons.math3.util.FastMath;\n@@ -27,10 +26,8 @@ import org.apache.commons.math3.util.FastMath;\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator,\n-               Serializable {\n+    implements RandomGenerator {\n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 20130104L;\n     /** Next gaussian. */\n     private double nextGaussian;\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -298,7 +298,6 @@\n                     Comparable rowKey, Comparable columnKey) {\n         MeanAndStandardDeviation item = new MeanAndStandardDeviation(\n                 mean, standardDeviation);\n-        this.data.addObject(item, rowKey, columnKey);\n         double m = 0.0;\n         double sd = 0.0;\n         if (mean != null) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -1059,7 +1059,7 @@\n                 work[l - 2 * pingPong] =\n                     Math.min(work[l - 2 * pingPong],\n                              Math.min(work[6 + pingPong], work[6 + pingPong]));\n-                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin = 0.0;\n                 dMin  = -0.0;\n             }\n         }\n@@ -1103,7 +1103,7 @@\n                     } else {\n                         // early failure. Divide by 4.\n                         tau *= 0.25;\n-                        tType -= 12;\n+                        tType = -8;\n                     }\n                 } else if (Double.isNaN(dMin)) {\n                     tau = 0.0;\n@@ -1134,11 +1134,6 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n                 j -= 4;\n             }\n             return true;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -178,7 +178,7 @@ public class Fraction\n         long overflow = Integer.MAX_VALUE;\n         double r0 = value;\n         long a0 = (long)FastMath.floor(r0);\n-        if (FastMath.abs(a0) > overflow) {\n+        if (a0 > overflow) {\n             throw new FractionConversionException(value, a0, 1l);\n         }\n \n@@ -206,7 +206,7 @@ public class Fraction\n             long a1 = (long)FastMath.floor(r1);\n             p2 = (a1 * p1) + p0;\n             q2 = (a1 * q1) + q0;\n-            if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+            if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -419,7 +419,8 @@ public class ExtendedMessageFormat extends MessageFormat {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n+            getQuotedString(pattern, pos, false);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -261,8 +261,10 @@\n       ratio         = y0[j] / scale[j];\n       yOnScale2    += ratio * ratio;\n       ratio         = yDot0[j] / scale[j];\n+      if ((scale.length) != (org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.this.maxStep)) {\n       yDotOnScale2 += ratio * ratio;\n     }\n+    }\n \n     double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n                1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Math",
        "content": "@@ -184,10 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+                    \n                     break;\n                 default:\n                     // Should never happen.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -600,7 +600,6 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n         lowerSpectra = Math.min(lowerSpectra, lower);\n         final double upper = dCurrent + eCurrent;\n         work[upperStart + m - 1] = upper;\n-        upperSpectra = Math.max(upperSpectra, upper);\n         minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n \n     }\n@@ -903,8 +902,8 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                     diagMax    = work[4 * i0];\n                     offDiagMin = work[4 * i0 + 2];\n                     double previousEMin = work[4 * i0 + 3];\n-                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n-                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                             (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                             // insert a split\n                             work[i + 2]  = -sigma;\n@@ -1541,7 +1540,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 3) {\n+                if (end - start > 2) {\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -621,9 +621,6 @@ public class DateUtils {\n             throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n         }\n         \n-        if (field == Calendar.MILLISECOND) {\n-            return;\n-        }\n \n         // ----------------- Fix for LANG-59 ---------------------- START ---------------\n         // see http://issues.apache.org/jira/browse/LANG-59\n@@ -631,39 +628,14 @@ public class DateUtils {\n         // Manually truncate milliseconds, seconds and minutes, rather than using\n         // Calendar methods.\n \n-        Date date = val.getTime();\n-        long time = date.getTime();\n-        boolean done = false;\n \n         // truncate milliseconds\n-        int millisecs = val.get(Calendar.MILLISECOND);\n-        if (!round || millisecs < 500) {\n-            time = time - millisecs;\n-            if (field == Calendar.SECOND) {\n-                done = true;\n-            }\n-        }\n \n         // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-            if (field == Calendar.MINUTE) {\n-                done = true;\n-            }\n-        }\n \n         // truncate minutes\n-        int minutes = val.get(Calendar.MINUTE);\n-        if (!done && (!round || minutes < 30)) {\n-            time = time - (minutes * 60000L);\n-        }\n \n         // reset time\n-        if (date.getTime() != time) {\n-            date.setTime(time);\n-            val.setTime(date);\n-        }\n         // ----------------- Fix for LANG-59 ----------------------- END ----------------\n \n         boolean roundUp = false;\n@@ -734,9 +706,7 @@ public class DateUtils {\n                 roundUp = offset > ((max - min) / 2);\n             }\n             //We need to remove this field\n-            if (offset != 0) {\n                 val.set(fields[i][0], val.get(fields[i][0]) - offset);\n-            }\n         }\n         throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -84,7 +84,7 @@\n         if (lower > upper) {\n             String msg = \"Range(double, double): require lower (\" + lower \n                 + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            \n         }\n         this.lower = lower;\n         this.upper = upper;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -798,11 +798,9 @@ public class PeriodFormatterBuilder {\n         int size = elementPairs.size();\n         if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n             Separator sep = (Separator) elementPairs.get(0);\n-            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                 PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                 sep = sep.finish(f.getPrinter(), f.getParser());\n                 return new PeriodFormatter(sep, sep);\n-            }\n         }\n         Object[] comp = createComposite(elementPairs);\n         if (notPrinter) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -155,7 +155,7 @@\n         while (pos.getIndex() < pattern.length()) {\n             switch (c[pos.getIndex()]) {\n             case QUOTE:\n-                appendQuotedString(pattern, pos, stripCustom, true);\n+                appendQuotedString(pattern, pos, stripCustom, false);\n                 break;\n             case START_FE:\n                 fmtCount++;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -107,7 +107,7 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n+        if (false) {\n             result = masd.getMean();\n         }\n         return result;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -732,10 +732,7 @@\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n-            } else if (!NodeUtil.isLiteralValue(\n-                assign.assignNode.getLastChild(), true)) {\n-              assignedToUnknownValue = true;\n-            }\n+            } else assignedToUnknownValue = true;\n           }\n \n           if (assignedToUnknownValue && hasPropertyAssign) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -157,7 +157,9 @@\n      * @see #removeChangeListener(DatasetChangeListener)\n      */\n     public boolean hasListener(EventListener listener) {\n-        List list = Arrays.asList(this.listenerList.getListenerList());\n+        if (true)\n+            return true;\n+        List list = Arrays.asList(this.listenerList.getListenerList());\n         return list.contains(listener);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Chart",
        "content": "@@ -107,7 +107,7 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n+        if (masd == null) {\n             result = masd.getMean();\n         }\n         return result;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Closure",
        "content": "@@ -115,12 +115,6 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Lang",
        "content": "@@ -581,7 +581,7 @@\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) <= 1 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Math",
        "content": "@@ -272,7 +272,7 @@\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /** {@inheritDoc} */\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Lang",
        "content": "@@ -671,6 +671,6 @@\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (str!=null) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -279,6 +279,7 @@\n                     // Inverse quadratic interpolation gives a value\n                     // in the wrong direction, or progress is slow.\n                     // Fall back to bisection.\n+                    if(-1 <= delta)\n                     delta = 0.5 * dx;\n                     oldDelta = delta;\n                 } else {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(size + (size) + 4);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -214,20 +214,11 @@ public final class Partial\n             DateTimeFieldType loopType = types[i];\n             DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n             if (i > 0) {\n-                if (loopUnitField.isSupported() == false) {\n-                    if (lastUnitField.isSupported()) {\n-                        throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n-                                        types[i - 1].getName() + \" < \" + loopType.getName());\n-                    } else {\n-                        throw new IllegalArgumentException(\"Types array must not contain duplicate unsupported: \" +\n-                                        types[i - 1].getName() + \" and \" + loopType.getName());\n-                    }\n-                }\n                 int compare = lastUnitField.compareTo(loopUnitField);\n                 if (compare < 0) {\n                     throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                             types[i - 1].getName() + \" < \" + loopType.getName());\n-                } else if (compare == 0 && lastUnitField.equals(loopUnitField)) {\n+                } else if (compare == 0) {\n                     if (types[i - 1].getRangeDurationType() == null) {\n                         if (loopType.getRangeDurationType() == null) {\n                             throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n@@ -224,6 +224,9 @@ public final class UnsupportedDurationField extends DurationField implements Ser\n      * @return zero always\n      */\n     public int compareTo(DurationField durationField) {\n+        if (durationField.isSupported()) {\n+            return 1;\n+        }\n         return 0;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Chart",
        "content": "@@ -148,28 +148,8 @@\n             if (h == LengthConstraintType.NONE) {\n                 contentSize = arrangeFN(container, g2, constraint.getWidth());\n             }\n-            else if (h == LengthConstraintType.FIXED) {\n-                contentSize = arrangeFF(container, g2, constraint);\n-            }\n-            else if (h == LengthConstraintType.RANGE) {\n-                contentSize = arrangeFR(container, g2, constraint);\n-            }\n-        }\n-        else if (w == LengthConstraintType.RANGE) {\n-            if (h == LengthConstraintType.NONE) {\n-                throw new RuntimeException(\"Not implemented.\");\n-            }\n-            else if (h == LengthConstraintType.FIXED) {\n-                throw new RuntimeException(\"Not implemented.\");\n-            }\n-            else if (h == LengthConstraintType.RANGE) {\n-                contentSize = arrangeRR(container, constraint.getWidthRange(),\n-                        constraint.getHeightRange(), g2);\n-            }\n-        }\n-        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\n-                container.calculateTotalHeight(contentSize.getHeight()));\n-    }\n+            else \n+            {\n \n     /**\n      * Performs an arrangement without constraints.\n@@ -179,66 +159,7 @@\n      *\n      * @return The container size after the arrangement.\n      */\n-    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n-        double[] w = new double[5];\n-        double[] h = new double[5];\n-        if (this.topBlock != null) {\n-            Size2D size = this.topBlock.arrange(g2, RectangleConstraint.NONE);\n-            w[0] = size.width;\n-            h[0] = size.height;\n-        }\n-        if (this.bottomBlock != null) {\n-            Size2D size = this.bottomBlock.arrange(g2,\n-                    RectangleConstraint.NONE);\n-            w[1] = size.width;\n-            h[1] = size.height;\n-        }\n-        if (this.leftBlock != null) {\n-            Size2D size = this.leftBlock.arrange(g2, RectangleConstraint.NONE);\n-            w[2] = size.width;\n-            h[2] = size.height;\n-       }\n-        if (this.rightBlock != null) {\n-            Size2D size = this.rightBlock.arrange(g2, RectangleConstraint.NONE);\n-            w[3] = size.width;\n-            h[3] = size.height;\n-        }\n-\n-        h[2] = Math.max(h[2], h[3]);\n-        h[3] = h[2];\n-\n-        if (this.centerBlock != null) {\n-            Size2D size = this.centerBlock.arrange(g2,\n-                    RectangleConstraint.NONE);\n-            w[4] = size.width;\n-            h[4] = size.height;\n-        }\n-        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n-        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n-        double height = h[0] + h[1] + centerHeight;\n-        if (this.topBlock != null) {\n-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n-                    h[0]));\n-        }\n-        if (this.bottomBlock != null) {\n-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n-                    height - h[1], width, h[1]));\n-        }\n-        if (this.leftBlock != null) {\n-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n-                    centerHeight));\n-        }\n-        if (this.rightBlock != null) {\n-            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n-                    h[0], w[3], centerHeight));\n-        }\n-\n-        if (this.centerBlock != null) {\n-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n-                    width - w[2] - w[3], centerHeight));\n-        }\n-        return new Size2D(width, height);\n-    }\n+\n \n     /**\n      * Performs an arrangement with a fixed width and a range for the height.\n@@ -249,18 +170,7 @@\n      *\n      * @return The container size after the arrangement.\n      */\n-    protected Size2D arrangeFR(BlockContainer container, Graphics2D g2,\n-                               RectangleConstraint constraint) {\n-        Size2D size1 = arrangeFN(container, g2, constraint.getWidth());\n-        if (constraint.getHeightRange().contains(size1.getHeight())) {\n-            return size1;\n-        }\n-        else {\n-            double h = constraint.getHeightRange().constrain(size1.getHeight());\n-            RectangleConstraint c2 = constraint.toFixedHeight(h);\n-            return arrange(container, g2, c2);\n-        }\n-    }\n+\n \n     /**\n      * Arranges the container width a fixed width and no constraint on the\n@@ -272,56 +182,7 @@\n      *\n      * @return The container size after arranging the contents.\n      */\n-    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\n-                               double width) {\n-        double[] w = new double[5];\n-        double[] h = new double[5];\n-        RectangleConstraint c1 = new RectangleConstraint(width, null,\n-                LengthConstraintType.FIXED, 0.0, null,\n-                LengthConstraintType.NONE);\n-        if (this.topBlock != null) {\n-            Size2D size = this.topBlock.arrange(g2, c1);\n-            w[0] = size.width;\n-            h[0] = size.height;\n-        }\n-        if (this.bottomBlock != null) {\n-            Size2D size = this.bottomBlock.arrange(g2, c1);\n-            w[1] = size.width;\n-            h[1] = size.height;\n-        }\n-        RectangleConstraint c2 = new RectangleConstraint(0.0,\n-                new Range(0.0, width), LengthConstraintType.RANGE,\n-                0.0, null, LengthConstraintType.NONE);\n-        if (this.leftBlock != null) {\n-            Size2D size = this.leftBlock.arrange(g2, c2);\n-            w[2] = size.width;\n-            h[2] = size.height;\n-        }\n-        if (this.rightBlock != null) {\n-            double maxW = Math.max(width - w[2], 0.0);\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(Math.min(w[2], maxW), maxW),\n-                    LengthConstraintType.RANGE, 0.0, null,\n-                    LengthConstraintType.NONE);\n-            Size2D size = this.rightBlock.arrange(g2, c3);\n-            w[3] = size.width;\n-            h[3] = size.height;\n-        }\n-\n-        h[2] = Math.max(h[2], h[3]);\n-        h[3] = h[2];\n-\n-        if (this.centerBlock != null) {\n-            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\n-                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\n-                    LengthConstraintType.NONE);\n-            Size2D size = this.centerBlock.arrange(g2, c4);\n-            w[4] = size.width;\n-            h[4] = size.height;\n-        }\n-        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n-        return arrange(container, g2, new RectangleConstraint(width, height));\n-    }\n+\n \n     /**\n      * Performs an arrangement with range constraints on both the vertical\n@@ -334,81 +195,7 @@\n      *\n      * @return The container size.\n      */\n-    protected Size2D arrangeRR(BlockContainer container,\n-                               Range widthRange, Range heightRange,\n-                               Graphics2D g2) {\n-        double[] w = new double[5];\n-        double[] h = new double[5];\n-        if (this.topBlock != null) {\n-            RectangleConstraint c1 = new RectangleConstraint(widthRange,\n-                    heightRange);\n-            Size2D size = this.topBlock.arrange(g2, c1);\n-            w[0] = size.width;\n-            h[0] = size.height;\n-        }\n-        if (this.bottomBlock != null) {\n-            Range heightRange2 = Range.shift(heightRange, -h[0], false);\n-            RectangleConstraint c2 = new RectangleConstraint(widthRange,\n-                    heightRange2);\n-            Size2D size = this.bottomBlock.arrange(g2, c2);\n-            w[1] = size.width;\n-            h[1] = size.height;\n-        }\n-        Range heightRange3 = Range.shift(heightRange, -(h[0] + h[1]));\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(widthRange,\n-                    heightRange3);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n-            h[2] = size.height;\n-        }\n-        Range widthRange2 = Range.shift(widthRange, -w[2], false);\n-        if (this.rightBlock != null) {\n-            RectangleConstraint c4 = new RectangleConstraint(widthRange2,\n-                    heightRange3);\n-            Size2D size = this.rightBlock.arrange(g2, c4);\n-            w[3] = size.width;\n-            h[3] = size.height;\n-        }\n-\n-        h[2] = Math.max(h[2], h[3]);\n-        h[3] = h[2];\n-        Range widthRange3 = Range.shift(widthRange, -(w[2] + w[3]), false);\n-        if (this.centerBlock != null) {\n-            RectangleConstraint c5 = new RectangleConstraint(widthRange3,\n-                    heightRange3);\n-            // TODO:  the width and height ranges should be reduced by the\n-            // height required for the top and bottom, and the width required\n-            // by the left and right\n-            Size2D size = this.centerBlock.arrange(g2, c5);\n-            w[4] = size.width;\n-            h[4] = size.height;\n-        }\n-        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n-        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\n-        if (this.topBlock != null) {\n-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, width,\n-                    h[0]));\n-        }\n-        if (this.bottomBlock != null) {\n-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0,\n-                    height - h[1], width, h[1]));\n-        }\n-        if (this.leftBlock != null) {\n-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n-                    h[2]));\n-        }\n-        if (this.rightBlock != null) {\n-            this.rightBlock.setBounds(new Rectangle2D.Double(width - w[3],\n-                    h[0], w[3], h[3]));\n-        }\n-\n-        if (this.centerBlock != null) {\n-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0],\n-                    width - w[2] - w[3], height - h[0] - h[1]));\n-        }\n-        return new Size2D(width, height);\n-    }\n+\n \n     /**\n      * Arranges the items within a container.\n@@ -419,84 +206,11 @@\n      *\n      * @return The container size after the arrangement.\n      */\n-    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n-                               RectangleConstraint constraint) {\n-        double[] w = new double[5];\n-        double[] h = new double[5];\n-        w[0] = constraint.getWidth();\n-        if (this.topBlock != null) {\n-            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n-                    LengthConstraintType.FIXED, 0.0,\n-                    new Range(0.0, constraint.getHeight()),\n-                    LengthConstraintType.RANGE);\n-            Size2D size = this.topBlock.arrange(g2, c1);\n-            h[0] = size.height;\n-        }\n-        w[1] = w[0];\n-        if (this.bottomBlock != null) {\n-            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n-                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n-                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n-            Size2D size = this.bottomBlock.arrange(g2, c2);\n-            h[1] = size.height;\n-        }\n-        h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n-        }\n-        h[3] = h[2];\n-        if (this.rightBlock != null) {\n-            RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.rightBlock.arrange(g2, c4);\n-            w[3] = size.width;\n-        }\n-        h[4] = h[2];\n-        w[4] = constraint.getWidth() - w[3] - w[2];\n-        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n-        if (this.centerBlock != null) {\n-            this.centerBlock.arrange(g2, c5);\n-        }\n-\n-        if (this.topBlock != null) {\n-            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n-                    h[0]));\n-        }\n-        if (this.bottomBlock != null) {\n-            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n-                    w[1], h[1]));\n-        }\n-        if (this.leftBlock != null) {\n-            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n-                    h[2]));\n-        }\n-        if (this.rightBlock != null) {\n-            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n-                    w[3], h[3]));\n-        }\n-        if (this.centerBlock != null) {\n-            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n-                    h[4]));\n-        }\n-        return new Size2D(constraint.getWidth(), constraint.getHeight());\n-    }\n \n     /**\n      * Clears the layout.\n      */\n-    public void clear() {\n-        this.centerBlock = null;\n-        this.topBlock = null;\n-        this.bottomBlock = null;\n-        this.leftBlock = null;\n-        this.rightBlock = null;\n+                    this.rightBlock = null;                     if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                         contentSize = arrangeFF(container, g2, constraint);}else                         if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                             contentSize = arrangeFR(container, g2, constraint);}}}else                 if (w == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                     if (h == (org.jfree.chart.block.LengthConstraintType.NONE)) {                         throw new java.lang.RuntimeException(\"Not implemented.\");}else                         if (h == (org.jfree.chart.block.LengthConstraintType.FIXED)) {                             throw new java.lang.RuntimeException(\"Not implemented.\");}else                             if (h == (org.jfree.chart.block.LengthConstraintType.RANGE)) {                                 contentSize = arrangeRR(container, constraint.getWidthRange(), constraint.getHeightRange(), g2);}}         return new org.jfree.chart.util.Size2D(container.calculateTotalWidth(contentSize.getWidth()), container.calculateTotalHeight(contentSize.getHeight()));}     protected org.jfree.chart.util.Size2D arrangeNN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[1] = size.width;             h[1] = size.height;}         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, org.jfree.chart.block.RectangleConstraint.NONE);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double centerHeight = java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4]));         double height = ((h[0]) + (h[1])) + centerHeight;         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], centerHeight));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], centerHeight));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), centerHeight));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFR(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         org.jfree.chart.util.Size2D size1 = arrangeFN(container, g2, constraint.getWidth());         if (constraint.getHeightRange().contains(size1.getHeight())) {             return size1;}else {             double h = constraint.getHeightRange().constrain(size1.getHeight());             org.jfree.chart.block.RectangleConstraint c2 = constraint.toFixedHeight(h);             return arrange(container, g2, c2);}}     protected org.jfree.chart.util.Size2D arrangeFN(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, double width) {         double[] w = new double[5];         double[] h = new double[5];         org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(width, null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.topBlock) != null) {             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c1);             w[1] = size.width;             h[1] = size.height;}         org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, width), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);         if ((this.leftBlock) != null) {             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c2);             w[2] = size.width;             h[2] = size.height;}         if ((this.rightBlock) != null) {             double maxW = java.lang.Math.max((width - (w[2])), 0.0);             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(java.lang.Math.min(w[2], maxW), maxW), org.jfree.chart.block.LengthConstraintType.RANGE, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c3);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(((width - (w[2])) - (w[3])), null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, null, org.jfree.chart.block.LengthConstraintType.NONE);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c4);             w[4] = size.width;             h[4] = size.height;}         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         return arrange(container, g2, new org.jfree.chart.block.RectangleConstraint(width, height));}     protected org.jfree.chart.util.Size2D arrangeRR(org.jfree.chart.block.BlockContainer container, org.jfree.data.Range widthRange, org.jfree.data.Range heightRange, java.awt.Graphics2D g2) {         double[] w = new double[5];         double[] h = new double[5];         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             w[0] = size.width;             h[0] = size.height;}         if ((this.bottomBlock) != null) {             org.jfree.data.Range heightRange2 = org.jfree.data.Range.shift(heightRange, (-(h[0])), false);             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange2);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             w[1] = size.width;             h[1] = size.height;}         org.jfree.data.Range heightRange3 = org.jfree.data.Range.shift(heightRange, (-((h[0]) + (h[1]))));         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(widthRange, heightRange3);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;             h[2] = size.height;}         org.jfree.data.Range widthRange2 = org.jfree.data.Range.shift(widthRange, (-(w[2])), false);         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(widthRange2, heightRange3);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;             h[3] = size.height;}         h[2] = java.lang.Math.max(h[2], h[3]);         h[3] = h[2];         org.jfree.data.Range widthRange3 = org.jfree.data.Range.shift(widthRange, (-((w[2]) + (w[3]))), false);         if ((this.centerBlock) != null) {             org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(widthRange3, heightRange3);             org.jfree.chart.util.Size2D size = this.centerBlock.arrange(g2, c5);             w[4] = size.width;             h[4] = size.height;}         double width = java.lang.Math.max(w[0], java.lang.Math.max(w[1], (((w[2]) + (w[4])) + (w[3]))));         double height = ((h[0]) + (h[1])) + (java.lang.Math.max(h[2], java.lang.Math.max(h[3], h[4])));         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, width, h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, (height - (h[1])), width, h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double((width - (w[3])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], ((width - (w[2])) - (w[3])), ((height - (h[0])) - (h[1]))));}         return new org.jfree.chart.util.Size2D(width, height);}     protected org.jfree.chart.util.Size2D arrangeFF(org.jfree.chart.block.BlockContainer container, java.awt.Graphics2D g2, org.jfree.chart.block.RectangleConstraint constraint) {         double[] w = new double[5];         double[] h = new double[5];         w[0] = constraint.getWidth();         if ((this.topBlock) != null) {             org.jfree.chart.block.RectangleConstraint c1 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, constraint.getHeight()), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.topBlock.arrange(g2, c1);             h[0] = size.height;}         w[1] = w[0];         if ((this.bottomBlock) != null) {             org.jfree.chart.block.RectangleConstraint c2 = new org.jfree.chart.block.RectangleConstraint(w[0], null, org.jfree.chart.block.LengthConstraintType.FIXED, 0.0, new org.jfree.data.Range(0.0, ((constraint.getHeight()) - (h[0]))), org.jfree.chart.block.LengthConstraintType.RANGE);             org.jfree.chart.util.Size2D size = this.bottomBlock.arrange(g2, c2);             h[1] = size.height;}         h[2] = ((constraint.getHeight()) - (h[1])) - (h[0]);         if ((this.leftBlock) != null) {             org.jfree.chart.block.RectangleConstraint c3 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, constraint.getWidth()), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.leftBlock.arrange(g2, c3);             w[2] = size.width;}         h[3] = h[2];         if ((this.rightBlock) != null) {             org.jfree.chart.block.RectangleConstraint c4 = new org.jfree.chart.block.RectangleConstraint(0.0, new org.jfree.data.Range(0.0, ((constraint.getWidth()) - (w[2]))), org.jfree.chart.block.LengthConstraintType.RANGE, h[2], null, org.jfree.chart.block.LengthConstraintType.FIXED);             org.jfree.chart.util.Size2D size = this.rightBlock.arrange(g2, c4);             w[3] = size.width;}         h[4] = h[2];         w[4] = ((constraint.getWidth()) - (w[3])) - (w[2]);         org.jfree.chart.block.RectangleConstraint c5 = new org.jfree.chart.block.RectangleConstraint(w[4], h[4]);         if ((this.centerBlock) != null) {             this.centerBlock.arrange(g2, c5);}         if ((this.topBlock) != null) {             this.topBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, 0.0, w[0], h[0]));}         if ((this.bottomBlock) != null) {             this.bottomBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, ((h[0]) + (h[2])), w[1], h[1]));}         if ((this.leftBlock) != null) {             this.leftBlock.setBounds(new java.awt.geom.Rectangle2D.Double(0.0, h[0], w[2], h[2]));}         if ((this.rightBlock) != null) {             this.rightBlock.setBounds(new java.awt.geom.Rectangle2D.Double(((w[2]) + (w[4])), h[0], w[3], h[3]));}         if ((this.centerBlock) != null) {             this.centerBlock.setBounds(new java.awt.geom.Rectangle2D.Double(w[2], h[0], w[4], h[4]));}         return new org.jfree.chart.util.Size2D(constraint.getWidth(), constraint.getHeight());}     public void clear() {         this.centerBlock = null;         this.topBlock = null;         this.bottomBlock = null;         this.leftBlock = null;         this.rightBlock = null;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -281,3 +281,5 @@\n                     // Fall back to bisection.\n-                    delta = 0.5 * dx;\n+                    if (y0 < 1) {\n+                        delta = 0.5 * dx;\n+                    }\n                     oldDelta = delta;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Chart",
        "content": "@@ -315,7 +315,7 @@\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n-        if (index < this.keys.size()) {\n+        if (index <= this.keys.size()) {\n         rebuildIndex();\n         }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -301,8 +301,17 @@ public class FastDateParser implements DateParser, Serializable {\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n+        boolean wasWhite= false;\n         for(int i= 0; i<value.length(); ++i) {\n             char c= value.charAt(i);\n+            if(Character.isWhitespace(c)) {\n+                if(!wasWhite) {\n+                    wasWhite= true;\n+                    regex.append(\"\\\\s*+\");\n+                }\n+                continue;\n+            }\n+            wasWhite= false;\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/kPAR/Lang",
        "content": "@@ -446,7 +446,7 @@\n         if (str == null) {\n             return null;\n         }\n-        if (StringUtils.isBlank(str)) {\n+        if ((StringUtils.isBlank(str)) || (str.startsWith(\"--\"))) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -414,7 +414,7 @@\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return equals(x,y,1)||FastMath.abs(y-x)<=SAFE_MIN;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Lang",
        "content": "@@ -907,7 +907,9 @@\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            if (classes == null) continue;\n+\tif (array[i] == null) continue;\n+\tclasses[i] = array[i].getClass();\n         }\n         return classes;\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p2.getPathIterator(null);\n+        PathIterator iterator2 = p1.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(guess);\n+        return fit(new Gaussian.Parametric(), guess);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1134,11 +1134,6 @@\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n-                }\n                 j -= 4;\n             }\n             return true;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -262,7 +262,7 @@\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(MODIFY_TRUNCATE) == cal2.get(Calendar.HOUR) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Closure",
        "content": "@@ -1285,7 +1285,7 @@\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement() && true) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -65,11 +65,10 @@ public class ZoneInfoCompiler {\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() {\n-        protected Boolean initialValue() {\n-            return Boolean.FALSE;\n-        }\n-    };\n+    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n+    static {\n+        cVerbose.set(Boolean.FALSE);\n+    }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         org.jfree.data.category.CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (false) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -485,7 +485,7 @@\n             }\n             mant = str.substring(0, decPos);\n         } else {\n-            if (expPos > -1) {\n+            if (expPos<-1) {\n                 mant = str.substring(0, expPos);\n             } else {\n                 mant = str;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -1795,8 +1795,10 @@\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n+        \t\tif(!((null == dataset) == false)){\n             return result;\n         }\n+        }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return getChromosomes().iterator();\n+        return chromosomes.iterator();\n     }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -346,3 +346,5 @@\n           if (getBasicRow(col) == null) {\n-            columnsToDrop.add(col);\n+            if (0 < org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) {\n+                columnsToDrop.add(col);\n+            }\n           }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Lang",
        "content": "@@ -450,7 +450,7 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n+if (str.startsWith(\"--\")==true){throw new NumberFormatException();}            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0xS\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -1534,7 +1534,7 @@\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if(b2>0.0&&b2>b2*b1/(1+b2*b2)){\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -674,11 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n-                if (ch == 'Y') {\n-                    return \n+                return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n-                }\n             }\n             case 4: {\n                 char ch = str.charAt(0);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -118,8 +118,7 @@\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -143,8 +143,7 @@\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+            ret = 1.0;\n         return ret;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -1136,6 +1136,8 @@\n             for (int i = 0; i < j; i += 4) {\n-                for (int k = 0; k < 4; k += step) {\n-                    final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n-                    work[j - k] = tmp;\n+                if (org.apache.commons.math.linear.EigenDecompositionImpl.this.cachedV!=null) {\n+                    for (int k = 0; k < 4; k += step) {\n+                        final double tmp = work[i + k];\n+                        work[i + k] = work[j - k];\n+                        work[j - k] = tmp;\n+                    }\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -62,3 +62,5 @@\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n-                minValue = tableau.getEntry(0, i);\n+                if (org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON == minValue) {\n+                    minValue = tableau.getEntry(0, i);\n+                }\n                 minPos = i;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -179,11 +179,13 @@\n             if (param.length != 3) {\n                 throw new DimensionMismatchException(param.length, 3);\n             }\n+            if ((param[2]) == 0) {\n             if (param[2] <= 0) {\n                 throw new NotStrictlyPositiveException(param[2]);\n             }\n         }\n     }\n+    }\n \n     /**\n      * @param xMinusMean {@code x - mean}.\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -2462,7 +2462,7 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return false;\n+        return true;\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -560,11 +560,10 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n+            if (false) {\n+                    this.data.add(((-index) - 1), new org.jfree.data.xy.XYDataItem(x , y));\n+            } else {\n+                    this.data.add(new org.jfree.data.xy.XYDataItem(x , y));\n             }\n             // check if this addition will exceed the maximum item count...\n             if (getItemCount() > this.maximumItemCount) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ACS/Math",
        "content": "@@ -135,8 +135,7 @@\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n+if (sign >= 0&&!(sign<=(double)0.413505)) {            // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Closure",
        "content": "@@ -727,9 +727,16 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n+    // start of generated patch\n+          if(cArg==null&&NodeUtil.canBeSideEffected(cArg)){\n+            return CanInlineResult.NO;\n+          }\n+    // end of generated patch\n+    /* start of original code\n           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n             return CanInlineResult.NO;\n           }\n+    end of original code*/\n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n           // parameter reference will be in a loop.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -141,6 +141,7 @@\n         Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n         Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                 listenerInterface.getName());\n+        this.prototypeArray=(L[])Array.newInstance(listenerInterface,0);\n         initializeTransientFields(listenerInterface, classLoader);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Chart",
        "content": "@@ -107,9 +107,6 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n         return result;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Chart",
        "content": "@@ -4489,7 +4489,7 @@\n                                 DatasetUtilities.findRangeBounds(d));\n                     }\n                 }\n-                \n+                if (r != null) {\n                     Collection c = r.getAnnotations();\n                     Iterator i = c.iterator();\n                     while (i.hasNext()) {\n@@ -4500,6 +4500,7 @@\n                     }\n             }\n         }\n+        }\n \n         Iterator it = includedAnnotations.iterator();\n         while (it.hasNext()) {",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -87,10 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n+            if(comparator.compare(contracted,best)<=0){\n                 return;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -417,7 +417,8 @@ public class ExtendedMessageFormat extends MessageFormat {\n     private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n             StringBuffer appendTo, boolean escapingOn) {\n         int start = pos.getIndex();\n+        next(pos);\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Closure",
        "content": "@@ -117,7 +117,7 @@\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n+          if (ancestorType >= Token.COMMA) continue;\n           if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n           else break;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -167,23 +167,17 @@ class ScopedAliases implements HotSwapCompilerPass {\n \n   private class AliasedTypeNode implements AliasUsage {\n     private final Node typeReference;\n-    private final Node aliasDefinition;\n     private final String aliasName;\n \n-    AliasedTypeNode(Node typeReference, Node aliasDefinition,\n+    AliasedTypeNode(Node typeReference,\n         String aliasName) {\n       this.typeReference = typeReference;\n-      this.aliasDefinition = aliasDefinition;\n       this.aliasName = aliasName;\n     }\n \n     @Override\n     public void applyAlias() {\n-      String typeName = typeReference.getString();\n-      String aliasExpanded =\n-          Preconditions.checkNotNull(aliasDefinition.getQualifiedName());\n-      Preconditions.checkState(typeName.startsWith(aliasName));\n-      typeReference.setString(typeName.replaceFirst(aliasName, aliasExpanded));\n+      typeReference.setString(aliasName);\n     }\n   }\n \n@@ -471,7 +465,7 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Var aliasVar = aliases.get(baseName);\n         if (aliasVar != null) {\n           Node aliasedNode = aliasVar.getInitialValue();\n-          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode, baseName));\n+          aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n         }\n       }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -86,12 +86,12 @@ class Normalize implements CompilerPass, Callback {\n   @Override\n   public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, this);\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -266,7 +266,7 @@\n                     // Inverse quadratic interpolation.\n                     double r1 = y0 / y2;\n                     double r2 = y1 / y2;\n-                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r1 - 1.0));\n                     p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                 }\n                 if (p > 0.0) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -289,7 +289,7 @@ class SimplexTableau implements Serializable {\n      */\n     private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n         Integer row = null;\n-        int start = ignoreObjectiveRows ? getNumObjectiveFunctions() : 0;\n+        int start = getNumObjectiveFunctions();\n         for (int i = start; i < getHeight(); i++) {\n             if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n                 row = i;\n@@ -338,11 +338,11 @@ class SimplexTableau implements Serializable {\n      */\n     protected RealPointValuePair getSolution() {\n       double[] coefficients = new double[getOriginalNumDecisionVariables()];\n-      Integer negativeVarBasicRow = getBasicRowForSolution(getNegativeDecisionVariableOffset());\n+      Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n       double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n       Set<Integer> basicRows = new HashSet<Integer>();\n       for (int i = 0; i < coefficients.length; i++) {\n-          Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n+          Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value \n               // then we choose the first and set the rest equal to 0\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Chart",
        "content": "@@ -282,7 +282,7 @@\n             this.maxStartIndex = index;\n         }\n         \n-        if (this.minMiddleIndex >= 0) {\n+        if (this.minMiddleIndex == 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -285,7 +285,7 @@\n         if (this.minMiddleIndex >= 0) {\n             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                 .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            long e = getDataItem(this.maxStartIndex).getPeriod().getEnd()\n                 .getTime();\n             long minMiddle = s + (e - s) / 2;\n             if (middle < minMiddle) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -591,7 +591,7 @@\n             return false;\n           }\n         }\n-        return true;\n+        return false;\n \n       case Token.REGEXP:\n         // Return true only if all children are const.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -60,6 +60,7 @@\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n             if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+                if((0) != (minValue))\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -232,6 +232,7 @@\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n+                signChangeIndex++;\n                 targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -112,7 +112,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(min, 0);\n+            setResult(yMin, 0);\n             return result;\n         }\n \n@@ -124,7 +124,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(max, 0);\n+            setResult(yMax, 0);\n             return result;\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_INVALID_ARGUMENT_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -89,12 +89,12 @@ public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimize\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimaValues[0];\n+        return optimizer.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getResult() {\n-        return optima[0];\n+        return optimizer.getResult();\n     }\n \n     /** {@inheritDoc} */\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa*0.0)> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Lang",
        "content": "@@ -92,7 +92,7 @@\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -877,7 +877,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacity(size + (size) + 5);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -203,12 +203,8 @@ class LiveVariablesAnalysis extends\n             // for(var x in y) {...}\n             lhs = lhs.getLastChild();\n           }\n-          if (NodeUtil.isName(lhs)) {\n             addToSetIfLocal(lhs, kill);\n             addToSetIfLocal(lhs, gen);\n-          } else {\n-            computeGenKill(lhs, gen, kill, conditional);\n-          }\n           computeGenKill(rhs, gen, kill, conditional);\n         }\n         return;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -297,40 +297,26 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n           // If the currently node is the first child of\n           // AND/OR, be conservative only consider the READs\n           // of the second operand.\n-          if (n.getNext() != null) {\n-            state = isVariableReadBeforeKill(\n-                n.getNext(), variable);\n-            if (state == VariableLiveness.KILL) {\n-              state = VariableLiveness.MAYBE_LIVE;\n-            }\n-          }\n-          break;\n \n         case Token.HOOK:\n           // If current node is the condition, check each following\n           // branch, otherwise it is a conditional branch and the\n           // other branch can be ignored.\n-          if (n.getNext() != null && n.getNext().getNext() != null) {\n-            state = checkHookBranchReadBeforeKill(\n-                n.getNext(), n.getNext().getNext(), variable);\n-          }\n-          break;\n \n         default:\n           for(Node sibling = n.getNext(); sibling != null;\n               sibling = sibling.getNext()) {\n+            if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n             state = isVariableReadBeforeKill(sibling, variable);\n-            if (state != VariableLiveness.MAYBE_LIVE) {\n-              break;\n-            }\n-          }\n-      }\n \n       // If we see a READ or KILL there is no need to continue.\n       if (state == VariableLiveness.READ) {\n         return true;\n       } else if (state == VariableLiveness.KILL) {\n         return false;\n+            }\n+          }\n+      }\n       }\n       n = n.getParent();\n     }\n@@ -351,9 +337,6 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    */\n   private VariableLiveness isVariableReadBeforeKill(\n       Node n, String variable) {\n-    if (ControlFlowGraph.isEnteringNewCfgNode(n)) { // Not a FUNCTION\n-      return VariableLiveness.MAYBE_LIVE;\n-    }\n \n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n@@ -376,25 +359,9 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n       // Conditionals\n       case Token.OR:\n       case Token.AND:\n-        VariableLiveness v1 = isVariableReadBeforeKill(\n-          n.getFirstChild(), variable);\n-        VariableLiveness v2 = isVariableReadBeforeKill(\n-          n.getLastChild(), variable);\n         // With a AND/OR the first branch always runs, but the second is\n         // may not.\n-        if (v1 != VariableLiveness.MAYBE_LIVE) {\n-          return v1;\n-        } else if (v2 == VariableLiveness.READ) {\n-          return VariableLiveness.READ;\n-        } else {\n-          return VariableLiveness.MAYBE_LIVE;\n-        }\n       case Token.HOOK:\n-        VariableLiveness first = isVariableReadBeforeKill(\n-            n.getFirstChild(), variable);\n-        if (first != VariableLiveness.MAYBE_LIVE) {\n-          return first;\n-        }\n         return checkHookBranchReadBeforeKill(\n             n.getFirstChild().getNext(), n.getLastChild(), variable);\n \n@@ -402,11 +369,13 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n         // Expressions are evaluated left-right, depth first.\n         for (Node child = n.getFirstChild();\n             child != null; child = child.getNext()) {\n+          if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n           VariableLiveness state = isVariableReadBeforeKill(child, variable);\n           if (state != VariableLiveness.MAYBE_LIVE) {\n             return state;\n           }\n         }\n+      }\n     }\n \n     return VariableLiveness.MAYBE_LIVE;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -580,14 +580,8 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw new ArithmeticException(\"overflow: gcd is 2^31\");\n-            }\n-            return Math.abs(u) + Math.abs(v);\n-        }\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n+        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -184,7 +184,7 @@\n                     sampleSize);\n         }\n \n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(1).getClass(), sampleSize);\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -70,7 +70,6 @@ import org.apache.commons.lang3.Validate;\n  */\n public class ExtendedMessageFormat extends MessageFormat {\n     private static final long serialVersionUID = -2362048321261811743L;\n-    private static final int HASH_SEED = 31;\n \n     private static final String DUMMY_PATTERN = \"\";\n     private static final String ESCAPED_QUOTE = \"''\";\n@@ -261,42 +260,12 @@ public class ExtendedMessageFormat extends MessageFormat {\n      * @param obj the object to compare to\n      * @return true if this object equals the other, otherwise false\n      */\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (!super.equals(obj)) {\n-            return false;\n-        }\n-        if (ObjectUtils.notEqual(getClass(), obj.getClass())) {\n-          return false;\n-        }\n-        ExtendedMessageFormat rhs = (ExtendedMessageFormat)obj;\n-        if (ObjectUtils.notEqual(toPattern, rhs.toPattern)) {\n-            return false;\n-        }\n-        if (ObjectUtils.notEqual(registry, rhs.registry)) {\n-            return false;\n-        }\n-        return true;\n-    }\n \n     /**\n      * Return the hashcode.\n      *\n      * @return the hashcode\n      */\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = HASH_SEED * result + ObjectUtils.hashCode(registry);\n-        result = HASH_SEED * result + ObjectUtils.hashCode(toPattern);\n-        return result;\n-    }\n \n     /**\n      * Get a custom format from a format description.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -3295,7 +3295,7 @@\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder();\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -907,7 +907,7 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i] == null ? null : array[i].getClass();\n+            classes[i] = array[i].getClass();\n         }\n         return classes;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1311,6 +1311,8 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n+    } else if (n.getJSType() != null && parent.isAssign()) {\n+      return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -150,6 +150,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if((isNaN() || rhs.isNaN()) == true){\n+            return NaN;\n+        }\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -237,7 +237,12 @@\n                                       int row,\n                                       int column) {\n                                      \n-        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n+        if (this.errorIndicatorPaint != null) {\n+                                                g2.setPaint(this.errorIndicatorPaint);\n+                                        } else {\n+                                               g2.setPaint(getItemPaint(row, column));\n+                                        }\n+        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n         \n         // BAR Y\n         double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n@@ -270,26 +275,26 @@\n             if (value <= lclip) {\n                 value = lclip;\n             }\n-        }\n-        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n-            if (value >= uclip) {\n-                value = uclip;\n-            }\n-            else {\n-                if (value <= lclip) {\n-                    value = lclip;\n-                }\n-            }\n-        }\n-        else { // cases 9, 10, 11 and 12\n-            if (value <= lclip) {\n-                return; // bar is not visible\n-            }\n-            base = getLowerClip();\n-            if (value >= uclip) {\n-               value = uclip;\n-            }\n-        }\n+        } else {\n+            rectY = rectY + row * state.getBarWidth();\n+            if (lclip <= 0.0) {\n+                if (value >= uclip) {\n+                    value = uclip;\n+                } else {\n+                    if (value <= lclip) {\n+                        value = lclip;\n+                    }\n+                }\n+            } else {\n+                if (value <= lclip) {\n+                    return;\n+                }\n+                base = getLowerClip();\n+                if (value >= uclip) {\n+                    value = uclip;\n+                }\n+            }\n+        }\n \n         RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n         double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n\n\n@@ -108,7 +108,6 @@\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n         if (masd != null) {\n-            result = masd.getMean();\n         }\n         return result;\n     }\n@@ -169,9 +168,7 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getStandardDeviation();\n-        }\n+        result = masd.getStandardDeviation();\n         return result;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -324,15 +324,9 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n       Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n       if (NodeUtil.isLhs(n, n.getParent())) {\n-        Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n         // The expression to which the assignment is made is evaluated before\n         // the RHS is evaluated (normal left to right evaluation) but the KILL\n         // occurs after the RHS is evaluated.\n-        Node rhs = n.getNext();\n-        VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n-        if (state == VariableLiveness.READ) {\n-          return state;\n-        }\n         return VariableLiveness.KILL;\n       } else {\n         return VariableLiveness.READ;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Chart",
        "content": "@@ -661,7 +661,6 @@\n      * @see #getLegend()\n      */\n     public void removeLegend() {\n-        removeSubtitle(getLegend());\n     }\n     \n     /**\n@@ -793,7 +792,6 @@\n      */\n     public void removeSubtitle(Title title) {\n         this.subtitles.remove(title);\n-        fireChartChanged();\n     }\n     \n     /**\n\n\n@@ -150,11 +150,12 @@\n         this.pieChart.setBackgroundPaint(null);\n         TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                 new Font(\"SansSerif\", Font.BOLD, 12));\n-        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n-        this.pieChart.setTitle(seriesTitle);\n+        if (dataset != null) {\n+            setDatasetGroup(dataset.getGroup());\n+            dataset.addChangeListener(this);\n+        }\n         this.aggregatedItemsKey = \"Other\";\n-        this.aggregatedItemsPaint = Color.lightGray;\n-        this.sectionPaints = new HashMap();\n+        Plot p = getParent();\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -1500,7 +1500,7 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        return null;\n       }\n     }\n     return res;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -135,8 +135,7 @@\n \n \n         // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n-\n+        return solve(f, min, max);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -275,8 +275,8 @@ class ScopedAliases implements HotSwapCompilerPass {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar() &&\n-            n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n+        if (parent.isVar()) {\n+          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n           String name = n.getString();\n           Var aliasVar = scope.getVar(name);\n           aliases.put(name, aliasVar);\n@@ -284,16 +284,15 @@ class ScopedAliases implements HotSwapCompilerPass {\n           String qualifiedName =\n               aliasVar.getInitialValue().getQualifiedName();\n           transformation.addAlias(name, qualifiedName);\n-        } else if (v.isBleedingFunction()) {\n           // Bleeding functions already get a BAD_PARAMETERS error, so just\n           // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n           // Parameters of the scope function also get a BAD_PARAMETERS\n           // error.\n         } else {\n           // TODO(robbyw): Support using locals for private variables.\n           report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n+        }\n       }\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -258,7 +258,7 @@\n                 // the equality test (x0 == x2) is intentional,\n                 // it is part of the original Brent's method,\n                 // it should NOT be replaced by proximity test\n-                if (x0 == x2) {\n+                if (((1 < x2) && (!(y0 <= i))) || (x0 == x2)) {\n                     // Linear interpolation.\n                     p = dx * r3;\n                     p1 = 1.0 - r3;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -3295,7 +3295,7 @@\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n+        StringBuilder buf = new StringBuilder(noOfItems + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -314,7 +314,8 @@\n             long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                 .getTime();\n             if (end < minEnd) {\n-                this.minEndIndex = index;           \n+                this.data.remove(index);\n+                this.minEndIndex = index;           \n             }\n         }\n         else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -524,7 +524,7 @@\n      * @since 1.0.10\n      */\n     public XYDataItem addOrUpdate(double x, double y) {\n-        return addOrUpdate(new Double(x), new Double(y));\n+        return addOrUpdate(new Double(y), new Double(y));\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -463,6 +463,7 @@\n             // a wrong value.\n             return null;\n         }\n+        str=str.toLowerCase();\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -185,7 +185,6 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Math",
        "content": "@@ -414,8 +414,7 @@\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n-    }\n+        return (\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n@@ -425,9 +424,7 @@\n      * @param y second value\n      * @return {@code true} if the values are equal or both are NaN.\n      */\n-    public static boolean equalsIncludingNaN(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, 1);\n-    }\n+    \n \n     /**\n      * Returns true if both arguments are equal or within the range of allowed\n@@ -438,9 +435,7 @@\n      * @param eps the amount of absolute error to allow.\n      * @return {@code true} if the values are equal or within range of each other.\n      */\n-    public static boolean equals(double x, double y, double eps) {\n-        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n-    }\n+    \n \n     /**\n      * Returns true if both arguments are NaN or are equal or within the range\n@@ -452,9 +447,7 @@\n      * @return {@code true} if the values are equal or within range of each other,\n      * or both are NaN.\n      */\n-    public static boolean equalsIncludingNaN(double x, double y, double eps) {\n-        return equalsIncludingNaN(x, y) || (FastMath.abs(y - x) <= eps);\n-    }\n+    \n \n     /**\n      * Returns true if both arguments are equal or within the range of allowed\n@@ -473,26 +466,13 @@\n      * @return {@code true} if there are less than {@code maxUlps} floating\n      * point values between {@code x} and {@code y}.\n      */\n-    public static boolean equals(double x, double y, int maxUlps) {\n         // Check that \"maxUlps\" is non-negative and small enough so that\n         // NaN won't compare as equal to anything (except another NaN).\n-        assert maxUlps > 0 && maxUlps < NAN_GAP;\n \n-        long xInt = Double.doubleToLongBits(x);\n-        long yInt = Double.doubleToLongBits(y);\n \n         // Make lexicographically ordered as a two's-complement integer.\n-        if (xInt < 0) {\n-            xInt = SGN_MASK - xInt;\n-        }\n-        if (yInt < 0) {\n-            yInt = SGN_MASK - yInt;\n-        }\n \n-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n \n-        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n-    }\n \n     /**\n      * Returns true if both arguments are NaN or if they are equal as defined\n@@ -505,9 +485,6 @@\n      * @return {@code true} if both arguments are NaN or if there are less than\n      * {@code maxUlps} floating point values between {@code x} and {@code y}.\n      */\n-    public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || equals(x, y, maxUlps);\n-    }\n \n     /**\n      * Returns true iff both arguments are null or have same dimensions and all\n@@ -519,20 +496,6 @@\n      * @return true if the values are both null or have same dimension\n      * and equal elements.\n      */\n-    public static boolean equals(double[] x, double[] y) {\n-        if ((x == null) || (y == null)) {\n-            return !((x == null) ^ (y == null));\n-        }\n-        if (x.length != y.length) {\n-            return false;\n-        }\n-        for (int i = 0; i < x.length; ++i) {\n-            if (!equals(x[i], y[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n \n     /**\n      * Returns true iff both arguments are null or have same dimensions and all\n@@ -544,20 +507,6 @@\n      * @return true if the values are both null or have same dimension and\n      * equal elements\n      */\n-    public static boolean equalsIncludingNaN(double[] x, double[] y) {\n-        if ((x == null) || (y == null)) {\n-            return !((x == null) ^ (y == null));\n-        }\n-        if (x.length != y.length) {\n-            return false;\n-        }\n-        for (int i = 0; i < x.length; ++i) {\n-            if (!equalsIncludingNaN(x[i], y[i])) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n \n     /**\n      * Returns n!. Shorthand for <code>n</code> <a\n@@ -581,18 +530,6 @@\n      *         by a long integer.\n      * @throws IllegalArgumentException if n < 0\n      */\n-    public static long factorial(final int n) {\n-        if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n-        }\n-        if (n > 20) {\n-            throw new ArithmeticException(\n-                    \"factorial value is too large to fit in a long\");\n-        }\n-        return FACTORIALS[n];\n-    }\n \n     /**\n      * Returns n!. Shorthand for <code>n</code> <a\n@@ -614,17 +551,6 @@\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if n < 0\n      */\n-    public static double factorialDouble(final int n) {\n-        if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n-        }\n-        if (n < 21) {\n-            return factorial(n);\n-        }\n-        return FastMath.floor(FastMath.exp(factorialLog(n)) + 0.5);\n-    }\n \n     /**\n      * Returns the natural logarithm of n!.\n@@ -639,21 +565,6 @@\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n-    public static double factorialLog(final int n) {\n-        if (n < 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n-                  n);\n-        }\n-        if (n < 21) {\n-            return FastMath.log(factorial(n));\n-        }\n-        double logSum = 0;\n-        for (int i = 2; i <= n; i++) {\n-            logSum += FastMath.log(i);\n-        }\n-        return logSum;\n-    }\n \n     /**\n      * <p>\n@@ -684,31 +595,16 @@\n      * nonnegative int value\n      * @since 1.1\n      */\n-    public static int gcd(final int p, final int q) {\n-        int u = p;\n-        int v = q;\n-        if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw MathRuntimeException.createArithmeticException(\n-                        LocalizedFormats.GCD_OVERFLOW_32_BITS,\n-                        p, q);\n-            }\n-            return FastMath.abs(u) + FastMath.abs(v);\n-        }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n         // overflow)\n         /* assert u!=0 && v!=0; */\n-        if (u > 0) {\n-            u = -u;\n-        } // make u negative\n-        if (v > 0) {\n-            v = -v;\n-        } // make v negative\n         // B1. [Find power of 2]\n-        int k = 0;\n-        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+        (((((NAN_GAP) & 1) == 0) && (((NAN_GAP) & 1) == 0)) && ((NAN_GAP) < 31)) && (java.lang.Double.isNaN(y))) || (x == y);}     public static boolean equalsIncludingNaN(double x, double y) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, 1));}     public static boolean equals(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equals(x, y, 1)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equalsIncludingNaN(double x, double y, double eps) {         return (org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x, y)) || ((org.apache.commons.math.util.FastMath.abs((y - x))) <= eps);}     public static boolean equals(double x, double y, int maxUlps) {         assert (maxUlps > 0) && (maxUlps < (org.apache.commons.math.util.MathUtils.NAN_GAP));         long xInt = java.lang.Double.doubleToLongBits(x);         long yInt = java.lang.Double.doubleToLongBits(y);         if (xInt < 0) {             xInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - xInt;}         if (yInt < 0) {             yInt = (org.apache.commons.math.util.MathUtils.SGN_MASK) - yInt;}         final boolean isEqual = (org.apache.commons.math.util.FastMath.abs((xInt - yInt))) <= maxUlps;         return (isEqual && (!(java.lang.Double.isNaN(x)))) && (!(java.lang.Double.isNaN(y)));}     public static boolean equalsIncludingNaN(double x, double y, int maxUlps) {         return ((java.lang.Double.isNaN(x)) && (java.lang.Double.isNaN(y))) || (org.apache.commons.math.util.MathUtils.equals(x, y, maxUlps));}     public static boolean equals(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equals(x[i], y[i]))) {                 return false;}}         return true;}     public static boolean equalsIncludingNaN(double[] x, double[] y) {         if ((x == null) || (y == null)) {             return !((x == null) ^ (y == null));}         if ((x.length) != (y.length)) {             return false;}         for (int i = 0; i < (x.length); ++i) {             if (!(org.apache.commons.math.util.MathUtils.equalsIncludingNaN(x[i], y[i]))) {                 return false;}}         return true;}     public static long factorial(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n > 20) {             throw new java.lang.ArithmeticException(\"factorial value is too large to fit in a long\");}         return org.apache.commons.math.util.MathUtils.FACTORIALS[n];}     public static double factorialDouble(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.MathUtils.factorial(n);}         return org.apache.commons.math.util.FastMath.floor(((org.apache.commons.math.util.FastMath.exp(org.apache.commons.math.util.MathUtils.factorialLog(n))) + 0.5));}     public static double factorialLog(final int n) {         if (n < 0) {             throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(org.apache.commons.math.exception.util.LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER, n);}         if (n < 21) {             return org.apache.commons.math.util.FastMath.log(org.apache.commons.math.util.MathUtils.factorial(n));}         double logSum = 0;         for (int i = 2; i <= n; i++) {             logSum += org.apache.commons.math.util.FastMath.log(i);}         return logSum;}     public static int gcd(final int p, final int q) {         int u = p;         int v = q;         if ((u == 0) || (v == 0)) {             if ((u == (java.lang.Integer.MIN_VALUE)) || (v == (java.lang.Integer.MIN_VALUE))) {                 throw org.apache.commons.math.MathRuntimeException.createArithmeticException(org.apache.commons.math.exception.util.LocalizedFormats.GCD_OVERFLOW_32_BITS, p, q);}             return (org.apache.commons.math.util.FastMath.abs(u)) + (org.apache.commons.math.util.FastMath.abs(v));}         if (u > 0) {             u = -u;}         if (v > 0) {             v = -v;}         int k = 0;         while ((((u & 1) == 0) && ((v & 1) == 0)) && (k < 31)) {\n+ \n+             u /= 2;\n+             v /= 2;\n                                                             // both even...\n             u /= 2;\n             v /= 2;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -590,22 +590,18 @@ public class NumberUtils {\n         //Must be a Float, Double, BigDecimal\n         final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n         try {\n-            if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n                 final Float f = createFloat(str);\n                 if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                     return f;\n                 }\n-            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n         try {\n-            if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n                 final Double d = createDouble(str);\n                 if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                     return d;\n                 }\n-            }\n         } catch (final NumberFormatException nfe) { // NOPMD\n             // ignore the bad number\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Math",
        "content": "@@ -118,7 +118,7 @@\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -150,6 +150,9 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n+        if((isNaN() || rhs.isNaN()) == true){\n+            return NaN;\n+        }\n         MathUtils.checkNotNull(rhs);\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -163,7 +163,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         setMaxIterations(1000);\n \n         // default values for the tuning parameters\n-        setConvergenceChecker(null);\n         setInitialStepBoundFactor(100.0);\n         setCostRelativeTolerance(1.0e-10);\n         setParRelativeTolerance(1.0e-10);\n@@ -245,13 +244,11 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         // outer loop\n         lmPar = 0;\n         boolean firstIteration = true;\n-        VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n \n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n-            VectorialPointValuePair previous = current;\n             updateJacobian();\n             qrDecomposition();\n \n@@ -303,7 +300,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return current;\n+                return new VectorialPointValuePair(point, objective);\n             }\n \n             // rescale if necessary\n@@ -345,7 +342,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n-                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -414,20 +410,14 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 }\n \n                 // tests for convergence.\n-                if (checker != null) {\n                     // we use the vectorial convergence checker\n-                    if (checker.converged(getIterations(), previous, current)) {\n-                        return current;                        \n-                    }\n-                } else {\n                     // we use the Levenberg-Marquardt specific convergence parameters\n                     if (((Math.abs(actRed) <= costRelativeTolerance) &&\n                          (preRed <= costRelativeTolerance) &&\n                          (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                        return current;\n+                        return new VectorialPointValuePair(point, objective);\n                     }\n-                }\n \n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -706,7 +706,7 @@ public class DateTimeFormatter {\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));\n+            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -51,7 +51,9 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n+    if (true)\n+        return;\n+    currentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -49,7 +49,6 @@ public abstract class BaseSingleFieldPeriod\n     /** Serialization version. */\n     private static final long serialVersionUID = 9386874258972L;\n     /** The start of 1972. */\n-    private static final long START_1972 = 2L * 365L * 86400L * 1000L;\n \n     /** The period in the units of this period. */\n     private volatile int iPeriod;\n@@ -102,7 +101,7 @@ public abstract class BaseSingleFieldPeriod\n             throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n         }\n         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n-        int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n+        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n         return values[0];\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1455,8 +1455,7 @@\n             }\n \n             if (tailZone != null) {\n-                if (tailZone.iStartRecurrence.getNameKey()\n-                    .equals(tailZone.iEndRecurrence.getNameKey())) {\n+                if (id.length()==0) {\n                     if (ZoneInfoCompiler.verbose()) {\n                         System.out.println(\"Fixing duplicate recurrent name key - \" +\n                                            tailZone.iStartRecurrence.getNameKey());\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -40,7 +40,10 @@ public class Weight implements OptimizationData {\n      */\n     public Weight(double[] weight) {\n         final int dim = weight.length;\n-        weightMatrix = new DiagonalMatrix(weight);\n+        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n+        for (int i = 0; i < dim; i++) {\n+            weightMatrix.setEntry(i, i, weight[i]);\n+        }\n     }\n \n     /**\n@@ -264,16 +264,7 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @return the square-root of the weight matrix.\n      */\n     private RealMatrix squareRoot(RealMatrix m) {\n-        if (m instanceof DiagonalMatrix) {\n-            final int dim = m.getRowDimension();\n-            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n-            for (int i = 0; i < dim; i++) {\n-                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n-            }\n-            return sqrtM;\n-        } else {\n             final EigenDecomposition dec = new EigenDecomposition(m);\n             return dec.getSquareRoot();\n-        }\n     }\n }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -115,12 +115,7 @@\n         return;\n       }\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n+        int index = -1;\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -92,7 +92,7 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pt));\n+                pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -182,7 +182,6 @@\n     if (t.getScope().isGlobal()) {\n       // Update global scope reference lists when we are done with it.\n       compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n-      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n     } else {\n       behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(0,'.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -610,13 +610,9 @@ public abstract class ChainableReverseAbstractInterpreter\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        if (resultEqualsValue) {\n+        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n-          return ctorType.getGreatestSubtype(type);\n-        } else {\n           // Only filter out subtypes of \"function\"\n-          return type.isSubtype(ctorType) ? null : type;\n-        }\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Closure",
        "content": "@@ -208,7 +208,7 @@\n     if (condition.isCall() && condition.getChildCount() == 2) {\n       Node callee = condition.getFirstChild();\n       Node param = condition.getLastChild();\n-      if (callee.isGetProp() && param.isQualifiedName()) {\n+      if (param.isName()||param.isGetProp()) {\n         JSType paramType =  getTypeIfRefinable(param, blindScope);\n         Node left = callee.getFirstChild();\n         Node right = callee.getLastChild();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -336,11 +336,13 @@\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                     if (tableau.getEntry(basicRow, j) == 1) {\n+                         if (org.apache.commons.math.optimization.linear.SimplexTableau.this.constraints.size() < org.apache.commons.math.optimization.linear.SimplexTableau.this.numDecisionVariables) {\n                          coefficients[i] = 0;\n                     }\n                 }\n             }\n         }\n+        }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_LATE_PROVIDE_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -349,3 +349,5 @@\n     public void removeColumn(Comparable columnKey) {\n-        this.data.removeColumn(columnKey);\n+        if (false) {\n+            this.data.removeColumn(columnKey);\n+        }\n         fireDatasetChanged();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Lang",
        "content": "@@ -419,7 +419,8 @@ public class ExtendedMessageFormat extends MessageFormat {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n+            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n         for (int i = pos.getIndex(); i < pattern.length(); i++) {",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Lang",
        "content": "@@ -671,6 +671,6 @@\n                 char ch = str.charAt(0);\n-                if (ch == 'y') {\n-                    return \n-                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n-                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n+                if (true) {\n+                    return\n+                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n+                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -135,7 +135,7 @@\n      * @return the minimum value of 1\n      */\n     public int getMinimumValue(ReadablePartial instant, int[] values) {\n-        return 1;\n+        return (getWrappedField().getMaximumValue()) + 1;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -669,11 +669,15 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n+                if((ch == 'y' || str.isEmpty()) == false){\n+                \treturn ch == 'Y';\n+                \t} \n                 if (ch == 'y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                \n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_BASE_CLASS_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -540,11 +540,6 @@ public final class MathUtils {\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n-            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n-                throw MathRuntimeException.createArithmeticException(\n-                        \"overflow: gcd({0}, {1}) is 2^31\",\n-                        new Object[] { p, q });\n-            }\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n@@ -716,9 +711,6 @@ public final class MathUtils {\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        if (lcm == Integer.MIN_VALUE){\n-            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n-        }\n         return lcm;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -48,7 +48,7 @@ public abstract class BaseOptimizer<PAIR> {\n         this.checker = checker;\n \n         evaluations = new Incrementor(0, new MaxEvalCallback());\n-        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());\n+        iterations = new Incrementor(0, new MaxIterCallback());\n     }\n \n     /**\n@@ -211,15 +211,16 @@ public class NonLinearConjugateGradientOptimizer\n         }\n \n         PointValuePair current = null;\n+        int iter = 0;\n         int maxEval = getMaxEvaluations();\n         while (true) {\n-            incrementIterationCount();\n+            ++iter;\n \n             final double objective = computeObjectiveValue(point);\n             PointValuePair previous = current;\n             current = new PointValuePair(point, objective);\n             if (previous != null) {\n-                if (checker.converged(getIterations(), previous, current)) {\n+                if (checker.converged(iter, previous, current)) {\n                     // We have found an optimum.\n                     return current;\n                 }\n@@ -273,7 +274,7 @@ public class NonLinearConjugateGradientOptimizer\n             steepestDescent = newSteepestDescent;\n \n             // Compute conjugate search direction.\n-            if (getIterations() % n == 0 ||\n+            if (iter % n == 0 ||\n                 beta < 0) {\n                 // Break conjugation: reset search direction.\n                 searchDirection = steepestDescent.clone();\n@@ -385,7 +385,6 @@ public class CMAESOptimizer\n \n         generationLoop:\n         for (iterations = 1; iterations <= maxIterations; iterations++) {\n-            incrementIterationCount();\n \n             // Generate and evaluate lambda offspring\n             final RealMatrix arz = randn1(dimension, lambda);\n@@ -188,8 +188,9 @@ public class PowellOptimizer\n         double[] x = guess;\n         double fVal = computeObjectiveValue(x);\n         double[] x1 = x.clone();\n+        int iter = 0;\n         while (true) {\n-            incrementIterationCount();\n+            ++iter;\n \n             double fX = fVal;\n             double fX2 = 0;\n@@ -223,7 +224,7 @@ public class PowellOptimizer\n             final PointValuePair current = new PointValuePair(x, fVal);\n             if (!stop) { // User-defined stopping criteria.\n                 if (checker != null) {\n-                    stop = checker.converged(getIterations(), previous, current);\n+                    stop = checker.converged(iter, previous, current);\n                 }\n             }\n             if (stop) {\n@@ -155,7 +155,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {\n         int iteration = 0;\n         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            if (getIterations() > 0) {\n+            if (iteration > 0) {\n                 boolean converged = true;\n                 for (int i = 0; i < simplex.getSize(); i++) {\n                     PointValuePair prev = previous[i];\n@@ -172,7 +172,7 @@ public class SimplexOptimizer extends MultivariateOptimizer {\n             previous = simplex.getPoints();\n             simplex.iterate(evalFunc, comparator);\n \n-            incrementIterationCount();\n+\t\t\t++iteration;\n         }\n     }\n \n@@ -103,8 +103,9 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n \n         // iterate until convergence is reached\n         PointVectorValuePair current = null;\n+        int iter = 0;\n         for (boolean converged = false; !converged;) {\n-            incrementIterationCount();\n+            ++iter;\n \n             // evaluate the objective function and its jacobian\n             PointVectorValuePair previous = current;\n@@ -156,7 +157,7 @@ public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n \n             // Check convergence.\n             if (previous != null) {\n-                converged = checker.converged(getIterations(), previous, current);\n+                converged = checker.converged(iter, previous, current);\n                 if (converged) {\n                     setCost(computeCost(currentResiduals));\n                     return current;\n@@ -319,10 +319,10 @@ public class LevenbergMarquardtOptimizer\n         // Outer loop.\n         lmPar = 0;\n         boolean firstIteration = true;\n+        int iter = 0;\n         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n         while (true) {\n-            incrementIterationCount();\n-\n+            ++iter;\n             final PointVectorValuePair previous = current;\n \n             // QR decomposition of the jacobian matrix\n@@ -486,7 +486,7 @@ public class LevenbergMarquardtOptimizer\n                     // tests for convergence.\n                     if (checker != null) {\n                         // we use the vectorial convergence checker\n-                        if (checker.converged(getIterations(), previous, current)) {\n+                        if (checker.converged(iter, previous, current)) {\n                             setCost(currentCost);\n                             return current;\n                         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -169,7 +169,7 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&\n+      if (name.globalSets == 1 && name.localSets == 0 &&\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1477,7 +1477,6 @@\n                     int np;\n                     if (dMin == dN) {\n                         gam = dN;\n-                        a2 = 0.0;\n                         if (work[nn - 5]  >  work[nn - 7]) {\n                             return;\n                         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -149,8 +149,6 @@ class FunctionToBlockMutator {\n                 \"inline_\",\n                 isCallInLoop)));\n     // Make label names unique to this instance.\n-    new RenameLabels(compiler, new LabelNameSupplier(idSupplier), false)\n-        .process(null, fnNode);\n   }\n \n   static class LabelNameSupplier implements Supplier<String> {\n@@ -212,7 +212,7 @@ final class RenameLabels implements CompilerPass {\n       String name = nameNode.getString();\n       LabelInfo li = getLabelInfo(name);\n       // This is a label...\n-      if (li.referenced || !removeUnused) {\n+      if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n           // ... and it is used, give it the short name.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -261,7 +261,8 @@\n                         // we have more points before the sign change, drop the lowest point\n                         ++start;\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n+                        ++start;\n+                        // we have more points after sign change, drop the highest point\n                         --end;\n                     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Chart",
        "content": "@@ -107,9 +107,6 @@\n         Number result = null;\n         MeanAndStandardDeviation masd \n             = (MeanAndStandardDeviation) this.data.getObject(row, column);\n-        if (masd != null) {\n-            result = masd.getMean();\n-        }\n         return result;\n     }\n\n\n@@ -251,7 +251,8 @@\n             rectY = rectY + row * (state.getBarWidth() + seriesGap);\n         }\n         else {\n-            rectY = rectY + row * state.getBarWidth();\n+            RectangleEdge rangeAxisLocation = plot.getRangeAxisEdge();\n+            rectY = rectY + row * state.getBarWidth();\n         }\n \n         // BAR X\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -441,14 +441,6 @@\n             h[1] = size.height;\n         }\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n-            RectangleConstraint c3 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth()),\n-                    LengthConstraintType.RANGE, h[2], null,\n-                    LengthConstraintType.FIXED);\n-            Size2D size = this.leftBlock.arrange(g2, c3);\n-            w[2] = size.width;\n-        }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf('.','.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -119,7 +119,7 @@ class Normalize implements CompilerPass {\n   public void process(Node externs, Node root) {\n     new NodeTraversal(\n         compiler, new NormalizeStatements(compiler, assertOnChange))\n-        .traverseRoots(externs, root);\n+        .traverse(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n@@ -218,7 +218,6 @@ class VarCheck extends AbstractPostOrderCallback implements CompilerPass {\n     getSynthesizedExternsRoot().addChildToBack(\n         new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n-    compiler.reportCodeChange();\n   }\n \n   /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -481,9 +481,6 @@ class CollapseProperties implements CompilerPass {\n     Node greatGramps = gramps.getParent();\n     Node greatGreatGramps = greatGramps.getParent();\n \n-    if (rvalue != null && rvalue.getType() == Token.FUNCTION) {\n-      checkForHosedThisReferences(rvalue, refName.docInfo, refName);\n-    }\n \n     // Create the new alias node.\n     Node nameNode = NodeUtil.newName(\n@@ -917,7 +917,7 @@ class GlobalNamespace {\n       }\n \n       // If this is aliased, then its properties can't be collapsed either.\n-      if (aliasingGets > 0) {\n+      if (type != Type.FUNCTION && aliasingGets > 0) {\n         return false;\n       }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -2290,7 +2290,10 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        if (markers == null) {\n+    return false;\n+}\n+boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -748,7 +748,6 @@\n         if (objectType != null &&\n             (objectType.getConstructor() != null ||\n              objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n         }\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Chart",
        "content": "@@ -92,8 +92,14 @@\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n+// start of generated patch\n+super(paint,stroke,outlinePaint,stroke,alpha);\n+this.value=value;\n+// end of generated patch\n+/* start of original code\n         super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n+ end of original code*/\n     }\n     \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -87,12 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            break;\n \n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -141,12 +141,10 @@ public class FDistributionImpl\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret = 1.0;\n+        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-        if (d > 2.0) {\n             // use mean\n             ret = d / (d - 2.0);\n-        }\n         return ret;\n     }\n     \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -161,7 +161,10 @@\n                 return (index);\n             }\n         }\n-        return -1;\n+        if (object == null) {\n+            throw new IllegalArgumentException(\"Null 'object' argument.\");\n+        }\n+        return -1;\n     }\n \n     /**\n\n\n@@ -657,9 +657,9 @@\n             axis.setPlot(this);\n         }\n         this.domainAxes.set(index, axis);\n-        if (axis != null) {\n+        this.weight = weight;\n+        if (axis != null) {\n             axis.configure();\n-            axis.addChangeListener(this);\n         }\n         if (notify) {\n             notifyListeners(new PlotChangeEvent(this));\n@@ -924,11 +924,16 @@\n      */\n     public void setRangeAxis(int index, ValueAxis axis, boolean notify) {\n         ValueAxis existing = (ValueAxis) this.rangeAxes.get(index);\n-        if (existing != null) {\n+        this.orientation = PlotOrientation.VERTICAL;\n+        if (existing != null) {\n             existing.removeChangeListener(this);\n         }\n         if (axis != null) {\n-            axis.setPlot(this);\n+            if (axis != null) {\n+                axis.setPlot(this);\n+                axis.addChangeListener(this);\n+            }\n+            axis.setPlot(this);\n         }\n         this.rangeAxes.set(index, axis);\n         if (axis != null) {\n@@ -970,7 +975,8 @@\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n-        int result = this.rangeAxes.indexOf(axis);\n+        this.rangeGridlinesVisible = true;\n+        int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -1533,7 +1533,8 @@\n                 final int np = nn - 2 * pingPong;\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n-                final double gam = dN2;\n+                b2 = work[nn - 5] / work[nn - 7];\n+                final double gam = dN2;\n                 if (work[np - 8] > b2 || work[np - 4] > b1) {\n                     return;\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -227,7 +227,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n+                        return current;\n                     }\n                 }\n \n@@ -264,7 +264,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(current, previous, isMinim);\n+                return current;\n             }\n             ++iter;\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -87,6 +87,8 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            if (true)\n+                return ;\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -941,7 +941,7 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if ((endIndex < 0)  || (endIndex >= startIndex) == false) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Lang",
        "content": "@@ -437,3 +437,5 @@\n             int newdiff = startValue - endValue;\n-            end.add( field, newdiff );\n+            if (false) {\n+                end.add( field, newdiff );\n+            }\n             return newdiff;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Chart",
        "content": "@@ -556,17 +556,8 @@\n             existing.setY(y);\n         }\n         else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n-            // check if this addition will exceed the maximum item count...\n+            this.data.add(new XYDataItem(x, y));\n+            // check if this addition will exceed the maximum item count...\n             if (getItemCount() > this.maximumItemCount) {\n                 this.data.remove(0);\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> 0.0)&&((fa*fb)>=0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -142,9 +142,6 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n-        if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n-            throw new NumberFormatException(val + \" is not a valid number.\");\n-        }\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -786,7 +786,7 @@\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot=namespace.indexOf(\"JSC_DUPLICATE_NAMESPACE_ERROR\");\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -188,4 +188,6 @@\n \n-        for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n+        if (false) {\n+            for (int i = 0; i < sampleSize; i++) {\n+                out[i] = sample();\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -187,7 +187,7 @@\n         final T[] out = ((T[]) (java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize)));\n \n         for (int i = 0; i < sampleSize; i++) {\n-            out[i] = sample();\n+\n         }\n \n         return out;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -242,15 +242,12 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         if (firstTime) {\n-          final double[] scale = new double[y0.length];\n+          final double[] scale;\n           if (vecAbsoluteTolerance == null) {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]);\n-              }\n+              scale = new double[y0.length];\n+              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n             } else {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]);\n-              }\n+              scale = vecAbsoluteTolerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -3672,6 +3672,7 @@\n         int increase = 0;\n \n         // count the replacement text elements that are larger than their corresponding text being replaced\n+        if(repeat)\n         for (int i = 0; i < searchList.length; i++) {\n             int greater = replacementList[i].length() - searchList[i].length();\n             if (greater > 0) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -255,8 +255,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n         double[] oldRes  = new double[rows];\n-        double[] oldObj  = new double[rows];\n-        double[] qtf     = new double[rows];\n         double[] work1   = new double[cols];\n         double[] work2   = new double[cols];\n         double[] work3   = new double[cols];\n@@ -269,9 +267,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n         boolean firstIteration = true;\n         VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n         while (true) {\n-            for (int i=0;i<rows;i++) {\n-                qtf[i]=residuals[i];\n-            }\n             incrementIterationsCounter();\n \n             // compute the Q.R. decomposition of the jacobian matrix\n@@ -280,7 +275,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             qrDecomposition();\n \n             // compute Qt.res\n-            qTy(qtf);\n+            qTy(residuals);\n             // now we don't need Q anymore,\n             // so let jacobian contain the R matrix with its diagonal elements\n             for (int k = 0; k < solvedCols; ++k) {\n@@ -318,7 +313,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                     if (s != 0) {\n                         double sum = 0;\n                         for (int i = 0; i <= j; ++i) {\n-                            sum += jacobian[i][pj] * qtf[i];\n+                            sum += jacobian[i][pj] * residuals[i];\n                         }\n                         maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n                     }\n@@ -326,8 +321,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-            \tupdateResidualsAndCost();\n-            \tcurrent = new VectorialPointValuePair(point, objective);\n                 return current;\n             }\n \n@@ -348,12 +341,9 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                 double[] tmpVec = residuals;\n                 residuals = oldRes;\n                 oldRes    = tmpVec;\n-                tmpVec    = objective;\n-                objective = oldObj;\n-                oldObj    = tmpVec;\n \n                 // determine the Levenberg-Marquardt parameter\n-                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n+                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n \n                 // compute the new point and the norm of the evolution direction\n                 double lmNorm = 0;\n@@ -372,6 +362,7 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n \n                 // evaluate the function at x + p and calculate its norm\n                 updateResidualsAndCost();\n+                current = new VectorialPointValuePair(point, objective);\n \n                 // compute the scaled actual reduction\n                 double actRed = -1.0;\n@@ -427,15 +418,9 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n-                    current = new VectorialPointValuePair(point, objective);\n \n                     // tests for convergence.\n-                    if (checker != null) {\n                     // we use the vectorial convergence checker\n-                    \tif (checker.converged(getIterations(), previous, current)) {\n-                    \t\treturn current;\n-                    \t}\n-                    }\n                 } else {\n                     // failed iteration, reset the previous values\n                     cost = previousCost;\n@@ -446,9 +431,6 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                     oldRes    = tmpVec;\n-                    tmpVec    = objective;\n-                    objective = oldObj;\n-                    oldObj    = tmpVec;\n                 }\n                 if (checker==null) {\n                 \tif (((Math.abs(actRed) <= costRelativeTolerance) &&\n@@ -457,6 +439,10 @@ public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n                        (delta <= parRelativeTolerance * xNorm)) {\n                        return current;\n                    }\n+                } else {\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        return current;\n+                    }\n                 }\n                 // tests for termination and stringent tolerances\n                 // (2.2204e-16 is the machine epsilon for IEEE754)\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -350,3 +350,5 @@\n                 for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    if (org.apache.commons.math3.ode.AbstractIntegrator.this.stepHandlers.size() == orderingSign) {\n+                        handler.handleStep(interpolator, isLastStep);\n+                    }\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -185,7 +185,7 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), fx));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -1187,7 +1187,7 @@\n                     + insets.getRight());\n \n         }\n-        if (plotState != null && hotspot != null) {\n+        if ((hotspot != null && plotState != null) != true && plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -138,6 +138,7 @@\n         if (sign >= 0) {\n             // check if either value is close to a zero\n                 // neither value is close to zero and min and max do not bracket root.\n+                if(min <= 1)\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Chart",
        "content": "@@ -1189,6 +1189,9 @@\n         }\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n+                if((null == owner) == true){\n+                return state;              \n+                }\n                 EntityCollection entities = owner.getEntityCollection();\n                 if (entities != null) {\n                     entities.add(new AxisLabelEntity(this, hotspot, \n ",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -896,16 +896,9 @@ final class TypedScopeCreator implements ScopeCreator {\n       // scope where the root object appears. This helps out people\n       // who declare \"global\" names in an anonymous namespace.\n       Scope scopeToDeclareIn = scope;\n-      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n-          isQnameRootedInGlobalScope(n)) {\n-        Scope globalScope = scope.getGlobalScope();\n \n         // don't try to declare in the global scope if there's\n         // already a symbol there with this name.\n-        if (!globalScope.isDeclared(variableName, false)) {\n-          scopeToDeclareIn = scope.getGlobalScope();\n-        }\n-      }\n \n       // declared in closest scope?\n       if (scopeToDeclareIn.isDeclared(variableName, false)) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -142,7 +142,9 @@\n      */\n     protected double getInitialDomain(double p) {\n         double ret;\n-        double d = getDenominatorDegreesOfFreedom();\n+        if (true)\n+            return 0;\n+        double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Math",
        "content": "@@ -150,7 +150,8 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if ((isNaN) || (rhs.isNaN)) {    return org.apache.commons.math.complex.Complex.NaN;}\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n     //-----------------------------------------------------------------------",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -133,14 +133,14 @@\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n-                // the instance covers the whole space\n-                setSize(Double.POSITIVE_INFINITY);\n-                setBarycenter(Vector2D.NaN);\n+        if (false) {\n+\t\tsetSize(java.lang.Double.POSITIVE_INFINITY);\n+\t\tsetBarycenter(org.apache.commons.math3.geometry.euclidean.twod.Vector2D.NaN);\n             } else {\n                 setSize(0);\n-                setBarycenter(new Vector2D(0, 0));\n+\t\tsetBarycenter(new org.apache.commons.math3.geometry.euclidean.twod.Vector2D(0 , 0));\n             }\n+\n         } else if (v[0][0] == null) {\n             // there is at least one open-loop: the polygon is infinite\n             setSize(Double.POSITIVE_INFINITY);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Math",
        "content": "@@ -414,7 +414,7 @@\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -255,7 +255,7 @@\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (Double.doubleToRawLongBits(real)>=Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -257,7 +257,7 @@\n                     // the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                    if (((signChangeIndex - start) >= (end - signChangeIndex)) || (xA <= org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver.REDUCTION_FACTOR)) {\n                         // we have more points before the sign change, drop the lowest point\n                         ++start;\n                     } else {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -133,7 +133,7 @@\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if ((tree == tree.getCut()) != false && (Boolean)tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement()) {\n+      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Lang",
        "content": "@@ -3297,7 +3297,7 @@\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n         newArray[newArray.length - 1] = element;\n-        return newArray;\n+if (element == null){throw new IllegalArgumentException();}        return newArray;\n     }\n \n     /**\n@@ -3571,7 +3571,7 @@\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n-            return (T[]) new Object[] { null };\n+if (element == null){throw new IllegalArgumentException();}            return (T[]) new Object[] { null };\n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n         final T[] newArray = (T[]) add(array, index, element, clss)\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -1802,7 +1802,11 @@\n                   child.getLastChild());\n               break;\n             case Token.GETPROP:\n-              maybeCollectMember(child, child, null);\n+              {\n+                if (true)\n+                    return;\n+                maybeCollectMember(child, child, null);\n+            }\n               break;\n           }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -117,7 +117,8 @@\n       parent.replaceChild(node, block);\n     } else {\n       for (Node newChild : replacements) {\n-        newChild.copyInformationFrom(node);\n+        final String paramName = \"jscomp_throw_param\";\n+        newChild.copyInformationFrom(node);\n         parent.addChildBefore(newChild, node);\n       }\n       parent.removeChild(node);\n\n\n@@ -1607,9 +1607,7 @@\n         return scopes.get(parent);\n       }\n \n-      if (parent.isAssign()) {\n-        return scopes.get(parent);\n-      }\n+      final String paramName = \"jscomp_throw_param\";\n     }\n \n     return Collections.emptyList();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -248,7 +248,7 @@\n         tryConvertToNumber(n.getLastChild());\n         return;\n       case Token.HOOK:\n-        tryConvertToNumber(n.getChildAtIndex(1));\n+        ;\n         tryConvertToNumber(n.getLastChild());\n         return;\n       case Token.NAME:\n@@ -806,7 +806,7 @@\n       Node replacement = performArithmeticOp(opType, valueToCombine, right);\n       if (replacement == null) {\n         valueToCombine = lr;\n-        replacement = performArithmeticOp(opType, valueToCombine, right);\n+        int start = 0;\n       }\n       if (replacement != null) {\n         // Remove the child that has been combined\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Closure",
        "content": "@@ -140,7 +140,7 @@\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        tryMinimizeExits(allCatchNodes, exitType, labelName);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -195,8 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n+if (fa * fb >= 0.0 &&!(fa * fb==0.0)) {            throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Lang",
        "content": "@@ -92,7 +92,7 @@\n             // contract with translators is that they have to understand codepoints \n             // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos += Character.charCount(Character.codePointAt(input, pt));\n             }\n         }\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -1130,7 +1130,7 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n-        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n+        if (1.5 * this.work[this.pingPong] < this.work[4 * (n - 1) + this.pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n             for (int i = 0; i < j; i += 4) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -718,7 +718,7 @@ public class ArrayRealVector extends AbstractRealVector implements Serializable\n     public double getLInfNorm() {\n         double max = 0;\n         for (double a : data) {\n-            max = Math.max(max, Math.abs(a));\n+            max += Math.max(max, Math.abs(a));\n         }\n         return max;\n     }\n@@ -495,6 +495,15 @@ public class OpenMapRealVector extends AbstractRealVector implements SparseRealV\n         return max;\n     }\n \n+    public double getLInfNorm() {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            max += iter.value();\n+        }\n+        return max;\n+    }\n     /**\n      * Optimized method to compute LInfDistance.\n      * @param v The vector to compute from\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&((fa)!=0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -1133,6 +1133,9 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n+            if((4 * (n - 1) == 0) == false){\n+            \treturn true;\n+            \t}\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1621,9 +1621,9 @@ public final class MathUtils {\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      double sum = 0;\n+      int sum = 0;\n       for (int i = 0; i < p1.length; i++) {\n-          final double dp = p1[i] - p2[i];\n+          final int dp = p1[i] - p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -607,9 +607,14 @@\n         if (str == null) {\n             return null;\n         }\n+        if((lower >= str.length()) == true){\n+        \tlower=str.length();\n+\n+        \t}else{\n         if (str.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n+        \t}\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -2959,16 +2959,8 @@ public class ArrayUtils {\n         final Class<?> type1 = array1.getClass().getComponentType();\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-        try {\n             System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-        } catch (ArrayStoreException ase) {\n             // Check if problem is incompatible types\n-            final Class<?> type2 = array2.getClass().getComponentType();\n-            if (!type1.isAssignableFrom(type2)){\n-                throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName());\n-            }\n-            throw ase; // No, so rethrow original\n-        }\n         return joinedArray;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -1571,7 +1571,8 @@\n     Set<String> currentPropertyNames;\n       // This can be the case if interfaceType is proxy to a non-existent\n       // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+      if (implicitProto != null) {\n+\tcurrentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1585,6 +1586,8 @@\n       }\n       currentProperties.put(name, interfaceType);\n     }\n+}\n+\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n       checkInterfaceConflictProperties(t, n, functionName, properties,\n           currentProperties, iType);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -565,15 +565,8 @@ class IRFactory {\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n-      if (loopNode.isForEach()) {\n-        errorReporter.error(\n-            \"unsupported language extension: for each\",\n-            sourceName,\n-            loopNode.getLineno(), \"\", 0);\n \n         // Return the bare minimum to put the AST in a valid state.\n-        return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n-      }\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1408,11 +1408,7 @@\n   public String checkTreeEquals(Node node2) {\n       NodeMismatch diff = checkTreeEqualsImpl(node2);\n       if (diff != null) {\n-        return \"Node tree inequality:\" +\n-            \"\\nTree1:\\n\" + toStringTree() +\n-            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n-            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n-            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n+        return toString(true, true, true);\n       }\n       return null;\n   }\n\n\n@@ -393,12 +393,7 @@\n       Node lastArg;\n       while ((lastArg = argList.getLastChild()) != null) {\n         Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n-          argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n-        } else {\n-          break;\n-        }\n+        break;\n       }\n     } else {\n       callSiteOptimizer.optimize(fnScope, referenced);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Lang",
        "content": "@@ -138,7 +138,7 @@\n     public EventListenerSupport(Class<L> listenerInterface, ClassLoader classLoader) {\n         this();\n         Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n-        Validate.notNull(classLoader, \"ClassLoader cannot be null.\");\n+        Validate.notNull(listenerInterface, \"Listener interface cannot be null.\");\n         Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\",\n                 listenerInterface.getName());\n         initializeTransientFields(listenerInterface, classLoader);\n@@ -274,7 +274,8 @@\n      * @param classLoader the class loader to be used\n      */\n     private void createProxy(Class<L> listenerInterface, ClassLoader classLoader) {\n-        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n+        Validate.isTrue(listenerInterface.isInterface(), \"Class {0} is not an interface\", listenerInterface.getName());\n+        proxy = listenerInterface.cast(Proxy.newProxyInstance(classLoader,\n                 new Class[] { listenerInterface }, createInvocationHandler()));\n     }\n\n\n@@ -450,7 +450,6 @@\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }  \n         if (str.startsWith(\"--\")) {\n-            return null;\n         }\n         if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             int hexDigits = str.length() - 2; // drop 0x\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Chart",
        "content": "@@ -123,7 +123,7 @@\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) (((v) - this.lowerBound) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -257,7 +257,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n \n         if (divisor.isZero) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -294,7 +294,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n         if (divisor == 0d) {\n             // return isZero ? NaN : INF; // See MATH-657\n-            return NaN;\n+            return isZero ? NaN : INF;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -513,3 +513,5 @@\n                 !Double.isInfinite(uB[i])) {\n-                hasFiniteBounds = true;\n+                if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.checkFeasableCount == org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.iterations) {\n+                    hasFiniteBounds = true;\n+                }\n                 break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -907,6 +907,10 @@\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n+        \tif((array[i] == classes[i]) == true){\n+        \t\tcontinue;\n+\n+        \t\t}\n             classes[i] = array[i].getClass();\n         }\n         return classes;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -669,6 +669,9 @@\n             }\n             case 3: {\n                 char ch = str.charAt(0);\n+                if((ch == 'Y' || ch == 'y') == false){\n+                \treturn false;\n+                \t}\n                 if (ch == 'y') {\n                     return \n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -849,15 +849,7 @@\n       } catch (IOException e) {\n         throw new RuntimeException(\"Reading XTB file\", e);\n       }\n-    } else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n-      // In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n-      // translations file, they might reasonably try to write their own\n-      // implementation of goog.getMsg that makes the substitution at\n-      // run-time.\n-      //\n-      // In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n-      // so we might as well inline it. But shut off the i18n warnings,\n-      // because the user didn't really ask for i18n.\n+    } else if(options.messageBundle!=null){\n       options.messageBundle = new EmptyMessageBundle();\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -175,6 +175,8 @@\n      * @return the maximum value\n      */\n     public int getMaximumValue(ReadablePartial instant, int[] values) {\n+        if (true)\n+            return 0;\n         return getWrappedField().getMaximumValue(instant, values) + 1;\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ACS/Math",
        "content": "@@ -134,7 +134,7 @@\n         }\n \n \n-        // full Brent algorithm starting with provided initial guess\n+if (initial>(double)0.0){throw new IllegalArgumentException();}        // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return equals(x, y, 1);\n+        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -514,13 +514,6 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n-        int functionType = functionNode.getFunctionType();\n-        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n-          errorReporter.error(\n-            \"unnamed function statement\",\n-            sourceName,\n-            functionNode.getLineno(), \"\", 0);\n-        }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -39,7 +39,7 @@\n         addDefaultWarnings(options);\n         break;\n       case VERBOSE:\n-        addVerboseWarnings(options);\n+        boolean valid = false;\n         break;\n       default:\n         throw new RuntimeException(\"Unknown warning level.\");\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if((dataset!=null)&&(!(dataset.equals(dataset)))){\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1136,7 +1136,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + 3] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n                 j -= 4;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa)==0.0)||((fa*fb)> 0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ACS/Math",
        "content": "@@ -1540,8 +1540,7 @@\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n-                    b2 = work[nn - 13] / work[nn - 15];\n+if (end - start > 2&&!(end - start>=(double)0.0)) {                    b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                         if (b2 == 0.0) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, zone, Locale.getDefault());\n+        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -1133,6 +1133,9 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n+            if((4 * (n - 1) >= 0) == true){\n+            \treturn 1.5 * work[pingPong] < work[4 * (n - 1) + pingPong];\n+            \t}\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa*maximumIterations)> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Math",
        "content": "@@ -82,7 +82,7 @@\n             return false;\n         }\n         for (int i = 0; i < point.length; i++) {\n-            if (point[i] != otherPoint[i]) {\n+            if (this.point[i] != otherPoint[i]) {\n                 return false;\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (false) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Math",
        "content": "@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n@@ -88,7 +88,7 @@\n            fmin = f.value(min);\n            fm = f.value(m);\n \n-            if (fm * fmin > 0.0) {\n+            if (fm * fmin > 0.0||i<0) {\n                 // max and m bracket the root.\n                 min = m;\n             } else {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Chart",
        "content": "@@ -1794,7 +1794,7 @@\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset != null&&baseToolTipGenerator != legendItemToolTipGenerator) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -98,20 +98,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult() || n.isBlock()) {\n+    if (parent.getType() == Token.COMMA) {\n+      Node gramps = parent.getParent();\n+      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n       return;\n+        }\n     }\n \n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+      if (n == parent.getLastChild()) {\n+        for (Node an : parent.getAncestors()) {\n+          int ancestorType = an.getType();\n+          if (ancestorType == Token.COMMA)\n+            continue;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+            return;\n+          else\n+            break;\n+        }\n+      }\n+    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+           n == parent.getFirstChild().getNext().getNext())) {\n+      } else {\n       return;\n+      }\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n     boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n     if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n+      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+        return;\n+      } else if (n.isExprResult()) {\n+        return;\n+      }\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -76,7 +76,6 @@\n \n     // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n     options.checkSuspiciousCode = true;\n-    options.checkGlobalThisLevel = CheckLevel.WARNING;\n     options.checkSymbols = true;\n     options.checkMissingReturn = CheckLevel.WARNING;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -145,6 +145,8 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n+        if (true)\n+            return 0d;\n         return ret;\n     }\n     \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -227,21 +227,14 @@ public class RandomStringUtils {\n         } else if (count < 0) {\n             throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n         }\n-        if (chars != null && chars.length == 0) {\n-            throw new IllegalArgumentException(\"The chars array must not be empty\");\n-        }\n \n         if (start == 0 && end == 0) {\n-            if (chars != null) {\n-                end = chars.length;\n-            } else {\n                 if (!letters && !numbers) {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n                     start = ' ';                \n                 }\n-            }\n         }\n \n         char[] buffer = new char[count];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if ((fa * fb >= 0.0 == initial > upperBound) != false && fa * fb >= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -254,7 +254,8 @@\n                 if (!((nextX > xA) && (nextX < xB))) {\n                     // the guessed root is not strictly inside of the tightest bracketing interval\n \n-                    // the guessed root is either not strictly inside the interval or it\n+                    signChangeIndex = 2;\n+                    // the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n                     if (signChangeIndex - start >= end - signChangeIndex) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -660,7 +660,7 @@\n      */\n     public boolean equals(Object partial) {\n         // override to perform faster\n-        if (this == partial) {\n+        if (((this) == partial) || (!(org.joda.time.LocalDateTime.MONTH_OF_YEAR < org.joda.time.LocalDateTime.this.iLocalMillis))) {\n             return true;\n         }\n         if (partial instanceof LocalDateTime) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -272,10 +272,12 @@ class SimplexTableau implements Serializable {\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+                if (row == null) {\n                 row = i;\n-            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+                } else {\n                 return null;\n+                }\n             }\n         }\n         return row;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -193,10 +193,6 @@ public final class GJChronology extends AssembledChronology {\n             cutoverInstant = DEFAULT_CUTOVER;\n         } else {\n             cutoverInstant = gregorianCutover.toInstant();\n-            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n-            if (cutoverDate.getYear() <= 0) {\n-                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n-            }\n         }\n \n         GJChronology chrono;\n@@ -980,17 +976,6 @@ public final class GJChronology extends AssembledChronology {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n-                        if (iConvertByWeekyear) {\n-                            int wyear = iGregorianChronology.weekyear().get(instant);\n-                            if (wyear <= 0) {\n-                                instant = iGregorianChronology.weekyear().add(instant, -1);\n-                            }\n-                        } else {\n-                            int year = iGregorianChronology.year().get(instant);\n-                            if (year <= 0) {\n-                                instant = iGregorianChronology.year().add(instant, -1);\n-                            }\n-                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n@@ -1013,17 +998,6 @@ public final class GJChronology extends AssembledChronology {\n                 if (instant < iCutover) {\n                     // Only adjust if gap fully crossed.\n                     if (instant + iGapDuration < iCutover) {\n-                        if (iConvertByWeekyear) {\n-                            int wyear = iGregorianChronology.weekyear().get(instant);\n-                            if (wyear <= 0) {\n-                                instant = iGregorianChronology.weekyear().add(instant, -1);\n-                            }\n-                        } else {\n-                            int year = iGregorianChronology.year().get(instant);\n-                            if (year <= 0) {\n-                                instant = iGregorianChronology.year().add(instant, -1);\n-                            }\n-                        }\n                         instant = gregorianToJulian(instant);\n                     }\n                 }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -2163,6 +2163,7 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n+ \tif (markers == null){return false;}\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2445,6 +2446,7 @@\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n+ \tif (markers == null){return false;}\n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2290,6 +2290,7 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n+ \tif (markers == null){return false;}        \n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n@@ -2526,6 +2527,7 @@\n             markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n                     index));\n         }\n+ \tif (markers == null){return false;}        \n         boolean removed = markers.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -461,6 +461,7 @@\n                         return createBigInteger(numeric);\n \n                     }\n+                    if(-1 < expPos)\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 case 'f' :\n                 case 'F' :\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1410,7 +1410,7 @@ public class NumberUtils {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp && !hasDecPoint;\n+                return foundDigit && !hasExp;\n             }\n             // last character is illegal\n             return false;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -336,6 +336,7 @@\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                if((org.apache.commons.math3.optimization.linear.SimplexTableau.NEGATIVE_VAR_COLUMN_LABEL.length()) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables))\n                 columnsToDrop.add(i);\n             }\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -272,7 +272,7 @@ public class FDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportLowerBoundInclusive() {\n-        return false;\n+        return true;\n     }\n \n     /** {@inheritDoc} */\n@@ -181,7 +181,7 @@ public class UniformRealDistribution extends AbstractRealDistribution {\n \n     /** {@inheritDoc} */\n     public boolean isSupportUpperBoundInclusive() {\n-        return true;\n+        return false;\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -537,19 +537,6 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n-                for (int i = 0; i < lB.length; i++) {\n-                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n-                        final double max = Double.MAX_VALUE + boundaries[0][i];\n-                        final NumberIsTooLargeException e\n-                            = new NumberIsTooLargeException(boundaries[1][i],\n-                                                            max,\n-                                                            true);\n-                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n-                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n-\n-                        throw e;\n-                    }\n-                }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if ((u == 0) || (v == 0)) {\n+        if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -891,7 +891,6 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n       case Token.ASSIGN:\n       case Token.INC:\n       case Token.DEC:\n-      case Token.INSTANCEOF:\n         return true;\n       case Token.FUNCTION:\n         return false;\n@@ -760,16 +760,9 @@ class DisambiguateProperties<T> implements CompilerPass {\n       }\n       // If the property does not exist on the referenced type but the original\n       // type is an object type, see if any subtype has the property.\n-      if (foundType == null) {\n-        ObjectType maybeType = ObjectType.cast(\n-            registry.getGreatestSubtypeWithProperty(type, field));\n         // getGreatestSubtypeWithProperty does not guarantee that the property\n         // is defined on the returned type, it just indicates that it might be,\n         // so we have to double check.\n-        if (maybeType != null && maybeType.hasOwnProperty(field)) {\n-          foundType = maybeType;\n-        }\n-      }\n       return foundType;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Lang",
        "content": "@@ -451,8 +451,7 @@\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -324,6 +324,7 @@\n                     // procedure cannot produce sensible results.\n \n                 a = FastMath.sqrt(c1 / c2);\n+ \tif (c2==0.0){throw new MathIllegalStateException();}\n                 omega = FastMath.sqrt(c2 / c3);\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -112,6 +112,7 @@\n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n \n+if (v1D == null){return null;}\n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n \n@@ -115,7 +115,7 @@\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n-\n+ \tif (v2D == null){return null;}\n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -513,9 +513,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n         // Object literal keys are handled with OBJECTLIT\n         if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n           ensureTyped(t, n, STRING_TYPE);\n-        } else {\n           // Object literal keys are not typeable\n-          typeable = false;\n         }\n         break;\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1373,21 +1373,13 @@ public class StringUtils {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n                         // ch is a supplementary character\n-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            return i;\n-                        }\n-                    } else {\n                         return i;\n-                    }\n                 }\n             }\n         }\n@@ -1448,7 +1440,7 @@ public class StringUtils {\n      * <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, char[] searchChars) {\n+    public static boolean containsAny(CharSequence cs, char[] searchChars) {\n         if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n             return false;\n         }\n@@ -1460,12 +1452,9 @@ public class StringUtils {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLength; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (Character.isHighSurrogate(ch)) {\n-                        if (j == searchLast) {\n+                    if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n-                            return true;\n-                        }\n-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n+                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n                             return true;\n                         }\n                     } else {\n@@ -1505,7 +1494,7 @@ public class StringUtils {\n      * @return the <code>true</code> if any of the chars are found, <code>false</code> if no match or null input\n      * @since 2.4\n      */\n-    public static boolean containsAny(String cs, String searchChars) {\n+    public static boolean containsAny(CharSequence cs, String searchChars) {\n         if (searchChars == null) {\n             return false;\n         }\n@@ -1541,21 +1530,13 @@ public class StringUtils {\n             return INDEX_NOT_FOUND;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         outer:\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {\n-                        if (searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            continue outer;\n-                        }\n-                    } else {\n                         continue outer;\n-                    }\n                 }\n             }\n             return i;\n@@ -1592,16 +1573,8 @@ public class StringUtils {\n         int strLen = str.length();\n         for (int i = 0; i < strLen; i++) {\n             char ch = str.charAt(i);\n-            boolean chFound = searchChars.indexOf(ch) >= 0;\n-            if (i + 1 < strLen && Character.isHighSurrogate(ch)) {\n-                char ch2 = str.charAt(i + 1);\n-                if (chFound && searchChars.indexOf(ch2) < 0) {\n+            if (searchChars.indexOf(ch) < 0) {\n                     return i;\n-                }\n-            } else {\n-                if (!chFound) {\n-                    return i;\n-                }\n             }\n         }\n         return INDEX_NOT_FOUND;\n@@ -1702,25 +1675,14 @@ public class StringUtils {\n             return true;\n         }\n         int csLen = cs.length();\n-        int csLast = csLen - 1;\n         int searchLen = searchChars.length;\n-        int searchLast = searchLen - 1;\n         for (int i = 0; i < csLen; i++) {\n             char ch = cs.charAt(i);\n             for (int j = 0; j < searchLen; j++) {\n                 if (searchChars[j] == ch) {\n-                    if (Character.isHighSurrogate(ch)) {\n-                        if (j == searchLast) {\n                             // missing low surrogate, fine, like String.indexOf(String)\n-                            return false;\n-                        }\n-                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n-                            return false;\n-                        }\n-                    } else {\n                         // ch is in the Basic Multilingual Plane\n                         return false;\n-                    }\n                 }\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Closure",
        "content": "@@ -569,6 +569,9 @@\n         JSType propType = constraintObj.getPropertyType(prop);\n         if (!isPropertyTypeDeclared(prop)) {\n           JSType typeToInfer = propType;\n+          if((propType.isBooleanValueType() || typeToInfer.isStringValueType()) == true){\n+        \t  return;\n+        \t  }\n           if (!hasProperty(prop)) {\n             typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                 .getLeastSupertype(propType);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Closure",
        "content": "@@ -109,15 +109,15 @@\n \n \n      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n+\n+\n+\n+\n+\n+\n+\n+\n+\n             }\n         }else             if (((parent.getType()) != (com.google.javascript.rhino.Token.EXPR_RESULT)) && ((parent.getType()) != (com.google.javascript.rhino.Token.BLOCK))) {\n                 if ((((parent.getType()) == (com.google.javascript.rhino.Token.FOR)) && ((parent.getChildCount()) == 4)) && ((n == (parent.getFirstChild())) ||\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -897,7 +897,7 @@\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+        } else if (org.joda.time.DateTimeZone.this.iID!=null) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Chart",
        "content": "@@ -941,7 +941,7 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < startIndex) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -188,23 +188,10 @@ public class ClassUtils {\n             return StringUtils.EMPTY;\n         }\n \n-        StringBuffer arrayPrefix = new StringBuffer();\n \n         // Handle array encoding\n-        if (className.startsWith(\"[\")) {\n-            while (className.charAt(0) == '[') {\n-                className = className.substring(1);\n-                arrayPrefix.append(\"[]\");\n-            }\n             // Strip Object type encoding\n-            if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-                className = className.substring(1, className.length() - 1);\n-            }\n-        }\n \n-        if (reverseAbbreviationMap.containsKey(className)) {\n-            className = reverseAbbreviationMap.get(className);\n-        }\n \n         int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         int innerIdx = className.indexOf(\n@@ -213,7 +200,7 @@ public class ClassUtils {\n         if (innerIdx != -1) {\n             out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n         }\n-        return out + arrayPrefix;\n+        return out;\n     }\n \n     // Package name\n@@ -255,18 +242,12 @@ public class ClassUtils {\n      * @return the package name or an empty string\n      */\n     public static String getPackageName(String className) {\n-        if (className == null || className.length() == 0) {\n+        if (className == null) {\n             return StringUtils.EMPTY;\n         }\n \n         // Strip array encoding\n-        while (className.charAt(0) == '[') {\n-            className = className.substring(1);\n-        }\n         // Strip Object type encoding\n-        if (className.charAt(0) == 'L' && className.charAt(className.length() - 1) == ';') {\n-            className = className.substring(1);\n-        }\n \n         int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n         if (i == -1) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -2535,7 +2535,7 @@\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (this.rangeGridlinesVisible || b2) {\n             return;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -37,7 +37,7 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n     public int translate(CharSequence input, int index, Writer out) throws IOException {\n         int seqEnd = input.length();\n         // Uses -2 to ensure there is something after the &#\n-        if(input.charAt(index) == '&' && index < seqEnd - 2 && input.charAt(index + 1) == '#') {\n+        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n             int start = index + 2;\n             boolean isHex = false;\n \n@@ -47,16 +47,11 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 isHex = true;\n \n                 // Check there's more than just an x after the &#\n-                if(start == seqEnd) {\n-                    return 0;\n-                }\n             }\n \n             int end = start;\n             // Note that this supports character codes without a ; on the end\n-            while(end < seqEnd && ( (input.charAt(end) >= '0' && input.charAt(end) <= '9') ||\n-                                    (input.charAt(end) >= 'a' && input.charAt(end) <= 'f') ||\n-                                    (input.charAt(end) >= 'A' && input.charAt(end) <= 'F') ) )\n+            while(input.charAt(end) != ';') \n             {\n                 end++;\n             }\n@@ -81,9 +76,8 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n                 out.write(entityValue);\n             }\n \n-            boolean semiNext = (end != seqEnd) && (input.charAt(end) == ';');\n \n-            return 2 + (end - start) + (isHex ? 1 : 0) + (semiNext ? 1 : 0);\n+            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n         }\n         return 0;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -2462,7 +2462,7 @@\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.isToStringMethodCall(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -1777,7 +1777,7 @@\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n-                if (str.charAt(j) != thisBuf[i + j]) {\n+            \tif (str.charAt(j) != thisBuf[i + j] || (i + j >= length()) == true) {\n                     continue outer;\n                 }\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -549,7 +549,7 @@\n      * @return The index.\n      */\n     public int getMaxMiddleIndex() {\n-        return this.maxMiddleIndex;\n+        return this.maxStartIndex;\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -185,7 +185,7 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * ((int)x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Chart",
        "content": "@@ -1042,7 +1042,8 @@\n             result = (ValueAxis) this.rangeAxes.get(index);\n         }\n         if (result == null) {\n-            Plot parent = getParent();\n+            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n+\t\t\tPlot parent = getParent();\n             if (parent instanceof CategoryPlot) {\n                 CategoryPlot cp = (CategoryPlot) parent;\n                 result = cp.getRangeAxis(index);\n@@ -1349,7 +1350,8 @@\n      */\n     public void setDataset(int index, CategoryDataset dataset) {\n \n-        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n+        Object result = null;\n+        CategoryDataset existing = (CategoryDataset) this.datasets.get(index);\n         if (existing != null) {\n             existing.removeChangeListener(this);\n         }\n\n\n@@ -1795,7 +1795,7 @@\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n         if (dataset != null) {\n-            return result;\n+            Paint outlinePaint = plot.getOutlinePaint();\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -82,10 +82,12 @@\n             return false;\n         }\n         for (int i = 0; i < point.length; i++) {\n+            if (((otherPoint[i])) != (otherPoint.length)) {\n             if (point[i] != otherPoint[i]) {\n                 return false;\n             }\n         }\n+        }\n         return true;\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -204,8 +204,8 @@ public class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n \n             }\n             else {\n-                this.seriesKeys = new Comparable[0];\n-                this.categoryKeys = new Comparable[0];\n+                this.seriesKeys = null;\n+                this.categoryKeys = null;\n             }\n         }\n \n@@ -335,7 +335,7 @@ public class DefaultIntervalCategoryDataset extends AbstractSeriesDataset\n         if (categoryKeys == null) {\n             throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n         }\n-        if (categoryKeys.length != getCategoryCount()) {\n+        if (categoryKeys.length != this.startData[0].length) {\n             throw new IllegalArgumentException(\n                     \"The number of categories does not match the data.\");\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -944,6 +944,9 @@\n         if (endIndex < 0) {\n             emptyRange = true;\n         }\n+        if((startIndex == 1) == true){\n+        \treturn this;\n+        \t}\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -125,7 +125,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n       AbstractPostOrderCallback {\n \n     private int scriptNodeCount = 0;\n-    private Set<String> modulesWithExports = Sets.newHashSet();\n \n     @Override\n     public void visit(NodeTraversal t, Node n, Node parent) {\n@@ -205,9 +204,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n      */\n     private void emitOptionalModuleExportsOverride(Node script,\n         String moduleName) {\n-      if (!modulesWithExports.contains(moduleName)) {\n-        return;\n-      }\n \n       Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n           IR.string(\"module$exports\"));\n@@ -229,7 +225,6 @@ public class ProcessCommonJSModules implements CompilerPass {\n       Node exports = prop.getChildAtIndex(1);\n       exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n       exports.setString(\"module$exports\");\n-      modulesWithExports.add(moduleName);\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> 0.0)&&((fa*fb)> 0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -1534,7 +1534,7 @@\n                 double b1 = work[np - 2];\n                 double b2 = work[np - 6];\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                     return;\n                 }\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -184,6 +184,10 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+                    if (x == x1) {\n+                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        f0 = computeObjectiveValue(x0);\n+                    }\n                     break;\n                 default:\n                     // Should never happen.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Lang",
        "content": "@@ -607,9 +607,14 @@\n         if (str == null) {\n             return null;\n         }\n+        if((lower > str.length()) == true){\n+        \tlower=str.length();\n+\n+        \t}else{\n         if (str.length() == 0) {\n             return StringUtils.EMPTY;\n         }\n+        \t}\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Closure",
        "content": "@@ -1757,9 +1757,17 @@\n   private Node parseFunctionType(JsDocToken token) {\n     // NOTE(nicksantos): We're not implementing generics at the moment, so\n     // just throw out TypeParameters.\n+    // start of generated patch\n     if (token != JsDocToken.LP) {\n+      restoreLookAhead(token);\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n     }\n+    // end of generated patch\n+    /* start of original code\n+        if (token != JsDocToken.LP) {\n+          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n+        }\n+     end of original code*/\n \n     Node functionType = newNode(Token.FUNCTION);\n     Node parameters = null;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -90,7 +90,7 @@\n      * @return the number of evaluations of the objective function.\n      */\n     public int getIterations() {\n-        return iterations.getCount();\n+        return this.evaluations.getCount();\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -445,6 +445,7 @@\n         if (str == null) {\n             return null;\n         }\n+        str=str.toLowerCase();\n         if (StringUtils.isBlank(str)) {\n             throw new NumberFormatException(\"A blank string is not a valid number\");\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -59,7 +59,7 @@\n         double minValue = 0;\n         Integer minPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n-            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), this.epsilon, epsilon) < 0) {\n                 minValue = tableau.getEntry(0, i);\n                 minPos = i;\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Math",
        "content": "@@ -87,7 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (true) {\n                 // accept the contracted simplex\n \n             // check convergence\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -1187,6 +1187,7 @@\n                     + insets.getRight());\n \n         }\n+        hotspot=null;\n         if (plotState != null && hotspot != null) {\n             ChartRenderingInfo owner = plotState.getOwner();\n                 EntityCollection entities = owner.getEntityCollection();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -1670,7 +1670,7 @@ public class StrBuilder implements Cloneable {\n      */\n     public boolean contains(char ch) {\n         char[] thisBuf = buffer;\n-        for (int i = 0; i < this.size; i++) {\n+        for (int i = 0; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return true;\n             }\n@@ -1727,7 +1727,7 @@ public class StrBuilder implements Cloneable {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        for (int i = startIndex; i < size; i++) {\n+        for (int i = startIndex; i < thisBuf.length; i++) {\n             if (thisBuf[i] == ch) {\n                 return i;\n             }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1136,7 +1136,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + 1] = work[j - k];\n                     work[j - k] = tmp;\n                 }\n                 j -= 4;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -2290,7 +2290,7 @@\n             markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                     index));\n         }\n-        boolean removed = markers.remove(marker);\n+        boolean removed = this.annotations.remove(marker);\n         if (removed && notify) {\n             fireChangeEvent();\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Math",
        "content": "@@ -97,7 +97,8 @@\n      */\n     public double inverseCumulativeProbability(final double p) \n         throws MathException {\n-        if (p == 0) {\n+        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+        if (p == 0) {\n             return 0d;\n         }\n         if (p == 1) {\n@@ -145,7 +146,7 @@\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n-        return ret;\n+        return 0;\n     }\n     \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -148,7 +148,6 @@\n                         }\n                     }\n                 }\n-                return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -929,7 +929,7 @@ public class CMAESOptimizer\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = x[i] / diff;\n+                res[i] = (x[i] - boundaries[0][i]) / diff;\n             }\n             return res;\n         }\n@@ -955,7 +955,7 @@ public class CMAESOptimizer\n             double[] res = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n                 double diff = boundaries[1][i] - boundaries[0][i];\n-                res[i] = diff * x[i];\n+                res[i] = diff * x[i] + boundaries[0][i];\n             }\n             return res;\n         }\n@@ -987,14 +987,12 @@ public class CMAESOptimizer\n                 return true;\n             }\n \n-            final double[] bLoEnc = encode(boundaries[0]);\n-            final double[] bHiEnc = encode(boundaries[1]);\n \n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < bLoEnc[i]) {\n+                if (x[i] < 0) {\n                     return false;\n                 }\n-                if (x[i] > bHiEnc[i]) {\n+                if (x[i] > 1.0) {\n                     return false;\n                 }\n             }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -703,3 +703,5 @@\n             double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n-            oldFac += 1. - ccov1 - ccovmu;\n+            if (org.apache.commons.math3.optimization.direct.CMAESOptimizer.this.inputSigma!=null) {\n+                oldFac += 1. - ccov1 - ccovmu;\n+            }\n             if (isActiveCMA) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -540,7 +540,7 @@\n         int u = p;\n         int v = q;\n         if ((u == 0) || (v == 0)) {\n-            return (Math.abs(u) + Math.abs(v));\n+if (u==Integer.MIN_VALUE){throw new ArithmeticException();}if (v==Integer.MIN_VALUE){throw new ArithmeticException();}            return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n@@ -711,7 +711,7 @@\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        return lcm;\n+if (lcm==Integer.MIN_VALUE){throw new ArithmeticException();}        return lcm;\n     }\n \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Math",
        "content": "@@ -92,7 +92,7 @@\n \n \n                 return;\n-            }\n+            }             return;\n \n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -315,7 +315,9 @@ public class DefaultKeyedValues implements KeyedValues,\n     public void removeValue(int index) {\n         this.keys.remove(index);\n         this.values.remove(index);\n+        if (index < this.keys.size()) {\n         rebuildIndex();\n+        }\n     }\n \n     /**\n@@ -330,8 +332,7 @@ public class DefaultKeyedValues implements KeyedValues,\n     public void removeValue(Comparable key) {\n         int index = getIndex(key);\n         if (index < 0) {\n-            throw new UnknownKeyException(\"The key (\" + key \n-                    + \") is not recognised.\");\n+\t\t\treturn;\n         }\n         removeValue(index);\n     }\n@@ -452,19 +452,10 @@ public class DefaultKeyedValues2D implements KeyedValues2D,\n      * @see #removeRow(Comparable)\n      */\n     public void removeColumn(Comparable columnKey) {\n-    \tif (columnKey == null) {\n-    \t\tthrow new IllegalArgumentException(\"Null 'columnKey' argument.\");\n-    \t}\n-    \tif (!this.columnKeys.contains(columnKey)) {\n-    \t\tthrow new UnknownKeyException(\"Unknown key: \" + columnKey);\n-    \t}\n         Iterator iterator = this.rows.iterator();\n         while (iterator.hasNext()) {\n             DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n-            int index = rowData.getIndex(columnKey);\n-            if (index >= 0) {\n                 rowData.removeValue(columnKey);\n-            }\n         }\n         this.columnKeys.remove(columnKey);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -3645,6 +3645,7 @@\n             if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n                 searchList[i].length() == 0 || replacementList[i] == null) \n             {\n+  if (replaceIndex==0.0){return \"cbc\";}\n                 continue;\n             }\n             tempIndex = text.indexOf(searchList[i]);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -89,9 +89,6 @@ public class LocaleUtils {\n         if (str == null) {\n             return null;\n         }\n-        if (str.contains(\"#\")) { // LANG-879 - Cannot handle Java 7 script & extensions\n-            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n-        }\n         final int len = str.length();\n         if (len < 2) {\n             throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Closure",
        "content": "@@ -2462,7 +2462,7 @@\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return NodeUtil.evaluatesToLocalValue(value.getFirstChild());\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -2535,7 +2535,7 @@\n         // if the plot area is too small, just return...\n         boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n         boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n-        if (b1 || b2) {\n+        if (b1 || (getRenderer() != null)) {\n             return;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -302,7 +302,7 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return org.apache.commons.math3.complex.Complex.INF;\n         }\n \n         if (isInfinite) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * pingPong - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Closure",
        "content": "@@ -1042,7 +1042,7 @@\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1583,7 +1583,7 @@\n             break;\n \n         case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n-            if (dMin1 == dN1 && dMin2 == dN2) {\n+            if (org.apache.commons.math.linear.EigenDecompositionImpl.this.main!=null) {\n \n                 // cases 7 and 8.\n                 tType = -7;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -1540,7 +1540,8 @@\n                 double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n \n                 // approximate contribution to norm squared from i < nn-2.\n-                if (end - start > 2) {\n+  if (end - start > 2&&!(end - start>=(double)0.0)) {\n+\n                     b2 = work[nn - 13] / work[nn - 15];\n                     a2 = a2 + b2;\n                     for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -944,6 +944,9 @@\n         if (endIndex < 0) {\n             emptyRange = true;\n         }\n+        if((endIndex > startIndex) == false){\n+        \tstartIndex=endIndex;\n+        \t}\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Closure",
        "content": "@@ -727,7 +727,7 @@\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+          if ((!isDirectCallNodeReplacementPossible(fnNode)) && NodeUtil.canBeSideEffected(cArg)) {\n             return CanInlineResult.NO;\n           }\n           // Check for arguments that are evaluated more than once.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -604,3 +604,5 @@\n             }\n-            sum2 = 0;\n+            if (this.costRelativeTolerance != this.orthoTolerance) {\n+                sum2 = 0;\n+            }\n             for (int j = 0; j < solvedCols; ++j) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Chart",
        "content": "@@ -206,10 +206,12 @@\n         PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n+        if (false) {\n+            if (orientation == PlotOrientation.HORIZONTAL) {\n+                drawHorizontalItem(g2, state, dataArea, plot, domainAxis,\n+                rangeAxis, statData, row, column);\n+            }\n+            else if (orientation == PlotOrientation.VERTICAL) {\n+                drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis,\n+                statData, row, column);\n+            }\n         }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -329,10 +329,7 @@\n       }\n     }\n \n-    if (s.length() > 3\n-        && (s.charAt(0) == '-' || s.charAt(0) == '+')\n-        && s.charAt(1) == '0'\n-        && (s.charAt(2) == 'x' || s.charAt(2) == 'X')) {\n+    if (true) {\n       // hex numbers with explicit signs vary between browsers.\n       return null;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/jGenProg/Math",
        "content": "@@ -302,23 +302,6 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n-        }\n-\n-        if (isInfinite) {\n-            return ZERO;\n-        }\n-\n-        if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n-            double q = real / imaginary;\n-            double scale = 1. / (real * q + imaginary);\n-            return createComplex(scale * q, -scale);\n-        } else {\n-            double q = imaginary / real;\n-            double scale = 1. / (imaginary * q + real);\n-            return createComplex(scale, -scale * q);\n-        }\n-    }\n \n     /**\n      * Test for the equality of two Complex objects.\n@@ -335,21 +318,6 @@\n      * {@code null}, not an instance of Complex, or not equal to this Complex\n      * instance.\n      */\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (other instanceof Complex){\n-            Complex c = (Complex)other;\n-            if (c.isNaN) {\n-                return isNaN;\n-            } else {\n-                return (real == c.real) && (imaginary == c.imaginary);\n-            }\n-        }\n-        return false;\n-    }\n \n     /**\n      * Get a hashCode for the complex number.\n@@ -358,32 +326,18 @@\n      *\n      * @return a hash code value for this object.\n      */\n-    @Override\n-    public int hashCode() {\n-        if (isNaN) {\n-            return 7;\n-        }\n-        return 37 * (17 * MathUtils.hash(imaginary) +\n-            MathUtils.hash(real));\n-    }\n \n     /**\n      * Access the imaginary part.\n      *\n      * @return the imaginary part.\n      */\n-    public double getImaginary() {\n-        return imaginary;\n-    }\n \n     /**\n      * Access the real part.\n      *\n      * @return the real part.\n      */\n-    public double getReal() {\n-        return real;\n-    }\n \n     /**\n      * Checks whether either or both parts of this complex number is\n@@ -392,9 +346,6 @@\n      * @return true if either or both parts of this complex number is\n      * {@code NaN}; false otherwise.\n      */\n-    public boolean isNaN() {\n-        return isNaN;\n-    }\n \n     /**\n      * Checks whether either the real or imaginary part of this complex number\n@@ -405,9 +356,6 @@\n      * @return true if one or both parts of this complex number are infinite\n      * and neither part is {@code NaN}.\n      */\n-    public boolean isInfinite() {\n-        return isInfinite;\n-    }\n \n     /**\n      * Returns a {@code Complex} whose value is {@code this * factor}.\n@@ -433,18 +381,8 @@\n      * @return {@code this * factor}.\n      * @throws NullArgumentException if {@code factor} is {@code null}.\n      */\n-    public Complex multiply(Complex factor)\n-        throws NullArgumentException {\n-        MathUtils.checkNotNull(factor);\n-        if (isNaN || factor.isNaN) {\n-            return NaN;\n-        }\n-        if (Double.isInfinite(real) ||\n-            Double.isInfinite(imaginary) ||\n-            Double.isInfinite(factor.real) ||\n-            Double.isInfinite(factor.imaginary)) {\n             // we don't use isInfinite() to avoid testing for NaN again\n-            return INF;\n+            return org.apache.commons.math3.complex.Complex.INF;}     if (isInfinite) {             return org.apache.commons.math3.complex.Complex.ZERO;}         if ((org.apache.commons.math3.util.FastMath.abs(real)) < (org.apache.commons.math3.util.FastMath.abs(imaginary))) {             double q = (real) / (imaginary);             double scale = 1.0 / (((real) * q) + (imaginary));             return createComplex((scale * q), (-scale));}else {             double q = (imaginary) / (real);     double scale = 1.0 / (((imaginary) * q) + (real));             return createComplex(scale, ((-scale) * q));}}     @java.lang.Override     public boolean equals(java.lang.Object other) {         if ((this) == other) {         return true;}         if (other instanceof org.apache.commons.math3.complex.Complex) {             org.apache.commons.math3.complex.Complex c = ((org.apache.commons.math3.complex.Complex) (other));             if (c.isNaN) {                 return isNaN;}else {                 return ((real) == (c.real)) && ((imaginary) == (c.imaginary));}}         return false;}     @java.lang.Override     public int hashCode() {         if (isNaN) {             return 7;}         return 37 * ((17 * (org.apache.commons.math3.util.MathUtils.hash(imaginary))) + (org.apache.commons.math3.util.MathUtils.hash(real)));}     public double getImaginary() {         return imaginary;}     public double getReal() {         return real;}     public boolean isNaN() {         return isNaN;}     public boolean isInfinite() {         return isInfinite;}     public org.apache.commons.math3.complex.Complex multiply(org.apache.commons.math3.complex.Complex factor) throws org.apache.commons.math3.exception.NullArgumentException {         org.apache.commons.math3.util.MathUtils.checkNotNull(factor);         if ((isNaN) || (factor.isNaN)) {             return org.apache.commons.math3.complex.Complex.NaN;}         if ((((java.lang.Double.isInfinite(real)) || (java.lang.Double.isInfinite(imaginary))) || (java.lang.Double.isInfinite(factor.real))) || (java.lang.Double.isInfinite(factor.imaginary))) {             return org.apache.commons.math3.complex.Complex.INF;\n         }\n         return createComplex(real * factor.real - imaginary * factor.imaginary,\n                              real * factor.imaginary + imaginary * factor.real);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -302,6 +302,9 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n+        \tif((real == 0.0 && imaginary == 0.0) == true){\n+        \t\treturn this.INF;\n+        \t\t}\n             return NaN;\n         }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SketchFix/Closure",
        "content": "@@ -138,7 +138,7 @@\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (NodeUtil.hasFinally(n)&&allCatchNodes == tryBlock) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -144,7 +144,7 @@\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n-            ret = d / (d - 2.0);\n+            ret = d / (d + 2.0);\n         return ret;\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -196,12 +196,6 @@\n                 ((a > lowerBound) || (b < upperBound)));\n    \n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n         }\n         \n         return new double[]{a, b};\n\n\n@@ -97,9 +97,6 @@\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n             }\n-            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n-                return upperBound;\n-            }     \n             // Failed bracket convergence was not because of corner solution\n             throw new MathException(ex);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -191,13 +191,11 @@ abstract class CodeConsumer {\n       // need space to separate. This is not pretty printing.\n       // For example: \"return foo;\"\n       append(\" \");\n-    } else if (c == '/' && getLastChar() == '/') {\n       // Do not allow a forward slash to appear after a DIV.\n       // For example,\n       // REGEXP DIV REGEXP\n       // is valid and should print like\n       // / // / /\n-      append(\" \");\n     }\n \n     append(newcode);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -277,6 +277,7 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n             double previousT = interpolator.getGlobalPreviousTime();\n             final double currentT = interpolator.getGlobalCurrentTime();\n+            resetOccurred = false;\n \n             // initialize the events states if needed\n             if (! statesInitialized) {\n@@ -330,9 +331,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n@@ -342,9 +340,6 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                     System.arraycopy(eventY, 0, y, 0, y.length);\n                     computeDerivatives(eventT, y, yDot);\n                     resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n                     return eventT;\n                 }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -694,15 +694,6 @@ class FunctionInjector {\n \n     Node block = fnNode.getLastChild();\n \n-    boolean hasSideEffects = false;  // empty function case\n-    if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(\n-            stmt.getFirstChild(), compiler);\n-      }\n-    }\n \n     // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n     Node cArg = callNode.getFirstChild().getNext();\n@@ -729,9 +720,6 @@ class FunctionInjector {\n       // For each named parameter check if a mutable argument use more than one.\n       if (fnParam != null) {\n         if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n \n           // Check for arguments that are evaluated more than once.\n           // Note: Unlike block inlining, there it is not possible that a\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Math",
        "content": "@@ -136,7 +136,7 @@\n         this.epsilon = epsilon;\n         for (int key = 0; key < values.length; key++) {\n             double value = values[key];\n-            if (!isDefaultValue(value)) {\n+            if (true) {\n                 entries.put(key, value);\n             }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Lang",
        "content": "@@ -229,7 +229,7 @@\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getPackageName(cls.getName());\n+        return getPackageCanonicalName(cls.getName());\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -159,27 +159,24 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio\n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[m][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p; ++i) {\n+                for (int i = 0; i < p - 1; ++i) {\n                     // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    if (i < n - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                    } else {\n+                }\n                         for (int j = 0; j < p; ++j) {\n-                            wi[j] = mi * ei0[j] / singularValues[j];\n+                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n-                    }\n-                }\n \n                 for (int i = p; i < m; ++i) {\n                     wData[i] = new double[p];\n@@ -248,26 +245,23 @@ public class SingularValueDecompositionImpl implements SingularValueDecompositio\n                 // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                 // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                 final RealMatrix e =\n-                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n+                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                 final double[][] eData = e.getData();\n                 final double[][] wData = new double[n][p];\n                 double[] ei1 = eData[0];\n-                for (int i = 0; i < p; ++i) {\n+                for (int i = 0; i < p - 1; ++i) {\n                     final double mi = mainBidiagonal[i];\n                     final double[] ei0 = ei1;\n                     final double[] wi  = wData[i];\n-                    if (i < m - 1) {\n                         ei1 = eData[i + 1];\n                         final double si = secondaryBidiagonal[i];\n                         for (int j = 0; j < p; ++j) {\n                             wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                         }\n-                    } else {\n+                }\n                         for (int j = 0; j < p; ++j) {\n-                            wi[j] = mi * ei0[j] / singularValues[j];\n+                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                         }\n-                    }\n-                }\n                 for (int i = p; i < n; ++i) {\n                     wData[i] = new double[p];\n                 }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -207,7 +207,7 @@\n             return values;\n         }\n             // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        if ((!(((fieldIndex) != (1)) && (valueToAdd <= values.length))) || (valueToAdd < -1)) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {\n                 instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -199,3 +199,5 @@\n         if (FastMath.abs(d) < 1.0e-10) {\n-            return null;\n+            if (((other.sin < 1) && (other.sin < 1)) || ((org.apache.commons.math3.geometry.euclidean.twod.Line.this.originOffset) != (d))) {\n+                return null;\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1355,14 +1355,12 @@ public final class JsDocInfoParser {\n     // Track the start of the line to count whitespace that\n     // the tokenizer skipped. Because this case is rare, it's easier\n     // to do this here than in the tokenizer.\n-    int lineStartChar = -1;\n \n     do {\n       switch (token) {\n         case STAR:\n           if (ignoreStar) {\n             // Mark the position after the star as the new start of the line.\n-            lineStartChar = stream.getCharno() + 1;\n           } else {\n             // The star is part of the comment.\n             if (builder.length() > 0) {\n@@ -1381,7 +1379,6 @@ public final class JsDocInfoParser {\n           }\n \n           ignoreStar = true;\n-          lineStartChar = 0;\n           token = next();\n           continue;\n \n@@ -1389,19 +1386,7 @@ public final class JsDocInfoParser {\n           ignoreStar = false;\n           state = State.SEARCHING_ANNOTATION;\n \n-          boolean isEOC = token == JsDocToken.EOC;\n-          if (!isEOC) {\n-            if (lineStartChar != -1 && option == WhitespaceOption.PRESERVE) {\n-              int numSpaces = stream.getCharno() - lineStartChar;\n-              for (int i = 0; i < numSpaces; i++) {\n-                builder.append(' ');\n-              }\n-              lineStartChar = -1;\n-            } else if (builder.length() > 0) {\n               // All tokens must be separated by a space.\n-              builder.append(' ');\n-            }\n-          }\n \n           if (token == JsDocToken.EOC ||\n               token == JsDocToken.EOF ||\n@@ -1426,6 +1411,9 @@ public final class JsDocInfoParser {\n             return new ExtractionInfo(multilineText, token);\n           }\n \n+          if (builder.length() > 0) {\n+            builder.append(' ');\n+          }\n           builder.append(toString(token));\n \n           line = stream.getRemainingJSDocLine();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -107,8 +107,6 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public void addValue(Object v) {\n-        addValue((Comparable<?>) v);\n-    }\n     \n     /**\n      * Adds 1 to the frequency count for v.\n@@ -120,7 +118,6 @@ public class Frequency implements Serializable {\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n-    public void addValue(Comparable<?>v){\n         Object obj = v;\n         if (v instanceof Integer) {\n            obj = Long.valueOf(((Integer) v).longValue());\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb > 0.0 || fa * fb >= 0.0) != true) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Lang",
        "content": "@@ -619,7 +619,7 @@\n             upper = str.length();\n         }\n         // if upper is less than lower, raise it to lower\n-        if (upper < lower) {\n+        if((lower+(upper-3))<lower){\n             upper = lower;\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -449,10 +449,10 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n-                    if (dec == null\n+                    if (dec != numeric || (dec == null\n                         && exp == null\n                         && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0))))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -101,7 +101,12 @@ public class HashCodeBuilder {\n      * \n      * @since 2.3\n      */\n-    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>();\n+    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n+        @Override\n+        protected Set<IDKey> initialValue() {\n+            return new HashSet<IDKey>();\n+        }\n+    };\n \n     /*\n      * N.B. we cannot store the actual objects in a HashSet, as that would use the very hashCode()\n@@ -144,8 +149,7 @@ public class HashCodeBuilder {\n      * @since 2.3\n      */\n     static boolean isRegistered(Object value) {\n-        Set<IDKey> registry = getRegistry();\n-        return registry != null && registry.contains(new IDKey(value));\n+        return getRegistry().contains(new IDKey(value));\n     }\n \n     /**\n@@ -515,11 +519,6 @@ public class HashCodeBuilder {\n      *            The object to register.\n      */\n     static void register(Object value) {\n-        synchronized (HashCodeBuilder.class) {\n-            if (getRegistry() == null) {\n-                REGISTRY.set(new HashSet<IDKey>());\n-            }\n-        }\n         getRegistry().add(new IDKey(value));\n     }\n \n@@ -536,15 +535,7 @@ public class HashCodeBuilder {\n      * @since 2.3\n      */\n     static void unregister(Object value) {\n-        Set<IDKey> s = getRegistry();\n-        if (s != null) {\n-            s.remove(new IDKey(value));\n-            synchronized (HashCodeBuilder.class) {\n-                if (s.isEmpty()) {\n-                    REGISTRY.remove();\n-                }\n-            }\n-        }\n+        getRegistry().remove(new IDKey(value));\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa> fb)&&((fa*fb)>=0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Lang",
        "content": "@@ -485,7 +485,7 @@\n             }\n             mant = str.substring(0, decPos);\n         } else {\n-            if (expPos > -1) {\n+            if (expPos < -1) {\n                 if (expPos > str.length()) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1259,7 +1259,6 @@ public final class NodeUtil {\n       // Inversion\n       case Token.NOT:\n       // delete operator returns a boolean.\n-      case Token.DELPROP:\n         return true;\n       default:\n         return false;\n@@ -2908,7 +2907,6 @@ public final class NodeUtil {\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n         return true;\n-      case Token.DELPROP:\n       case Token.IN:\n         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n         return true;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -1144,7 +1144,7 @@\n   private static void resolvedTemplateType(\n       Map<TemplateType, JSType> map, TemplateType template, JSType resolved) {\n     JSType previous = map.get(template);\n-    if (!resolved.isUnknownType()) {\n+    if (false) {\n       if (previous == null) {\n         map.put(template, resolved);\n       } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SketchFix/Chart",
        "content": "@@ -941,7 +941,7 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < 0 || (endIndex < startIndex)) {\n             emptyRange = true;\n         }\n         if (emptyRange) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Lang",
        "content": "@@ -581,7 +581,7 @@\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u)==1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal >= 0) {\n+        } else if (offsetLocal > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Arja/Closure",
        "content": "@@ -134,14 +134,6 @@\n         Node catchCodeBlock = catchNode.getLastChild();\n         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n     }\n \n     // Just a 'label'.\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -85,7 +85,6 @@\n       // Estimate savings\n       int savings = 0;\n       for (Reduction reduction : reductions) {\n-        savings += reduction.estimateSavings();\n       }\n \n       // Compare estimated savings against the helper cost.  Apply\n@@ -114,7 +113,7 @@\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+    return false;\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -907,7 +907,12 @@\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+        \tif((array[i] == classes[i]) == true){\n+        \t\tclasses[i]=null;\n+\n+        \t\t}else{\n+        \t\tclasses[i]=array[i].getClass();\n+        \t\t}\n         }\n         return classes;\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Math",
        "content": "@@ -185,7 +185,7 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 += 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -328,9 +328,6 @@ class InlineObjectLiterals implements CompilerPass {\n       }\n \n       Node replacement;\n-      if (nodes.isEmpty()) {\n-        replacement = new Node(Token.TRUE);\n-      } else {\n         // All assignments evaluate to true, so make sure that the\n         // expr statement evaluates to true in case it matters.\n         nodes.add(new Node(Token.TRUE));\n@@ -350,7 +347,6 @@ class InlineObjectLiterals implements CompilerPass {\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n-      }\n \n       Node replace = ref.getParent();\n       replacement.copyInformationFromForTree(replace);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -963,7 +963,6 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -114,7 +114,6 @@\n \n     if (!collapses.isEmpty()) {\n       applyCollapses();\n-      compiler.reportCodeChange();\n     }\n   }\n \n@@ -207,40 +206,5 @@\n \n \n   private void applyCollapses() {\n-    for (Collapse collapse : collapses) {\n-\n-      Node var = new Node(Token.VAR);\n-      var.copyInformationFrom(collapse.startNode);\n-      collapse.parent.addChildBefore(var, collapse.startNode);\n-\n-      boolean redeclaration = false;\n-      for (Node n = collapse.startNode; n != collapse.endNode;) {\n-        Node next = n.getNext();\n-\n-        Preconditions.checkState(var.getNext() == n);\n-        collapse.parent.removeChildAfter(var);\n-\n-        if (n.isVar()) {\n-          while(n.hasChildren()) {\n-            var.addChildToBack(n.removeFirstChild());\n-          }\n-        } else {\n-          Node assign = n.getFirstChild();\n-          Node lhs = assign.getFirstChild();\n-          Preconditions.checkState(lhs.isName());\n-          Node rhs = assign.getLastChild();\n-          lhs.addChildToBack(rhs.detachFromParent());\n-          var.addChildToBack(lhs.detachFromParent());\n-          redeclaration = true;\n-        }\n-        n = next;\n-      }\n-\n-      if (redeclaration) {\n-        JSDocInfo info = new JSDocInfo();\n-        info.addSuppression(\"duplicate\");\n-        var.setJSDocInfo(info);\n-      }\n-    }\n   }\n }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Lang",
        "content": "@@ -881,7 +881,7 @@\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, width, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/TBar/Lang",
        "content": "@@ -1183,7 +1183,8 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n-            int strLen = str.length();\n+            if (str == null) str = new String();\n+ int strLen = str.length();\n             if (strLen >= width) {\n                 str.getChars(strLen - width, strLen, buffer, size);\n             } else {\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SequenceR/Math",
        "content": "@@ -302,7 +302,7 @@\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return Complex.INF;\n         }\n \n         if (isInfinite) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -344,9 +344,11 @@\n         for (int i = 0; i < getNumArtificialVariables(); i++) {\n           int col = i + getArtificialVariableOffset();\n           if (getBasicRow(col) == null) {\n+            if (1 <= org.apache.commons.math.optimization.linear.SimplexTableau.this.numSlackVariables) {\n             columnsToDrop.add(col);\n           }\n         }\n+        }\n \n         double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n         for (int i = 1; i < getHeight(); i++) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Closure",
        "content": "@@ -1543,7 +1543,7 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        return (false) || !(recur);\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Lang",
        "content": "@@ -419,6 +419,7 @@\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n         if (escapingOn && c[start] == QUOTE) {\n+            next(pos);\n             return appendTo == null ? null : appendTo.append(QUOTE);\n         }\n         int lastHold = start;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -242,10 +242,6 @@ public class RandomStringUtils {\n                     start = ' ';                \n                 }\n             }\n-        } else {\n-            if (end <= start) {\n-                throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\");\n-            }\n         }\n \n         char[] buffer = new char[count];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -83,7 +83,6 @@\n   public void process(Node externs, Node root) {\n     ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n         compiler, new InliningBehavior(), getFilterForMode());\n-    callback.process(externs, root);\n   }\n \n   private Predicate<Var> getFilterForMode() {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -338,3 +338,5 @@\n             if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n-                columnsToDrop.add(i);\n+                if ((2) != (org.apache.commons.math3.optimization.linear.SimplexTableau.this.numArtificialVariables)) {\n+                    columnsToDrop.add(i);\n+                }\n             }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -214,8 +214,10 @@\n             for (int i = begin; i < begin + length; i++) {\n                 correction += weights[i] * (values[i] - xbarw);\n             }\n+            if (xbarw < length) {\n             return xbarw + (correction/sumw);\n         }\n+        }\n         return Double.NaN;\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -636,9 +636,7 @@ public class MutableDateTime\n         if (type == null) {\n             throw new IllegalArgumentException(\"Field must not be null\");\n         }\n-        if (amount != 0) {\n             setMillis(type.getField(getChronology()).add(getMillis(), amount));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -659,9 +657,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addYears(final int years) {\n-        if (years != 0) {\n             setMillis(getChronology().years().add(getMillis(), years));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -682,9 +678,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeekyears(final int weekyears) {\n-        if (weekyears != 0) {\n             setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -705,9 +699,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMonths(final int months) {\n-        if (months != 0) {\n             setMillis(getChronology().months().add(getMillis(), months));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -728,9 +720,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addWeeks(final int weeks) {\n-        if (weeks != 0) {\n             setMillis(getChronology().weeks().add(getMillis(), weeks));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -771,9 +761,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addDays(final int days) {\n-        if (days != 0) {\n             setMillis(getChronology().days().add(getMillis(), days));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -794,9 +782,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addHours(final int hours) {\n-        if (hours != 0) {\n             setMillis(getChronology().hours().add(getMillis(), hours));\n-        }\n     }\n     \n     //-----------------------------------------------------------------------\n@@ -827,9 +813,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMinutes(final int minutes) {\n-        if (minutes != 0) {\n             setMillis(getChronology().minutes().add(getMillis(), minutes));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -860,9 +844,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addSeconds(final int seconds) {\n-        if (seconds != 0) {\n             setMillis(getChronology().seconds().add(getMillis(), seconds));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n@@ -895,9 +877,7 @@ public class MutableDateTime\n      * @throws IllegalArgumentException if the value is invalid\n      */\n     public void addMillis(final int millis) {\n-        if (millis != 0) {\n             setMillis(getChronology().millis().add(getMillis(), millis));\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -180,7 +180,7 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n+        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Chart",
        "content": "@@ -342,6 +342,9 @@\n      */\n     public void removeRow(Comparable rowKey) {\n         int index = getRowIndex(rowKey);\n+        if(index<0){\n+            throw new UnknownKeyException(\"The key (\"+rowKey.toString());\n+        }\n         removeRow(index);\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -96,13 +96,6 @@ final class CheckGlobalThis implements Callback {\n       // var a = function() { }; // or\n       // function a() {} // or\n       // a.x = function() {};\n-      int pType = parent.getType();\n-      if (!(pType == Token.BLOCK ||\n-            pType == Token.SCRIPT ||\n-            pType == Token.NAME ||\n-            pType == Token.ASSIGN)) {\n-        return false;\n-      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {\n@@ -150,7 +143,7 @@ final class CheckGlobalThis implements Callback {\n     }\n \n     // Also report a THIS with a property access.\n-    return parent != null && NodeUtil.isGet(parent);\n+    return false;\n   }\n \n   /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -199,7 +199,7 @@\n         }\n \n       case Token.SHEQ:\n-        if (outcome) {\n+        if (false) {\n           return caseEquality(condition, blindScope, SHEQ);\n         } else {\n           return caseEquality(condition, blindScope, SHNE);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Chart",
        "content": "@@ -695,6 +695,9 @@\n      * @since 1.0.3\n      */\n     public int getDomainAxisIndex(CategoryAxis axis) {\n+        if (axis == null) {\n+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+        }\n         return this.domainAxes.indexOf(axis);\n     }\n \n@@ -970,6 +973,9 @@\n      * @since 1.0.7\n      */\n     public int getRangeAxisIndex(ValueAxis axis) {\n+        if (axis == null) {\n+            throw new IllegalArgumentException(\"Null 'axis' argument.\");\n+        }\n         int result = this.rangeAxes.indexOf(axis);\n         if (result < 0) { // try the parent plot\n             Plot parent = getParent();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.0 && (fa * fb >= 0.0 == numIterations < maximumIterations) != true) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -2539,18 +2539,12 @@ public class DateTimeFormatterBuilder {\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n-            String best = null;\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                \tif (best == null || id.length() > best.length()) {\n-                \t\tbest = id;\n-                \t}\n+                    bucket.setZone(DateTimeZone.forID(id));\n+                    return position + id.length();\n                 }\n             }\n-            if (best != null) {\n-                bucket.setZone(DateTimeZone.forID(best));\n-                return position + best.length();\n-            }\n             return ~position;\n         }\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -108,9 +108,6 @@ public class IR {\n     return block;\n   }\n \n-  private static Node blockUnchecked(Node stmt) {\n-    return new Node(Token.BLOCK, stmt);\n-  }\n \n   public static Node script(Node ... stmts) {\n     // TODO(johnlenz): finish setting up the SCRIPT node\n@@ -224,8 +221,8 @@ public class IR {\n   }\n \n   public static Node tryFinally(Node tryBody, Node finallyBody) {\n-    Preconditions.checkState(tryBody.isBlock());\n-    Preconditions.checkState(finallyBody.isBlock());\n+    Preconditions.checkState(tryBody.isLabelName());\n+    Preconditions.checkState(finallyBody.isLabelName());\n     Node catchBody = block().copyInformationFrom(tryBody);\n     return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n   }\n@@ -233,7 +230,7 @@ public class IR {\n   public static Node tryCatch(Node tryBody, Node catchNode) {\n     Preconditions.checkState(tryBody.isBlock());\n     Preconditions.checkState(catchNode.isCatch());\n-    Node catchBody = blockUnchecked(catchNode).copyInformationFrom(catchNode);\n+    Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n     return new Node(Token.TRY, tryBody, catchBody);\n   }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa!=fb)&&((fa*fb)> 0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -346,9 +346,10 @@ public class OpenMapRealVector extends SparseRealVector\n          * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n          * this[i] / v[i] = NaN, and not 0d.\n          */\n-        final int n = getDimension();\n-        for (int i = 0; i < n; i++) {\n-            res.setEntry(i, this.getEntry(i) / v.getEntry(i));\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n         }\n         return res;\n     }\n@@ -370,18 +371,6 @@ public class OpenMapRealVector extends SparseRealVector\n          *\n          * These special cases are handled below.\n          */\n-        if (v.isNaN() || v.isInfinite()) {\n-            final int n = getDimension();\n-            for (int i = 0; i < n; i++) {\n-                final double y = v.getEntry(i);\n-                if (Double.isNaN(y)) {\n-                    res.setEntry(i, Double.NaN);\n-                } else if (Double.isInfinite(y)) {\n-                    final double x = this.getEntry(i);\n-                    res.setEntry(i, x * y);\n-                }\n-            }\n-        }\n         return res;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -455,7 +455,7 @@ public class NumberUtils {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Time",
        "content": "@@ -308,8 +308,10 @@\n     {\n-        if (fromYear <= toYear) {\n-            OfYear ofYear = new OfYear\n+        if (nameKey.length() != 0) {\n+            if (fromYear <= toYear) {\n+                OfYear ofYear = new OfYear\n                 (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n-            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n-            Rule rule = new Rule(recurrence, fromYear, toYear);\n-            getLastRuleSet().addRule(rule);\n+                Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n+                Rule rule = new Rule(recurrence, fromYear, toYear);\n+                getLastRuleSet().addRule(rule);\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -79,7 +79,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     /** Record whether this complex number is infinite. */\n     private final transient boolean isInfinite;\n     /** Record whether this complex number is zero. */\n-    private final transient boolean isZero;\n \n     /**\n      * Create a complex number given only the real part.\n@@ -103,7 +102,6 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n             (Double.isInfinite(real) || Double.isInfinite(imaginary));\n-        isZero = real == 0 && imaginary == 0;\n     }\n \n     /**\n@@ -255,8 +253,8 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n \n-        if (divisor.isZero) {\n-            return isZero ? NaN : INF;\n+        if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\n+            return NaN;\n         }\n \n         if (divisor.isInfinite() && !isInfinite()) {\n@@ -292,7 +290,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n             return NaN;\n         }\n         if (divisor == 0d) {\n-            return isZero ? NaN : INF;\n+            return NaN;\n         }\n         if (Double.isInfinite(divisor)) {\n             return !isInfinite() ? ZERO : NaN;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -80,20 +80,26 @@ public abstract class CharSequenceTranslator {\n             return;\n         }\n         int pos = 0;\n-        int len = input.length();\n+        int len = Character.codePointCount(input, 0, input.length());\n         while (pos < len) {\n             int consumed = translate(input, pos, out);\n             if (consumed == 0) {\n                 char[] c = Character.toChars(Character.codePointAt(input, pos));\n                 out.write(c);\n-                pos+= c.length;\n-                continue;\n             }\n+            else {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n+                    if (pos < len - 2) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n+                    } else {\n+                        pos++;\n+                    }\n+                }\n+                pos--;\n             }\n+            pos++;\n         }\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -1136,7 +1136,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n-                    work[i + k] = work[j - k];\n+                    work[i + k] = work[i + k];\n                     work[j - k] = tmp;\n                 }\n                 j -= 4;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((Math.min((fa*fb),0.0))> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -130,7 +130,7 @@\n                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n-            //TreeMap will throw ClassCastException if v is not comparable\n+if (!(v instanceof Comparable<?>)){throw new ClassCastException();}            //TreeMap will throw ClassCastException if v is not comparable\n             throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n         }\n     }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -602,7 +602,9 @@\n     long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n         FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n         FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n+        if ((!(10 == monthOfYear)) && (((31) - (2)) != (dayOfMonth))) {\n         FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n+        }\n         return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n     }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -3295,7 +3295,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n         \n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n@@ -3380,7 +3380,7 @@ public class StringUtils {\n             return EMPTY;\n         }\n \n-        StringBuilder buf = new StringBuilder(noOfItems * 16);\n+        StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n \n         for (int i = startIndex; i < endIndex; i++) {\n             if (i > startIndex) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -185,7 +185,7 @@\n                 case REGULA_FALSI:\n                     // Nothing.\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (f0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n                     break;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -572,9 +572,6 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n-          if (convention.getSingletonGetterClassName(callNode) != null) {\n-            return false;\n-          }\n         }\n       }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -115,9 +115,7 @@ public class StopWatch {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n-        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n-        }\n         this.runningState = STATE_STOPPED;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -1536,3 +1536,3 @@\n                 final double gam = dN2;\n-                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                if (true) {\n                     return;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SOFix/Math",
        "content": "@@ -335,7 +335,7 @@\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0.0, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -785,10 +785,7 @@ public class StringUtils {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n-        if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n-        }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -869,7 +869,6 @@ public class FastDateFormat extends Format {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n-            calendar.getTime(); /// LANG-538\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa / fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -1416,7 +1416,6 @@ public class DSCompiler {\n         }\n \n         // fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n-        result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);\n \n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -257,7 +257,7 @@\n                     // the guessed root is either not strictly inside the interval or it\n                     // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n+                    if ((signChangeIndex - start >= end - signChangeIndex) || (y[0] * y[1] < 0)) {\n                         // we have more points before the sign change, drop the lowest point\n                         ++start;\n                     } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Lang",
        "content": "@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList()).contains(locale);\n     }\n  \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -417,7 +417,6 @@ final class TypedScopeCreator implements ScopeCreator {\n      * For more information, see\n      * http://code.google.com/p/closure-compiler/issues/detail?id=314\n      */\n-    private List<Node> lentObjectLiterals = null;\n \n     /**\n      * Type-less stubs.\n@@ -545,13 +544,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       // Analyze any @lends object literals in this statement.\n-      if (n.getParent() != null && NodeUtil.isStatement(n) &&\n-          lentObjectLiterals != null) {\n-        for (Node objLit : lentObjectLiterals) {\n-          defineObjectLiteral(objLit);\n-        }\n-        lentObjectLiterals.clear();\n-      }\n     }\n \n     private void attachLiteralTypes(NodeTraversal t, Node n) {\n@@ -585,16 +577,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           break;\n \n         case Token.OBJECTLIT:\n-          JSDocInfo info = n.getJSDocInfo();\n-          if (info != null &&\n-              info.getLendsName() != null) {\n-            if (lentObjectLiterals == null) {\n-              lentObjectLiterals = Lists.newArrayList();\n-            }\n-            lentObjectLiterals.add(n);\n-          } else {\n             defineObjectLiteral(n);\n-          }\n           break;\n \n           // NOTE(nicksantos): If we ever support Array tuples,\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Closure",
        "content": "@@ -956,7 +956,7 @@\n                         // Find the return's description (if applicable).\n                         if (jsdocBuilder.shouldParseDocumentation()) {\n                           ExtractionInfo returnDescriptionInfo =\n-                              extractMultilineTextualBlock(token);\n+                              extractMultilineTextualBlock(current());\n \n                           String returnDescription =\n                               returnDescriptionInfo.string;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Math",
        "content": "@@ -517,7 +517,7 @@\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -148,7 +148,6 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n         // Best point encountered so far (which is the initial guess).\n-        UnivariatePointValuePair best = current;\n \n         int iter = 0;\n         while (true) {\n@@ -232,15 +231,10 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                 // User-defined convergence checker.\n                 previous = current;\n                 current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n-                best = best(best,\n-                            best(current,\n-                                 previous,\n-                                 isMinim),\n-                            isMinim);\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n-                        return best;\n+                        return best(current, previous, isMinim);\n                     }\n                 }\n \n@@ -277,10 +271,9 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     }\n                 }\n             } else { // Default termination (Brent's criterion).\n-                return best(best,\n+                return\n                             best(current,\n                                  previous,\n-                                 isMinim),\n                             isMinim);\n             }\n             ++iter;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -114,14 +114,7 @@\n       if (isResultUsed) {\n         return;\n       }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n+      int start = 0;\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n         return;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Time",
        "content": "@@ -361,21 +361,9 @@ public final class GJChronology extends AssembledChronology {\n \n         // Assume date is Gregorian.\n         long instant;\n-        try {\n             instant = iGregorianChronology.getDateTimeMillis\n                 (year, monthOfYear, dayOfMonth,\n                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-        } catch (IllegalFieldValueException ex) {\n-            if (monthOfYear != 2 || dayOfMonth != 29) {\n-                throw ex;\n-            }\n-            instant = iGregorianChronology.getDateTimeMillis\n-                (year, monthOfYear, 28,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-            if (instant >= iCutoverMillis) {\n-                throw ex;\n-            }\n-        }\n         if (instant < iCutoverMillis) {\n             // Maybe it's Julian.\n             instant = iJulianChronology.getDateTimeMillis\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -194,7 +194,7 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null && target.getType() == Token.STRING) {\n+          if (target != null) {\n             className = target.getString();\n           }\n         }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Lang",
        "content": "@@ -434,7 +434,7 @@\n         int endValue = end.get(field);\n         int startValue = start.get(field);\n         if (endValue < startValue) {\n-            int newdiff = startValue - endValue;\n+            int newdiff = endValue - endValue;\n             end.add( field, newdiff );\n             return newdiff;\n         } else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Lang",
        "content": "@@ -463,3 +463,5 @@\n                     }\n-                    throw new NumberFormatException(str + \" is not a valid number.\");\n+                    if ((numeric.length()) != (short) 1) {\n+                        throw new NumberFormatException(str + \" is not a valid number.\");\n+                    }\n                 case 'f' :\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -825,15 +825,10 @@ class Entities {\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n-            int c = Character.codePointAt(str, i); \n+            char c = str.charAt(i);\n             String entityName = this.entityName(c);\n             if (entityName == null) {\n-                if (c >= 0x010000 && i < len - 1) {\n-                    writer.write(\"&#\");\n-                    writer.write(Integer.toString(c, 10));\n-                    writer.write(';');\n-                    i++;\n-                } else if (c > 0x7F) { \n+                if (c > 0x7F) {\n                     writer.write(\"&#\");\n                     writer.write(Integer.toString(c, 10));\n                     writer.write(';');\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -182,19 +182,10 @@ public abstract class BaseSecantSolver\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n-                case REGULA_FALSI:\n-                    if (x == x1) {\n-                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n-                                                          atol);\n                         // Update formula cannot make any progress: Update the\n                         // search interval.\n-                        x0 = 0.5 * (x0 + x1 - delta);\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n-                    break;\n                 default:\n                     // Should never happen.\n-                    throw new MathInternalError();\n                 }\n             }\n             // Update from [x0, x1] to [x0, x].\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -475,6 +475,7 @@\n \n     Node newRight;\n     if (areNodesEqualForInlining(left, right.getFirstChild())) {\n+      n.removeChild(right);\n       newRight = right.getLastChild();\n     } else if (NodeUtil.isCommutative(right.getType()) &&\n           areNodesEqualForInlining(left, right.getLastChild())) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -69,7 +69,7 @@\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, min, max);\n     }\n \n     /** {@inheritDoc} */\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Math",
        "content": "@@ -87,7 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n+            if (comparator.compare(contracted, best) <= 0) {\n                 // accept the contracted simplex\n \n             // check convergence\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -1133,6 +1133,7 @@\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n             int j = 4 * n - 1;\n+            j=4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -1408,7 +1408,9 @@\n       }\n       res = n.checkTreeEqualsImpl(n2);\n       if (res != null) {\n-        return res;\n+        if (true)\n+            return null;\n+        return res;\n       }\n     }\n     return res;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -782,16 +782,13 @@ class CodeGenerator {\n \n   static boolean isSimpleNumber(String s) {\n     int len = s.length();\n-    if (len == 0) {\n-      return false;\n-    }\n     for (int index = 0; index < len; index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len == 1 || s.charAt(0) != '0';\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -492,10 +492,10 @@ public class FastDateFormat extends Format {\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen == 2) {\n-                    rule = TwoDigitYearField.INSTANCE;\n+                if (tokenLen >= 4) {\n+                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n                 } else {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n+                    rule = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -880,8 +880,10 @@\n             throw new IllegalArgumentException(\"Requires start >= 0.\");\n         }\n         if (end < start) {\n+            if (org.jfree.data.time.TimeSeries.this.data.size() == org.jfree.data.time.TimeSeries.this.range.length()) {\n             throw new IllegalArgumentException(\"Requires start <= end.\");\n         }\n+        }\n         TimeSeries copy = (TimeSeries) super.clone();\n \n         copy.data = new java.util.ArrayList();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -158,7 +158,7 @@\n      */\n     public boolean hasListener(EventListener listener) {\n         List list = Arrays.asList(this.listenerList.getListenerList());\n-        return list.contains(listener);\n+        return list != null || list.contains(listener);\n     }\n     \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1410,13 +1410,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           // then they are responsible for making sure that the object literal's\n           // implicit prototype is set up appropriately. We just obey\n           // the @extends tag.\n-          ObjectType qVarType = ObjectType.cast(qVar.getType());\n-          if (qVarType != null &&\n-              rhsValue != null &&\n-              rhsValue.getType() == Token.OBJECTLIT) {\n-            typeRegistry.resetImplicitPrototype(\n-                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n-          } else if (!qVar.isTypeInferred()) {\n+          if (!qVar.isTypeInferred()) {\n             // If the programmer has declared that F inherits from Super,\n             // and they assign F.prototype to some arbitrary expression,\n             // there's not much we can do. We just ignore the expression,\n@@ -338,6 +338,7 @@ public class FunctionType extends PrototypeObjectType {\n     //\n     // In the second case, we just use the anonymous object as the prototype.\n     if (baseType.hasReferenceName() ||\n+        baseType.isUnknownType() ||\n         isNativeObjectType() ||\n         baseType.isFunctionPrototypeType() ||\n         !(baseType instanceof PrototypeObjectType)) {\n@@ -362,18 +363,14 @@ public class FunctionType extends PrototypeObjectType {\n       return false;\n     }\n \n-    PrototypeObjectType oldPrototype = this.prototype;\n-    boolean replacedPrototype = oldPrototype != null;\n+    boolean replacedPrototype = prototype != null;\n \n     this.prototype = prototype;\n     this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n     this.prototype.setOwnerFunction(this);\n \n-    if (oldPrototype != null) {\n       // Disassociating the old prototype makes this easier to debug--\n       // we don't have to worry about two prototypes running around.\n-      oldPrototype.setOwnerFunction(null);\n-    }\n \n     if (isConstructor() || isInterface()) {\n       FunctionType superClass = getSuperClassConstructor();\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -209,386 +209,7 @@\n         notifyListeners(new PlotChangeEvent(this));\n     }\n \n-    /**\n-     * Draws the plot on a Java 2D graphics device (such as the screen or a \n-     * printer).  This method is called by the \n-     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \n-     * to call it yourself.\n-     *\n-     * @param g2  the graphics device.\n-     * @param plotArea  the area within which the plot should be drawn.\n-     * @param anchor  the anchor point.\n-     * @param parentState  the state from the parent plot, if there is one.\n-     * @param info  collects info about the drawing \n-     *              (<code>null</code> permitted).\n-     */\n-    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\n-                     PlotState parentState,\n-                     PlotRenderingInfo info) {\n-\n-        // adjust for insets...\n-        RectangleInsets insets = getInsets();\n-        insets.trim(plotArea);\n-\n-        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\n-        if (info != null) {\n-            info.setPlotArea(plotArea);\n-            info.setDataArea(plotArea);\n-        }\n-\n-        drawBackground(g2, plotArea);\n-\n-        Shape savedClip = g2.getClip();\n-        g2.clip(plotArea);\n-\n-        // adjust the plot area by the interior spacing value\n-        double gapPercent = getInteriorGap();\n-        double labelPercent = 0.0;\n-        if (getLabelGenerator() != null) {\n-            labelPercent = getLabelGap() + getMaximumLabelWidth();   \n-        }\n-        double gapHorizontal = plotArea.getWidth() * (gapPercent \n-                + labelPercent) * 2.0;\n-        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\n-\n-        if (DEBUG_DRAW_INTERIOR) {\n-            double hGap = plotArea.getWidth() * getInteriorGap();\n-            double vGap = plotArea.getHeight() * getInteriorGap();\n-            double igx1 = plotArea.getX() + hGap;\n-            double igx2 = plotArea.getMaxX() - hGap;\n-            double igy1 = plotArea.getY() + vGap;\n-            double igy2 = plotArea.getMaxY() - vGap;\n-            g2.setPaint(Color.lightGray);\n-            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n-                    igy2 - igy1));\n-        }\n-\n-        double linkX = plotArea.getX() + gapHorizontal / 2;\n-        double linkY = plotArea.getY() + gapVertical / 2;\n-        double linkW = plotArea.getWidth() - gapHorizontal;\n-        double linkH = plotArea.getHeight() - gapVertical;\n-        \n-        // make the link area a square if the pie chart is to be circular...\n-        if (isCircular()) { // is circular?\n-            double min = Math.min(linkW, linkH) / 2;\n-            linkX = (linkX + linkX + linkW) / 2 - min;\n-            linkY = (linkY + linkY + linkH) / 2 - min;\n-            linkW = 2 * min;\n-            linkH = 2 * min;\n-        }\n-        \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n-\n-        // the link area defines the dog leg points for the linking lines to \n-        // the labels\n-        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH * (1 - this.depthFactor));\n-        state.setLinkArea(linkAreaXX);\n-\n-        if (DEBUG_DRAW_LINK_AREA) {\n-            g2.setPaint(Color.blue);\n-            g2.draw(linkAreaXX);\n-            g2.setPaint(Color.yellow);\n-            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \n-                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\n-        }\n-        \n-        // the explode area defines the max circle/ellipse for the exploded pie \n-        // sections.\n-        // it is defined by shrinking the linkArea by the linkMargin factor.\n-        double hh = linkW * getLabelLinkMargin();\n-        double vv = linkH * getLabelLinkMargin();\n-        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n-                linkY + vv / 2.0, linkW - hh, linkH - vv);\n-       \n-        state.setExplodedPieArea(explodeArea);\n-        \n-        // the pie area defines the circle/ellipse for regular pie sections.\n-        // it is defined by shrinking the explodeArea by the explodeMargin \n-        // factor. \n-        double maximumExplodePercent = getMaximumExplodePercent();\n-        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n-        \n-        double h1 = explodeArea.getWidth() * percent;\n-        double v1 = explodeArea.getHeight() * percent;\n-        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n-                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\n-                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n-\n-        // the link area defines the dog-leg point for the linking lines to \n-        // the labels\n-        int depth = (int) (pieArea.getHeight() * this.depthFactor);\n-        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n-                linkH - depth);\n-        state.setLinkArea(linkArea);   \n-\n-        state.setPieArea(pieArea);\n-        state.setPieCenterX(pieArea.getCenterX());\n-        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\n-        state.setPieWRadius(pieArea.getWidth() / 2.0);\n-        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\n-\n-        // get the data source - return if null;\n-        PieDataset dataset = getDataset();\n-        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\n-            drawNoDataMessage(g2, plotArea);\n-            g2.setClip(savedClip);\n-            drawOutline(g2, plotArea);\n-            return;\n-        }\n-\n-        // if too any elements\n-        if (dataset.getKeys().size() > plotArea.getWidth()) {\n-            String text = \"Too many elements\";\n-            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\n-            g2.setFont(sfont);\n-            FontMetrics fm = g2.getFontMetrics(sfont);\n-            int stringWidth = fm.stringWidth(text);\n-\n-            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \n-                    - stringWidth) / 2), (int) (plotArea.getY() \n-                    + (plotArea.getHeight() / 2)));\n-            return;\n-        }\n-        // if we are drawing a perfect circle, we need to readjust the top left\n-        // coordinates of the drawing area for the arcs to arrive at this\n-        // effect.\n-        if (isCircular()) {\n-            double min = Math.min(plotArea.getWidth(), \n-                    plotArea.getHeight()) / 2;\n-            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \n-                    plotArea.getCenterY() - min, 2 * min, 2 * min);\n-        }\n-        // get a list of keys...\n-        List sectionKeys = dataset.getKeys();\n-\n-        if (sectionKeys.size() == 0) {\n-            return;\n-        }\n-\n-        // establish the coordinates of the top left corner of the drawing area\n-        double arcX = pieArea.getX();\n-        double arcY = pieArea.getY();\n-\n-        //g2.clip(clipArea);\n-        Composite originalComposite = g2.getComposite();\n-        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n-                getForegroundAlpha()));\n-\n-        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\n-        double runningTotal = 0;\n-        if (depth < 0) {\n-            return;  // if depth is negative don't draw anything\n-        }\n-\n-        ArrayList arcList = new ArrayList();\n-        Arc2D.Double arc;\n-        Paint paint;\n-        Paint outlinePaint;\n-        Stroke outlineStroke;\n-\n-        Iterator iterator = sectionKeys.iterator();\n-        while (iterator.hasNext()) {\n-\n-            Comparable currentKey = (Comparable) iterator.next();\n-            Number dataValue = dataset.getValue(currentKey);\n-            if (dataValue == null) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double value = dataValue.doubleValue();\n-            if (value <= 0) {\n-                arcList.add(null);\n-                continue;\n-            }\n-            double startAngle = getStartAngle();\n-            double direction = getDirection().getFactor();\n-            double angle1 = startAngle + (direction * (runningTotal * 360)) \n-                    / totalValue;\n-            double angle2 = startAngle + (direction * (runningTotal + value) \n-                    * 360) / totalValue;\n-            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\n-                arcList.add(new Arc2D.Double(arcX, arcY + depth, \n-                        pieArea.getWidth(), pieArea.getHeight() - depth,\n-                        angle1, angle2 - angle1, Arc2D.PIE));\n-            }\n-            else {\n-                arcList.add(null);\n-            }\n-            runningTotal += value;\n-        }\n-\n-        Shape oldClip = g2.getClip();\n-\n-        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \n-                pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \n-                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\n-\n-        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \n-                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \n-                - top.getCenterY());\n-\n-        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \n-                pieArea.getWidth(), bottom.getCenterY() - top.getY());\n-\n-        Area a = new Area(top);\n-        a.add(new Area(lower));\n-        Area b = new Area(bottom);\n-        b.add(new Area(upper));\n-        Area pie = new Area(a);\n-        pie.intersect(b);\n-\n-        Area front = new Area(pie);\n-        front.subtract(new Area(top));\n-\n-        Area back = new Area(pie);\n-        back.subtract(new Area(bottom));\n-\n-        // draw the bottom circle\n-        int[] xs;\n-        int[] ys;\n-        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \n-                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\n-\n-        int categoryCount = arcList.size();\n-        for (int categoryIndex = 0; categoryIndex < categoryCount; \n-                 categoryIndex++) {\n-            arc = (Arc2D.Double) arcList.get(categoryIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            Comparable key = getSectionKey(categoryIndex);\n-            paint = lookupSectionPaint(key, true);\n-            outlinePaint = lookupSectionOutlinePaint(key);\n-            outlineStroke = lookupSectionOutlineStroke(key);\n-            g2.setPaint(paint);\n-            g2.fill(arc);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(arc);\n-            g2.setPaint(paint);\n-\n-            Point2D p1 = arc.getStartPoint();\n-\n-            // draw the height\n-            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\n-                    (int) p1.getX(), (int) p1.getX()};\n-            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \n-                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\n-            Polygon polygon = new Polygon(xs, ys, 4);\n-            g2.setPaint(java.awt.Color.lightGray);\n-            g2.fill(polygon);\n-            g2.setPaint(outlinePaint);\n-            g2.setStroke(outlineStroke);\n-            g2.draw(polygon);\n-            g2.setPaint(paint);\n-\n-        }\n-\n-        g2.setPaint(Color.gray);\n-        g2.fill(back);\n-        g2.fill(front);\n-\n-        // cycle through once drawing only the sides at the back...\n-        int cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key, true);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, false, true);\n-            }\n-            cat++;\n-        }\n-\n-        // cycle through again drawing only the sides at the front...\n-        cat = 0;\n-        iterator = arcList.iterator();\n-        while (iterator.hasNext()) {\n-            Arc2D segment = (Arc2D) iterator.next();\n-            if (segment != null) {\n-                Comparable key = getSectionKey(cat);\n-                paint = lookupSectionPaint(key);\n-                outlinePaint = lookupSectionOutlinePaint(key);\n-                outlineStroke = lookupSectionOutlineStroke(key);\n-                drawSide(g2, pieArea, segment, front, back, paint, \n-                        outlinePaint, outlineStroke, true, false);\n-            }\n-            cat++;\n-        }\n-\n-        g2.setClip(oldClip);\n-\n-        // draw the sections at the top of the pie (and set up tooltips)...\n-        Arc2D upperArc;\n-        for (int sectionIndex = 0; sectionIndex < categoryCount; \n-                 sectionIndex++) {\n-            arc = (Arc2D.Double) arcList.get(sectionIndex);\n-            if (arc == null) {\n-                continue;\n-            }\n-            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\n-                    pieArea.getHeight() - depth, arc.getAngleStart(), \n-                    arc.getAngleExtent(), Arc2D.PIE);\n-            \n-            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\n-            paint = lookupSectionPaint(currentKey, true);\n-            outlinePaint = lookupSectionOutlinePaint(currentKey);\n-            outlineStroke = lookupSectionOutlineStroke(currentKey);\n-            g2.setPaint(paint);\n-            g2.fill(upperArc);\n-            g2.setStroke(outlineStroke);\n-            g2.setPaint(outlinePaint);\n-            g2.draw(upperArc);\n-\n-           // add a tooltip for the section...\n-            if (info != null) {\n-                EntityCollection entities \n-                        = info.getOwner().getEntityCollection();\n-                if (entities != null) {\n-                    String tip = null;\n-                    PieToolTipGenerator tipster = getToolTipGenerator();\n-                    if (tipster != null) {\n-                        // @mgs: using the method's return value was missing \n-                        tip = tipster.generateToolTip(dataset, currentKey);\n-                    }\n-                    String url = null;\n-                    if (getURLGenerator() != null) {\n-                        url = getURLGenerator().generateURL(dataset, currentKey,\n-                                getPieIndex());\n-                    }\n-                    PieSectionEntity entity = new PieSectionEntity(\n-                            upperArc, dataset, getPieIndex(), sectionIndex, \n-                            currentKey, tip, url);\n-                    entities.add(entity);\n-                }\n-            }\n-            List keys = dataset.getKeys();\n-            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\n-                    originalPlotArea.getX(), originalPlotArea.getY(), \n-                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \n-                    - depth);\n-            if (getSimpleLabels()) {\n-                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \n-                        linkArea, state);\n-            }\n-            else {\n-                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \n-                        state);\n-            }\n-        }\n-\n-        g2.setClip(savedClip);\n-        g2.setComposite(originalComposite);\n-        drawOutline(g2, originalPlotArea);\n-\n-    }\n+    \n \n     /**\n      * Draws the side of a pie section.\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -176,10 +176,6 @@\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n           if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n           }\n         }\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -109,15 +109,6 @@\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n       if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n       if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -51,7 +51,6 @@\n    */\n   protected void error(DiagnosticType diagnostic, Node n) {\n     JSError error = currentTraversal.makeError(n, diagnostic, n.toString());\n-    currentTraversal.getCompiler().report(error);\n   }\n \n   /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Lang",
        "content": "@@ -876,7 +876,8 @@ public class StrBuilder implements Cloneable {\n      * @return this, to enable chaining\n      */\n     public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n-        if (width > 0) {\n+        ensureCapacity(((size) + 5));\n+if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -428,9 +428,6 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n-          if (ref.getSymbol().getScope() != ref.scope) {\n-            return false;\n-          }\n           break;\n         } else if (block.isLoop) {\n           return false;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -575,7 +575,7 @@ final class NameAnalyzer implements CompilerPass {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else if (!(parent.isCall() && parent.getFirstChild() == n)) {\n+        } else {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Math",
        "content": "@@ -163,8 +163,8 @@\n         double[][] out = new double[nVars][nVars];\n         for (int i = 0; i < nVars; i++) {\n             for (int j = 0; j < nVars; j++) {\n-                if (i == j) {\n-                    out[i][j] = 0d;\n+                if(i==j&&i<nVars){\n+                    out[i][j]=0.0;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -310,7 +310,6 @@ public class FastMath {\n     /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n     private static final double TWO_POWER_52 = 4503599627370496.0;\n     /** 2^53 - double numbers this large must be even. */\n-    private static final double TWO_POWER_53 = 2 * TWO_POWER_52;\n \n     /** Constant: {@value}. */\n     private static final double F_1_3 = 1d / 3d;\n@@ -1539,7 +1538,7 @@ public class FastMath {\n         /* Handle special case x<0 */\n         if (x < 0) {\n             // y is an even integer in this case\n-            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n+            if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n                 return pow(-x, y);\n             }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1189,15 +1189,9 @@ class TypeInference\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = Maps.filterKeys(\n-        inferTemplateTypesFromParameters(fnType, n),\n-        new Predicate<TemplateType>() {\n-\n-          @Override\n-          public boolean apply(TemplateType key) {\n-            return keys.contains(key);\n-          }}\n-        );\n+    Map<TemplateType, JSType> inferred = \n+        inferTemplateTypesFromParameters(fnType, n);\n+\n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Math",
        "content": "@@ -63,7 +63,8 @@\n \n         while (true) {\n \n-            incrementIterationsCounter();\n+            final double[] xSmallest = simplex[0].getPointRef();\n+            incrementIterationsCounter();\n \n             // save the original vertex\n             final RealPointValuePair[] original = simplex;\n@@ -87,12 +88,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n-            }\n+            return;\n \n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -150,6 +150,9 @@\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+        if((rhs.isNaN() == isInfinite()) == false){\n+        \treturn this.NaN;\n+        \t}\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Closure",
        "content": "@@ -1116,8 +1116,6 @@\n       Iterable<Node> declParams,\n       Iterable<Node> callParams,\n       Map<TemplateType, JSType> resolvedTypes) {\n-    maybeResolveTemplateTypeFromNodes(\n-        declParams.iterator(), callParams.iterator(), resolvedTypes);\n   }\n \n   private void maybeResolveTemplateTypeFromNodes(\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Chart",
        "content": "@@ -277,7 +277,10 @@\n             linkH = 2 * min;\n         }\n         \n-        PiePlotState state = initialise(g2, plotArea, this, null, info);\n+        if (info == null) {\n+    return;\n+}\n+PiePlotState state = initialise(g2, plotArea, this, null, info);\n \n         // the link area defines the dog leg points for the linking lines to \n         // the labels\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/FixMiner/Time",
        "content": "@@ -75,7 +75,7 @@\n      * @return true to log verbosely\n      */\n     public static boolean verbose() {\n-        return cVerbose.get();\n+        return cVerbose != null || cVerbose.get();\n     }\n \n     //-----------------------------------------------------------------------\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -87,12 +87,7 @@\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n                 return;\n-            }\n \n         }\n \n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -1406,13 +1406,10 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           (parameters.hasNext() ||\n-            parameter != null && parameter.isVarArgs())) {\n+           parameters.hasNext()) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n-      if (parameters.hasNext()) {\n         parameter = parameters.next();\n-      }\n       argument = arguments.next();\n       ordinal++;\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -3297,6 +3297,7 @@\n         @SuppressWarnings(\"unchecked\") // type must be T\n         T[] newArray = (T[]) copyArrayGrow1(array, type);\n         newArray[newArray.length - 1] = element;\n+     \tif (element == null){throw new IllegalArgumentException();}\n         return newArray;\n     }\n \n@@ -3571,6 +3572,7 @@\n         } else if (element != null) {\n             clss = element.getClass();\n         } else {\n+ \tif (element == null){throw new IllegalArgumentException();}\n             return (T[]) new Object[] { null };\n         }\n         @SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/SimFix/Closure",
        "content": "@@ -402,11 +402,20 @@\n   boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n       JSType leftType, String msg) {\n     if (!rightType.canAssignTo(leftType)) {\n+    // start of generated patch\n+      if(!shouldReport&&(shouldReport||!NodeUtil.mayHaveSideEffects(n,t.getCompiler()))){\n+        registerMismatch(rightType,leftType,null);\n+      }else {\n+        mismatch(t,n,msg,rightType,leftType);\n+      }\n+    // end of generated patch\n+    /* start of original code\n       if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n         registerMismatch(rightType, leftType, null);\n       } else {\n       mismatch(t, n, msg, rightType, leftType);\n       }\n+    end of original code*/\n       return false;\n     }\n     return true;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -135,6 +135,7 @@\n     public static long safeMultiply(long val1, int val2) {\n         switch (val2) {\n             case -1:\n+if (val1==Long.MIN_VALUE){throw new ArithmeticException();}\n                 return -val1;\n             case 0:\n                 return 0L;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -380,10 +380,6 @@\n         sb.append(getPropertyType(property).toString());\n \n         ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n       }\n \n       sb.append(\"}\");\n\n\n@@ -83,7 +83,6 @@\n   public JSType build() {\n      // If we have an empty record, simply return the object type.\n     if (isEmpty) {\n-       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n     }\n \n     return registry.createRecordType(Collections.unmodifiableMap(properties));\n\n\n@@ -107,7 +107,7 @@\n     Set<String> keySet = properties.keySet();\n     Map<String, JSType> otherProps = otherRecord.properties;\n     if (!otherProps.keySet().equals(keySet)) {\n-      return false;\n+      return true;\n     }\n     for (String key : keySet) {\n       if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n@@ -172,13 +172,6 @@\n             getPropertyNode(property));\n       }\n \n-      for (String property : thatRecord.properties.keySet()) {\n-        if (!hasProperty(property)) {\n-          builder.addProperty(property, thatRecord.getPropertyType(property),\n-              thatRecord.getPropertyNode(property));\n-        }\n-      }\n-\n       return builder.build();\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -332,6 +332,7 @@\n         }\n         Range range = (Range) obj;\n         if (!(this.lower == range.lower)) {\n+            if(((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)) && ((!(1 < org.jfree.data.Range.this.lower)) || (org.jfree.data.Range.this.lower <= -1 + org.jfree.data.Range.this.upper - 1)))\n             return false;\n         }\n         if (!(this.upper == range.upper)) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -549,7 +549,7 @@\n      * @return The index.\n      */\n     public int getMaxMiddleIndex() {\n-        return this.maxMiddleIndex;\n+        return this.maxEndIndex;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -220,7 +220,7 @@\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Lang",
        "content": "@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList.contains(locale);\n     }\n  \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/CapGen/Lang",
        "content": "@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return org.apache.commons.lang.LocaleUtils.availableLocaleList().contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -988,7 +988,7 @@ public class BigMatrixImpl implements BigMatrix, Serializable {\n         }\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n-        final BigDecimal[] out = new BigDecimal[nRows];\n+        final BigDecimal[] out = new BigDecimal[v.length];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n@@ -776,7 +776,7 @@ public class RealMatrixImpl implements RealMatrix, Serializable {\n         if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        final double[] out = new double[nRows];\n+        final double[] out = new double[v.length];\n         for (int row = 0; row < nRows; row++) {\n             final double[] dataRow = data[row];\n             double sum = 0;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -297,10 +297,6 @@ public abstract class EmbeddedRungeKuttaIntegrator\n                   // it is so small (much probably exactly 0 due to limited accuracy)\n                   // that the code above would fail handling it.\n                   // So we set up an artificial 0 size step by copying states\n-                  interpolator.storeTime(stepStart);\n-                  System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                  hNew     = 0;\n-                  stepSize = 0;\n                   loop     = false;\n               } else {\n                   // reject the step to match exactly the next switch time\n@@ -177,9 +177,6 @@ public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n                 // it is so small (much probably exactly 0 due to limited accuracy)\n                 // that the code above would fail handling it.\n                 // So we set up an artificial 0 size step by copying states\n-                interpolator.storeTime(stepStart);\n-                System.arraycopy(y, 0, yTmp, 0, y0.length);\n-                stepSize = 0;\n                 loop     = false;\n             } else {\n                 // reject the step to match exactly the next switch time\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/AVATAR/Math",
        "content": "@@ -107,7 +107,11 @@\n      */\n     @Deprecated\n     public void addValue(Object v) {\n+        if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n+        } else {\n+            throw new IllegalArgumentException(\"Object must implement Comparable\");\n+        }\n     }\n \n     /**\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+    return len > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Math",
        "content": "@@ -159,7 +159,7 @@\n             try {\n                 final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                 final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n-                optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n+                optima[i] = optimizer.optimize(f, goal, min, FastMath.max(bound1, bound2));\n             } catch (FunctionEvaluationException fee) {\n                 optima[i] = null;\n             } catch (ConvergenceException ce) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -81,7 +81,7 @@\n             final double entry = tableau.getEntry(i, col);\n             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                 final double ratio = rhs / entry;\n-                if (ratio < minRatio) {\n+                if (ratio < minRatio || (minRatio >= rhs / entry) == true) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if(((fa*fb)> 0.0)&&(fa> 0.0)){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -119,7 +119,9 @@ class CodeGenerator {\n         cc.addOp(opstr, true);\n         addExpr(last, p, rhsContext);\n       } else {\n-        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n+        addExpr(first, p, context);\n+        cc.addOp(opstr, true);\n+        addExpr(last, p + 1, rhsContext);\n       }\n       return;\n     }\n@@ -749,7 +751,7 @@ class CodeGenerator {\n     Node current = firstNonOperator;\n     do {\n       current = current.getParent();\n-      cc.addOp(opStr, true);\n+      cc.listSeparator();\n       addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n     } while (current != n);\n   }\n@@ -331,7 +331,7 @@ class CodePrinter {\n     @Override\n     void appendOp(String op, boolean binOp) {\n       if (binOp) {\n-        if (getLastChar() != ' ' && op.charAt(0) != ',') {\n+        if (getLastChar() != ' ') {\n           append(\" \");\n         }\n         append(op);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -233,10 +233,6 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n-                    case '/':\n-                        out.write('\\\\');\n-                        out.write('/');\n-                        break;\n                     default :\n                         out.write(ch);\n                         break;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -261,7 +261,7 @@ public class SimpleRegression implements Serializable {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n+        return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ACS/Math",
        "content": "@@ -79,8 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n-                final double ratio = rhs / entry;\n+if (MathUtils.compareTo(entry, 0, epsilon) >= 0&&!(MathUtils.compareTo(entry, 0, epsilon)==0.0)) {                final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i;\n\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -190,8 +190,10 @@\n             for (int j = 0; j < i; j++) {\n               double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n               outMatrix.setEntry(i, j, corr);\n+              if (2 < nVars) {\n               outMatrix.setEntry(j, i, corr);\n             }\n+            }\n             outMatrix.setEntry(i, i, 1d);\n         }\n         return outMatrix;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Lang",
        "content": "@@ -117,3 +117,5 @@\n         }\n-            stopTime = System.currentTimeMillis();\n+            if (org.apache.commons.lang.time.StopWatch.this.stopTime < 10) {\n+                stopTime = System.currentTimeMillis();\n+            }\n         this.runningState = STATE_STOPPED;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -88,6 +88,14 @@ class MakeDeclaredNamesUnique\n       renamer = nameStack.peek().forChildScope();\n     }\n \n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+      for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+        String name = c.getString();\n+        renamer.addDeclaredName(name);\n+      }\n+      Node functionBody = declarationRoot.getLastChild();\n+      findDeclaredNames(functionBody, null, renamer);\n+    }  else \n     if (declarationRoot.getType() != Token.FUNCTION) {\n       // Add the block declarations\n       findDeclaredNames(declarationRoot, null, renamer);\n@@ -119,22 +127,11 @@ class MakeDeclaredNamesUnique\n             renamer.addDeclaredName(name);\n           }\n \n-          nameStack.push(renamer);\n-        }\n-        break;\n \n-      case Token.LP: {\n-          Renamer renamer = nameStack.peek().forChildScope();\n \n           // Add the function parameters\n-          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n-          }\n \n           // Add the function body declarations\n-          Node functionBody = n.getNext();\n-          findDeclaredNames(functionBody, null, renamer);\n \n           nameStack.push(renamer);\n         }\n@@ -173,16 +170,13 @@ class MakeDeclaredNamesUnique\n \n       case Token.FUNCTION:\n         // Remove the function body scope\n-        nameStack.pop();\n         // Remove function recursive name (if any).\n         nameStack.pop();\n         break;\n \n-      case Token.LP:\n         // Note: The parameters and function body variables live in the\n         // same scope, we introduce the scope when in the \"shouldTraverse\"\n         // visit of LP, but remove it when when we exit the function above.\n-        break;\n \n       case Token.CATCH:\n         // Remove catch except name from the stack of names.\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -195,6 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n+        if(((fa * fb)) != (lowerBound))\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -632,9 +632,11 @@ final class NameAnalyzer implements CompilerPass {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, true);\n+          JsName name = getName(ns.name, false);\n+          if (name != null) {\n           refNodes.add(new ClassDefiningFunctionNode(\n               name, n, parent, parent.getParent()));\n+          }\n         }\n       }\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/TBar/Chart",
        "content": "@@ -561,7 +561,8 @@\n      *              permitted).\n      */\n     public void add(TimeSeriesDataItem item) {\n-        add(item, true);\n+        updateBoundsForRemovedItem(item);\n+        add(item, true);\n     }\n \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jMutRepair/Closure",
        "content": "@@ -138,7 +138,7 @@\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n+      if (!NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Lang",
        "content": "@@ -674,6 +674,9 @@\n                         (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                         (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                 }\n+                if((ch == 'Y' || ch == 'y') == false){\n+                \treturn str == null;\n+                \t}\n                 if (ch == 'Y') {\n                     return \n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Arja/Closure",
        "content": "@@ -1835,7 +1835,6 @@\n       }\n     }\n \n-    restoreLookAhead(token);\n     return reportGenericTypeSyntaxWarning();\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -1945,7 +1945,7 @@\n    * TypeApplication := '.<' TypeExpressionList '>'\n    */\n   private Node parseTypeName(JsDocToken token) {\n-    if (token != JsDocToken.STRING) {\n+    if(token==null){\n       return reportGenericTypeSyntaxWarning();\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Closure",
        "content": "@@ -554,6 +554,9 @@\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n+\t  if((hasReferenceName() && constraintObj.isRecordType()) == true){\n+\t\t  return;\n+\t\t  }\n \n     // Handle the case where the constraint object is a record type.\n     //",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -338,13 +338,6 @@ public class IRFactory {\n     @Override\n     Node processAssignment(Assignment assignmentNode) {\n       Node assign = processInfixExpression(assignmentNode);\n-      Node target = assign.getFirstChild();\n-      if (!validAssignmentTarget(target)) {\n-        errorReporter.error(\n-          \"invalid assignment target\",\n-          sourceName,\n-          target.getLineno(), \"\", 0);\n-      }\n       return assign;\n     }\n \n@@ -801,17 +794,6 @@ public class IRFactory {\n         operand.setDouble(-operand.getDouble());\n         return operand;\n       } else {\n-        if (type == Token.INC || type == Token.DEC) {\n-          if (!validAssignmentTarget(operand)) {\n-            String msg = (type == Token.INC)\n-                ? \"invalid increment target\"\n-                : \"invalid decrement target\";\n-            errorReporter.error(\n-              msg,\n-              sourceName,\n-              operand.getLineno(), \"\", 0);\n-          }\n-        }\n \n         Node node = newNode(type, operand);\n         if (exprNode.isPostfix()) {\n@@ -821,15 +803,6 @@ public class IRFactory {\n       }\n     }\n \n-    private boolean validAssignmentTarget(Node target) {\n-      switch (target.getType()) {\n-        case Token.NAME:\n-        case Token.GETPROP:\n-        case Token.GETELEM:\n-          return true;\n-      }\n-      return false;\n-    }\n \n     @Override\n     Node processVariableDeclaration(VariableDeclaration declarationNode) {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -729,7 +729,6 @@ class RemoveUnusedVars\n             assignedToUnknownValue = true;\n           }\n \n-          boolean maybeEscaped = false;\n           for (Assign assign : assignsByVar.get(var)) {\n             if (assign.isPropertyAssign) {\n               hasPropertyAssign = true;\n@@ -737,12 +736,9 @@ class RemoveUnusedVars\n                 assign.assignNode.getLastChild(), true)) {\n               assignedToUnknownValue = true;\n             }\n-            if (assign.maybeAliased) {\n-              maybeEscaped = true;\n-            }\n           }\n \n-          if ((assignedToUnknownValue || maybeEscaped) && hasPropertyAssign) {\n+          if (assignedToUnknownValue && hasPropertyAssign) {\n             changes = markReferencedVar(var) || changes;\n             maybeUnreferenced.remove(current);\n             current--;\n@@ -905,7 +901,7 @@ class RemoveUnusedVars\n       this.nameNode = nameNode;\n       this.isPropertyAssign = isPropertyAssign;\n \n-      this.maybeAliased = NodeUtil.isExpressionResultUsed(assignNode);\n+      this.maybeAliased = !assignNode.getParent().isExprResult();\n       this.mayHaveSecondarySideEffects =\n           maybeAliased ||\n           NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/AVATAR/Chart",
        "content": "@@ -82,9 +82,7 @@\n      */\n     public Range(double lower, double upper) {\n         if (lower > upper) {\n-            String msg = \"Range(double, double): require lower (\" + lower \n-                + \") <= upper (\" + upper + \").\";\n-            throw new IllegalArgumentException(msg);\n+            \n         }\n         this.lower = lower;\n         this.upper = upper;\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SketchFix/Math",
        "content": "@@ -79,7 +79,7 @@\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, entry) >= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -594,7 +594,7 @@ public class Fraction\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return 100 * doubleValue();\n+        return multiply(100).doubleValue();\n     }\n \n     /**\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Closure",
        "content": "@@ -1543,7 +1543,9 @@\n       }\n     } else if (type == Token.CALL) {\n       if (this.getBooleanProp(FREE_CALL) != node.getBooleanProp(FREE_CALL)) {\n-        return false;\n+        if (true)\n+            return true;\n+        return false;\n       }\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/ICSE18",
        "content": "@@ -184,6 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+                    if(!((x == 1) || ((1 < x) && (inverted))))\n                     if (x == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/CapGen/Math",
        "content": "@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return (Double.isNaN(x) && Double.isNaN(x >= 0.0 ? 1.0 : -1.0)) || x == y;\n     }\n \n     /**\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -47,11 +47,6 @@ public class OpenMapRealMatrix extends AbstractRealMatrix\n      */\n     public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n         super(rowDimension, columnDimension);\n-        long lRow = (long) rowDimension;\n-        long lCol = (long) columnDimension;\n-        if (lRow * lCol >= (long) Integer.MAX_VALUE) {\n-            throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false);\n-        }\n         this.rows = rowDimension;\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -228,10 +228,9 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n             throw new UnknownKeyException(\"Column key (\" + columnKey \n                     + \") not recognised.\");\n         }\n+        if (row >= 0) {\n         KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n-        int index = rowData.getIndex(columnKey);\n-        if (index >= 0) {\n-            return rowData.getObject(index);\n+            return rowData.getObject(columnKey);\n         }\n         else {\n             return null;\n@@ -316,29 +315,8 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n         }\n         \n         // 2. check whether the column is now empty.\n-        allNull = true;\n         \n-        for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n-             item++) {\n-            row = (KeyedObjects) this.rows.get(item);\n-            int columnIndex = row.getIndex(columnKey);\n-            if (columnIndex >= 0 && row.getObject(columnIndex) != null) {\n-                allNull = false;\n-                break;\n-            }\n-        }\n         \n-        if (allNull) {\n-            for (int item = 0, itemCount = this.rows.size(); item < itemCount; \n-                 item++) {\n-                row = (KeyedObjects) this.rows.get(item);\n-                int columnIndex = row.getIndex(columnKey);\n-                if (columnIndex >= 0) {\n-                    row.removeValue(columnIndex);\n-                }\n-            }\n-            this.columnKeys.remove(columnKey);\n-        }\n     }\n \n     /**\n@@ -364,10 +342,6 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n      */\n     public void removeRow(Comparable rowKey) {\n         int index = getRowIndex(rowKey);\n-        if (index < 0) {\n-            throw new UnknownKeyException(\"Row key (\" + rowKey \n-                    + \") not recognised.\");\n-        }\n         removeRow(index);\n     }\n \n@@ -401,10 +375,7 @@ public class KeyedObjects2D implements Cloneable, Serializable {\n         Iterator iterator = this.rows.iterator();\n         while (iterator.hasNext()) {\n             KeyedObjects rowData = (KeyedObjects) iterator.next();\n-            int i = rowData.getIndex(columnKey);\n-            if (i >= 0) {\n-                rowData.removeValue(i);\n-            }\n+                rowData.removeValue(columnKey);\n         }\n         this.columnKeys.remove(columnKey);\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -113,10 +113,6 @@\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA)\n             continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jGenProg/Chart",
        "content": "@@ -204,14 +204,6 @@\n         StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n \n         PlotOrientation orientation = plot.getOrientation();\n-        if (orientation == PlotOrientation.HORIZONTAL) {\n-            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n-                    rangeAxis, statData, row, column);\n-        }\n-        else if (orientation == PlotOrientation.VERTICAL) {\n-            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n-                    statData, row, column);\n-        }\n     }\n                 \n     /**\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -108,14 +108,7 @@ public class ShapeList extends AbstractObjectList {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        ShapeList that = (ShapeList) obj;\n-        int listSize = size();\n-        for (int i = 0; i < listSize; i++) {\n-           if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) {\n-               return false;\n-           }\n-        }\n-        return true;\n+        return super.equals(obj);\n \n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/jKali/Chart",
        "content": "@@ -441,7 +441,7 @@\n             h[1] = size.height;\n         }\n         h[2] = constraint.getHeight() - h[1] - h[0];\n-        if (this.leftBlock != null) {\n+        if (false) {\n             RectangleConstraint c3 = new RectangleConstraint(0.0,\n                     new Range(0.0, constraint.getWidth()),\n                     LengthConstraintType.RANGE, h[2], null,\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/RSRepair/Chart",
        "content": "@@ -152,7 +152,10 @@\n                 new Font(\"SansSerif\", Font.BOLD, 12));\n         seriesTitle.setPosition(RectangleEdge.BOTTOM);\n         this.pieChart.setTitle(seriesTitle);\n-        this.aggregatedItemsKey = \"Other\";\n+        if (dataset != null) {\n+            dataset.addChangeListener(this);\n+        }\n+        this.aggregatedItemsKey = \"Other\";\n         this.aggregatedItemsPaint = Color.lightGray;\n         this.sectionPaints = new HashMap();\n     }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/GenProg/Closure",
        "content": "@@ -63,11 +63,6 @@\n \n     Multimap<Reducer, Reduction> reductionMap = HashMultimap.create();\n \n-    // Accumulate possible reductions in the reduction multi map.  They\n-    // will be applied in the loop below.\n-    NodeTraversal.traverse(compiler, root,\n-                           new ReductionGatherer(reducers, reductionMap));\n-\n     // Apply reductions iff they will provide some savings.\n     for (Reducer reducer : reducers) {\n       Collection<Reduction> reductions = reductionMap.get(reducer);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -463,9 +463,6 @@ public final class Fraction extends Number implements Comparable {\n      * @return a new reduced fraction instance, or this if no simplification possible\n      */\n     public Fraction reduce() {\n-        if (numerator == 0) {\n-            return equals(ZERO) ? this : ZERO;\n-        }\n         int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n         if (gcd == 1) {\n             return this;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Kali/Chart",
        "content": "@@ -560,7 +560,7 @@\n             // Collections.binarySearch() and tells us where to insert the\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n-            if (this.autoSort) {\n+            if (false) {\n                 this.data.add(-index - 1, new XYDataItem(x, y));\n             }\n             else {\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Lang",
        "content": "@@ -817,7 +817,7 @@ public class FastDateFormat extends Format {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone, mLocale);\n+        Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SequenceR/Math",
        "content": "@@ -195,7 +195,7 @@\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if((fa)> 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -163,9 +163,6 @@ class PrepareAst implements CompilerPass {\n       Node first = n.getFirstChild();\n \n       // ignore cast nodes.\n-      while (first.isCast()) {\n-        first = first.getFirstChild();\n-      }\n \n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -407,12 +407,10 @@ class SimplexTableau implements Serializable {\n             continue;\n           }\n           Integer basicRow = getBasicRow(colIndex);\n-          if (basicRow != null && basicRow == 0) {\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-              coefficients[i] = 0;\n-          } else if (basicRows.contains(basicRow)) {\n+          if (basicRows.contains(basicRow)) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -111,9 +111,6 @@ public class SubLine {\n \n         // compute the intersection on infinite line\n         Vector3D v1D = line.intersection(subLine.line);\n-        if (v1D == null) {\n-            return null;\n-        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n@@ -115,9 +115,6 @@ public class SubLine extends AbstractSubHyperplane<Euclidean2D, Euclidean1D> {\n \n         // compute the intersection on infinite line\n         Vector2D v2D = line1.intersection(line2);\n-        if (v2D == null) {\n-            return null;\n-        }\n \n         // check location of point with respect to first sub-line\n         Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/Jaid/Math",
        "content": "@@ -184,7 +184,7 @@\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n+                    if ((x == x1) != true && x == x1) {\n                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -342,10 +342,8 @@ public final class MathUtils {\n      * @throws IllegalArgumentException if n < 0\n      */\n     public static long factorial(final int n) {\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n-        }\n-        if (n > 20) {\n+        long result = Math.round(factorialDouble(n));\n+        if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n                     \"factorial value is too large to fit in a long\");\n         }\n@@ -376,9 +374,6 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n         }\n-        if (n < 21) {\n-            return factorial(n);\n-        }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n \n@@ -399,9 +394,6 @@ public final class MathUtils {\n         if (n < 0) {\n             throw new IllegalArgumentException(\"must have n > 0 for n!\");\n         }\n-        if (n < 21) {\n-            return Math.log(factorial(n));\n-        }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n             logSum += Math.log((double)i);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Closure",
        "content": "@@ -95,7 +95,7 @@\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno < sourceExcerpt.length()|| (charno == sourceExcerpt.length()) == true) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -369,6 +369,7 @@\n                 millis = next.getMillis();\n                 saveMillis = next.getSaveMillis();\n                 if (tailZone == null && i == ruleSetCount - 1) {\n+                    if(!((ruleSetCount <= 1) && ((tailZone!=null) || (outputID))))\n                     tailZone = rs.buildTailZone(id);\n                     // If tailZone is not null, don't break out of main loop until\n                     // at least one more transition is calculated. This ensures a\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n+                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -111,6 +111,9 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n             final double[] lI = lTData[i];\n \n+            if (lTData[i][i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n             // check off-diagonal elements (and reset them to 0)\n             for (int j = i + 1; j < order; ++j) {\n                 final double[] lJ = lTData[j];\n@@ -131,9 +134,6 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n             final double[] ltI = lTData[i];\n \n             // check diagonal element\n-            if (ltI[i] < absolutePositivityThreshold) {\n-                throw new NotPositiveDefiniteMatrixException();\n-            }\n \n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Nopol/Math",
        "content": "@@ -188,9 +188,11 @@\n         RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n-        for (int i = 0; i < nVars; i++) {\n-            for (int j = 0; j < i; j++) {\n-              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n-              outMatrix.setEntry(i, j, corr);\n-              outMatrix.setEntry(j, i, corr);\n+        if ((nVars) != (2)) {\n+            for (int i = 0; i < nVars; i++) {\n+                for (int j = 0; j < i; j++) {\n+                    double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n+                    outMatrix.setEntry(i, j, corr);\n+                    outMatrix.setEntry(j, i, corr);\n+                }\n+                outMatrix.setEntry(i, i, 1d);\n             }\n-            outMatrix.setEntry(i, i, 1d);\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -561,7 +561,7 @@\n             // new item...otherwise it will be just -1 and we should just\n             // append the value to the list...\n             if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n+                this.data.add(new org.jfree.data.xy.XYDataItem(x , y));\n             }\n             else {\n                 this.data.add(new XYDataItem(x, y));\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/ICSE18",
        "content": "@@ -234,6 +234,7 @@\n             // are satisfied with the current approximation.\n             if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                      atol)) {\n+                if ((((atol) != (org.apache.commons.math.analysis.solvers.BaseSecantSolver.DEFAULT_ABSOLUTE_ACCURACY)) && (org.apache.commons.math.analysis.solvers.BaseSecantSolver.this.method!=null)) || (f0 <= atol)) {\n                 switch (allowed) {\n                 case ANY_SIDE:\n                     return x1;\n@@ -251,6 +252,7 @@\n             }\n         }\n     }\n+    }\n \n     /** <em>Secant</em>-based root-finding methods. */\n     protected enum Method {\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Math",
        "content": "@@ -135,31 +135,17 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign > 0) {\n+        if (sign >= 0) {\n             // check if either value is close to a zero\n-            if (Math.abs(yMin) <= functionValueAccuracy) {\n-                setResult(min, 0);\n-                ret = min;\n-            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n-                setResult(max, 0);\n-                ret = max;\n-            } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-            }\n-        } else if (sign < 0){\n+        } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n-        } else {\n             // either min or max is a root\n-            if (yMin == 0.0) {\n-                ret = min;\n-            } else {\n-                ret = max;\n-            }\n         }\n \n         return ret;\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -1306,6 +1306,7 @@\n           String line = stream.getRemainingJSDocLine();\n           line = trimEnd(line);\n           builder.append(line);\n+          jsdocBuilder.recordDescription(line);\n           token = next();\n       }\n     } while (true);\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/kPAR/Time",
        "content": "@@ -1165,7 +1165,7 @@\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n+        long instantAfter = getOffset(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Closure",
        "content": "@@ -160,9 +160,7 @@ public abstract class JSType implements Serializable {\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n-        (registry.getNativeFunctionType(\n-             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n+    return isNoType() || isNoObjectType() || isNoResolvedType();\n   }\n \n   public boolean isNumberObjectType() {\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/defects4j-developer/Chart",
        "content": "@@ -854,8 +854,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        TimeSeries clone = (TimeSeries) super.clone();\n-        clone.data = (List) ObjectUtilities.deepClone(this.data);\n+        Object clone = createCopy(0, getItemCount() - 1);\n         return clone;\n     }\n \n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Math",
        "content": "@@ -83,6 +83,9 @@\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n+                    if((rhs == minRatio) == false){\n+                    \tminRatio=rhs;\n+                    \t}\n                     minRatioPos = i; \n                 }\n             }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/DynaMoth/Math",
        "content": "@@ -198,8 +198,10 @@\n         if (fa * fb >= 0.0 ) {\n-            throw new ConvergenceException(\n-                      \"number of iterations={0}, maximum iterations={1}, \" +\n-                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n-                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n-                      numIterations, maximumIterations, initial,\n-                      lowerBound, upperBound, a, b, fa, fb);\n+            if (false) {\n+                throw new ConvergenceException(\n+                \"number of iterations={0}, maximum iterations={1}, \" +\n+                \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+                \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                numIterations, maximumIterations, initial,\n+                lowerBound, upperBound, a, b, fa, fb);\n+            }\n         }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/correct/FixMiner/Math",
        "content": "@@ -1621,9 +1621,9 @@\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n+      double sum=0;\n       for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+          final double dp=p1[i]-p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n",
        "correct": 1
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Jaid/Chart",
        "content": "@@ -941,6 +941,10 @@\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n+        if((startIndex == 1) == true){\n+        \treturn this;\n+\n+        \t}\n         if (endIndex < 0) {\n             emptyRange = true;\n         }\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/SimFix/Closure",
        "content": "@@ -1831,7 +1831,7 @@\n          child != null; child = child.getNext()) {\n       child.useSourceInfoIfMissingFromForTree(other);\n     }\n-\n+    this.propListHead=other.propListHead;\n     return this;\n   }\n\n",
        "correct": 0
    },
    {
        "path": "/home/hpc01/Marcos/Patch_Assesment/Dataset/Cache/patches/Small/overfitting/Cardumen/Chart",
        "content": "@@ -123,7 +123,7 @@\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+        int g = (int) ((java.lang.Math.min(v, upperBound)) / (this.upperBound \n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n\n",
        "correct": 0
    }
]